<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>基于SSM的网上花店系统</title><url>/design/111/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SSM</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 网上花店系统: 可以方便管理人员对网上花店系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，用户管理，花材选择管理、鲜花信息管理、鲜花出入库管理、鲜花出库管理、订单管理、系统管理等。 用户角色：首页、个人中心、我的收藏，订单管理、客户咨询等。 2、前台功能：
首页、个人中心、鲜花信息、鲜花资讯、购物车、客服、后台管理。 本系统是一个B/S模式系统，采用SSM框架作为后台开发技术，前端框架是vue，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得网上花店系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：spring | springmvc | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、用户管理
04、花材选择管理
05、鲜花信息管理
06、鲜花入库管理
07、鲜花出库管理
08、鲜花资讯
09、订单管理
10、前台页面
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的智能物流管理系统</title><url>/design/110/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 智能物流管理系统: 可以方便管理人员对智能物流管理系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、顾客管理、员工管理、店主管理、门店信息管理、门店员工管理、部门分类管理、订单信息管理、工作日志管理。 店主角色：首页、个人中心、员工管理、门店信息管理、门店员工管理、订单信息管理、工作日志管理。 员工角色：首页、个人中心、门店信息管理、订单信息管理、工作日志管理。 顾客角色：首页、个人中心、门店信息管理、订单信息管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得智能物流管理系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、顾客管理
04、员工管理
05、店主管理
06、门店信息管理
07、门店员工管理
08、部门分类管理
09、订单信息管理
10、工作日志管理
项目源码：关注公众号</content></entry><entry><title>基于SSM的党员管理系统</title><url>/design/109/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SSM</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 党员管理系统: 可以方便管理人员对党员管理系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，党员管理，党费登记、奖惩记录、支部管理、基础单位、支部荣誉、支部日志、公告管理等。 支部角色：首页、个人中心、党员管理，党费登记、奖惩记录、基础单位，支部荣誉、支部日志、公告管理等。 党员角色：首页、个人中心、党费缴纳，奖惩记录、公告信息等。 本系统是一个B/S模式系统，采用SSM框架作为后台开发技术，前端框架是JSP，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得党员管理系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | jsp
后端：spring | springmvc | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、党员管理-党员
04、党员管理-党费登记
05、党员管理-奖惩记录
06、支部管理-支部
07、支部管理-基层单位
08、支部管理-支部荣誉
09、支部日志
10、公告管理
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的车辆管理系统</title><url>/design/108/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 车辆管理系统: 可以方便管理人员对车辆管理系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、员工管理、证件信息管理、车辆信息管理、业务单据管理、事故登记管理、维修登记管理、保养登记管理、加油登记管理、违章信息管理。 员工角色：首页、个人中心、证件信息管理、车辆信息管理、业务单据管理、事故登记管理、维修登记管理、保养登记管理、加油登记管理、违章信息管理。 2、前台功能：
无 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得车辆管理系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、员工管理
04、证件信息管理
05、车辆信息管理
06、业务单据管理
07、事故登记管理
08、维修登记管理
09、保养登记管理
10、加油登记管理
11、违章信息管理
项目源码：关注公众号</content></entry><entry><title>基于SSM的新生报到系统</title><url>/design/107/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SSM</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 新生报到系统: 可以方便管理人员对新生报到系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，学院信息，专业信息、班级信息、消息通知、宿舍信息、缴费信息、学生管理、管理员管理等。 学生角色：首页、个人中心、缴费信息，消息通知等。 本系统是一个B/S模式系统，采用SSM框架作为后台开发技术，前端框架是JSP，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得新生报到系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | jsp
后端：spring | springmvc | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、学院信息
04、专业信息
05、班级信息
06、宿舍管理
07、缴费信息
08、学生管理
09、管理员信息
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的在线考试系统</title><url>/design/106/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 在线考试系统: 可以方便管理人员对在线考试系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，用户管理，试卷管理、试题管理、考试管理、考试评分管理、考试统计管理、考试规则管理、专业列表管理、专业类型管理、系统管理等。 用户角色：首页、个人中心、考试规则，试卷列表，考试资讯，参加考试，考试记录，错题本，考试评分等 2、前台功能：
首页、个人中心、考试规则、试卷列表、考试资讯、后台管理 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得在线考试系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、用户管理
04、试卷管理
05、试题管理
06、考试管理
07、考试评分管理
08、考试统计管理
09、考试规则管理
10、专业列表管理
11、专业类型管理
12、前台页面
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的视频网站系统</title><url>/design/105/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 视频网站系统: 可以方便管理人员对视频网站系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，用户管理，视频分享管理，视频排名管理，平台公告管理，视频类型管理，交流论坛管理，留言板管理，系统管理等。 用户角色：首页、个人中心、视频分享管理、留言板管理、交流论坛管理。 2、前台功能：
首页、个人中心、视频分享、视频排名、交流论坛、留言反馈、后台管理 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得视频网站系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、用户管理
04、视频分享管理
05、视频排名管理
06、平台公告管理
07、视频类型管理
08、交流论坛
09、留言板管理
10、轮播图管理
11、前台页面
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的旅游景点导游系统</title><url>/design/104/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 旅游景点导游系统: 可以方便管理人员对旅游景点导游系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、景点类型管理、景点信息管理、线路推荐管理、预定信息管理、论坛交流、系统管理等。 用户角色：首页、个人中心、景点信息管理、预定信息管理、线路推荐管理。 2、前台功能：
首页、个人中心、景点信息、线路推荐、论坛交流、新闻资讯、后台管理 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得旅游景点导游系统工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、用户管理
04、景点类型管理
05、景点信息管理
06、线路推荐管理
07、预定信息管理
08、论坛交流
09、新闻资讯
10、前台页面
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的人事管理系统</title><url>/design/103/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 人事管理系统: 可以方便管理人员对人事系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、部门信息管理、员工信息管理、考勤信息管理、上班记录管理、下班记录管理、加班记录管理、员工薪酬管理等。 员工角色：首页、个人中心、考勤信息管理、上班记录管理、下班记录管理、加班记录管理、员工薪酬管理等。 2、前台功能：
无 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得人事系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面
02、后台首页
03、部门信息管理
04、员工信息管理
05、考勤信息管理
06、上班记录管理
07、下班记录管理
08、加班记录管理
09、员工薪酬管理
项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的学科竞赛系统</title><url>/design/102/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 学科竞赛系统: 可以方便管理人员对学科竞赛系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、教师管理、学生管理、领队教师管理、竞赛类型管理、竞赛信息管理、学院管理、专业管理、获奖情况管理、系统管理等。 教师角色：首页、个人中心、题目类型管理、竞赛题库管理、竞赛类型管理、竞赛信息管理、报名信息管理、竞赛评分管理、参赛名单管理、晋级名单管理、获奖名单管理、竞赛总结管理、报销清单管理、成绩申诉管理、参赛信息管理、参赛信息管理、往年成绩管理、获奖情况管理。 学生角色：首页、个人中心、竞赛题库管理、竞赛类型管理、竞赛信息管理、报名信息管理、竞赛评分管理、参赛名单管理、晋级名单管理、获奖名单管理、竞赛总结管理、报销清单管理、成绩申诉管理、参赛信息管理、参赛信息管理、往年成绩管理、获奖情况管理。 2、前台功能：
首页、个人中心、 竞赛信息、竞赛资讯、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得学科竞赛系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、教师管理 04、学生管理 05、领队教师管理 06、竞赛类型管理 07、竞赛信息管理 08、学院管理 09、专业管理 10、获奖情况管理 11、竞赛资讯 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的知识管理系统</title><url>/design/101/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 知识管理系统: 可以方便管理人员对知识管理系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、文章分类管理、文章信息管理、资料分类管理、资料下载管理、问答管理、论坛交流、留言板管理、系统管理等。 用户角色：首页、个人中心、文章信息管理、资料下载管理、问答管理、我的收藏管理。 2、前台功能：
首页、个人中心、 文章信息、资料下载、问答、论坛交流、留言反馈、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得知识管理系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、文章分类管理 05、文章信息管理 06、资料分类管理 07、资料下载管理 08、问答管理 09、论坛交流 10、留言板管理 11、轮播图管理 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的病历交互系统</title><url>/design/100/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 病历交互系统: 将IT技术用于医疗病历信息的管理, 它能够收集与存储用户病历的档案信息，提供更新与检索病历信息档案的接口；提高工作效率。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、医院管理、医院列表管理、院区展示管理、医院科室管理、科室预约管理、医生管理、病历管理、医疗管理、医院公告、医院文章管理、系统管理。 用户角色：首页、个人中心、科室预约管理、病历管理、医疗管理。 医生角色：首页、个人中心、病历管理、医疗管理、医院文章管理。 2、前台功能：
首页、个人中心、 院区展示、医院文章、医院科室、医生展示、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得病历交互系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、医院管理 05、医院列表管理 06、院区展示管理 07、医院科室管理 08、科室预约管理 09、医生管理 10、病历管理 11、医疗管理 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的课程答疑系统</title><url>/design/99/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 课程答疑系统: 方便管理人员对课程答疑系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、学生管理、老师管理、科目类型管理、学生问题管理、老师回答管理、老师信息管理、关注列表管理、交流区、系统管理。 学生角色：首页、个人中心、科目类型管理、学生问题管理、老师回答管理、老师信息管理、关注列表管理、我的收藏管理。 老师角色：首页、个人中心、老师回答管理、老师信息管理、关注列表管理、我的收藏管理。 2、前台功能：
首页、个人中心、 学生问题、老师回答、老师信息、交流区、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得课程答疑系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、学生管理 04、老师管理 05、科目类型管理 06、学生问题管理 07、老师回答管理 08、老师信息管理 09、关注列表管理 10、交流区 11、轮播图管理 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的洗衣店管理系统</title><url>/design/98/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 洗衣店管理系统: 方便管理人员对洗衣店管理系统的管理，提高信息管理工作效率及查询效率，有利于更好的为用户提供服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、顾客管理、店家管理、店铺信息管理、衣服类型管理、洗衣信息管理、订单信息管理、订单进度管理、交流区、系统管理等。 顾客角色：首页、个人中心、店铺信息管理、洗衣信息管理、订单信息管理、订单进度管理等。 店家角色：首页、个人中心、店铺信息管理、衣服类型管理、洗衣信息管理、订单信息管理、订单进度管理等。 2、前台功能：
首页、个人中心、 店铺信息、交流区、系统公告、后台管理、在线客服。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得洗衣店管理系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、顾客管理 04、店家管理 05、店铺信息管理 06、衣服类型管理 07、洗衣信息管理 08、订单信息管理 09、订单进度管理 10、交流区 11、系统公告 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的服装生产管理系统</title><url>/design/97/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 服装生产管理系统: 提高信息管理工作效率及查询效率，将互联网与信息技术应用于经营与管理，以现代化工具代替传统手工作业。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、样板管理、成品检验管理、原料仓库管理、原料入库管理、原料出库管理、成衣仓库管理、成衣出库管理、订单管理、人事安排管理、考勤管理、工资管理、系统管理等。 用户角色：首页、个人中心、样板管理、考勤管理、工资管理、系统管理等。 2、前台功能：
首页、个人中心、 人事安排、样板、系统公告、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得服装生产管理系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、样板管理 05、成品检验管理 06、原料仓库管理 07、原料入库管理 08、原料出库管理 09、成衣仓库管理 10、成衣出库管理 11、订单管理 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的宠物咖啡馆系统</title><url>/design/96/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 宠物咖啡馆系统: 提高信息管理工作效率及查询效率，有利于更好的为人们服务，将互联网与信息技术应用于经营与管理，以现代化工具代替传统手工作业。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、看护师管理、宠物信息管理、宠物体验管理、宠物订单管理、宠物寄养管理、健康状况管理、互动项目管理、看护服务管理、咖啡菜品管理、菜品类型管理、菜品订单管理、周边商品管理、商品类型管理、商品购买管理、商品入库管理、系统管理等。 用户角色：首页、个人中心、咖啡菜品管理、菜品订单管理、宠物信息管理、宠物体验管理、宠物订单管理、宠物寄养管理、健康状况管理、看护服务管理、周边商品管理、商品购买管理、我的收藏管理等。 看护师角色：首页、个人中心、宠物体验管理、宠物寄养管理、健康状况管理、看护服务管理等。 2、前台功能：
首页、个人中心、 咖啡菜品、宠物信息、周边商品、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得宠物咖啡馆系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、看护师管理 05、宠物信息管理 06、宠物体验管理 07、宠物订单管理 08、宠物寄养管理 09、健康状况管理 10、互动项目管理 11、看护服务管理 12、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的旅游管理系统</title><url>/design/95/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 旅游管理系统: 适合部份景点的管理系统，力求创造好的用户体验，将互联网与信息技术应用于经营与管理，以现代化工具代替传统手工作业。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，用户管理、景点信息管理、订票信息管理、用户评价管理、系统管理等。 用户角色：首页、个人中心，订票信息管理、用户评价管理。 2、前台功能：
首页、个人中心、 景点信息、景点资讯、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得旅游管理系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、景点信息管理 05、订票信息管理 06、用户评价管理 07、景点资讯 08、轮播图管理 09、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的校园资料分享系统</title><url>/design/94/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 校园资料分享系统: 适合校园内的资料分享系统，让信息的交换和信息流通显得特别重要，将互联网与信息技术应用于经营与管理，以现代化工具代替传统手工作业。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，学生管理、资料分享管理、资料分类管理、举报反馈管理、系统管理等。 学生角色：首页、个人中心，资料分享管理、资料评价、我的收藏管理。 2、前台功能：
首页、个人中心、 资料分享、公告资讯、后台管理、在线客服。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得校园资料分享系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、学生管理 04、资料分享管理 05、资料分类管理 06、举报反馈管理 07、在线客服 08、公告资讯 09、前台页面 项目源码：关注公众号</content></entry><entry><title>基于SpringBoot的大学生就业招聘系统</title><url>/design/93/</url><categories><category>项目源码</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 大学生就业招聘系统: 适合大学生就业招聘流程的系统，将互联网与信息技术应用于经营与管理，使用网络信息化管理使信息管理更先进、更高效、更科学，信息交流更迅速。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，用户管理、企业管理、岗位分类管理、招聘信息管理、岗位申请管理、在线留言管理、求职信息管理、邀请面试管理、系统管理。 用户角色：首页、个人中心，岗位申请管理、在线留言管理、求职信息管理、邀请面试管理。 企业角色：首页、个人中心、招聘信息管理、岗位申请管理、在线留言管理、邀请面试管理。 2、前台功能：
首页、个人中心、 招聘信息、求职信息、后台管理。 本系统是一个B/S模式系统，采用SpringBoot框架作为后台开发技术，前端框架是VUE，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得大学生就业招聘系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、企业管理 05、岗位分类管理 06、招聘信息管理 07、岗位申请管理 08、在线留言管理 09、求职信息管理 10、邀请面试管理 11、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的新闻推荐系统</title><url>/design/92/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 新闻推荐系统: 将互联网与信息技术应用于经营与管理，使用网络信息化管理使信息管理更先进、更高效、更科学，信息交流更迅速。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，用户管理、排行榜管理、新闻管理、我的收藏管理、系统管理。 用户角色：首页、个人中心，我的收藏管理。 2、前台功能：
首页、个人中心、 排行榜、新闻、后台管理。 本系统是一个B/S模式系统，采用Spring Boot框架作为开发技术，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得新闻推荐系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、排行榜管理 05、新闻管理 06、我的收藏管理 07、轮播图管理 08、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的美容院管理系统</title><url>/design/91/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 美容院管理系统: 通过电子的方式进行保存，让信息系统化，流程化，规范化，无论是管理人员检索美容院信息，维护美容院信息都可以便利化操作，真正缩短信息处理时间，节省人力和信息管理的成本。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，普通用户管理、会员管理、技师管理、前台管理、美容用品管理、美容项目管理、用户预约信息管理、会员预约信息管理、美容部位管理、销售信息管理、库存信息管理、业绩统计管理、消费信息管理、订单信息管理。 技师角色：首页、个人中心、美容用品管理、美容项目管理、用户预约信息管理、会员预约信息管理、技师月业绩统计管理、技师年业绩统计管理。 前台角色：首页、个人中心、普通用户管理、会员管理、用户预约信息管理、会员预约信息管理、前台月业绩统计管理、前台年业绩统计管理。 2、前台功能：
首页、个人中心、 美容用品、美容项目、用户预约信息、会员预约信息、后台管理、购物车。 本系统使用Java语言进行开发，采用Spring Boot框架，MYSQL数据库设计，充分保证系统的稳定性，系统具有界面清晰、操作简单，功能齐全。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 以技师角色功能为例：
01、登录页面 02、后台首页 03、美容用品管理 04、美容项目管理 05、用户预约信息管理 06、会员预约信息管理 07、技师月业绩统计管理 08、技师年业绩统计管理 09、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的社区医院信息系统</title><url>/design/90/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 社区医院信息系统: 可以方便管理人员对信息管理更先进、更高效、更科学，提高信息管理工作效率及查询效率，有利于更好的为人们服务。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，患者管理、护士管理、医生管理、药品管理员管理。 医生角色：首页、个人中心、患者管理、检查结果管理、诊断信息管理。 护士角色：首页、个人中心、患者管理、待检查列表管理、检查结果管理、注射列表管理、完成注射列表管理、注射取药列表管理。 药品管理员角色：首页、个人中心、诊断信息管理、药品信息管理、药品进价管理、取药列表管理、注射列表管理、药费结算管理。 患者角色：首页、个人中心、检查结果管理、诊断信息管理、取药列表管理、药费结算管理。 2、前台功能：
首页、个人中心、 检查结果、诊断信息、取药列表、药费结算、后台管理。 本系统是一个B/S模式系统，采用Spring Boot框架，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，可以使管理人员从繁重的工作中解脱出来，实现无纸化办公。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 以护士角色功能为例：
01、登录页面 02、后台首页 03、患者管理 04、待检查列表管理 05、检查结果管理 06、注射列表管理 07、完成注射列表管理 08、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的教师工作量管理系统</title><url>/design/89/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 教师工作量管理系统: 采用电子化的存储方式，解决传统的人工方式去管理，导致管理效率低下、出错频率高等问题。此系统对查询、更新还有维护会带来很大便利。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，教师管理，分类信息管理，课程信息管理，工作量管理，系统管理等。
员工角色：首页、个人中心，课程信息管理，工作量管理。
2、前台功能：
首页、个人中心、课程信息、系统公告、后台管理。 本系统是一个B/S模式系统，后台采用SpringBoot框架，MYSQL数据库设计开发。
系统具有界面清晰、操作简单，功能齐全的特点，使得教师工作量系统化、规范化。
本系统可以使管理人员从繁重的工作中解脱出来，实现无纸化办公，能够有效的提高教师管理效率。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、教师管理 04、分类信息管理 05、课程信息管理 06、工作量管理 07、系统公告 08、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的在线文档管理系统</title><url>/design/88/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 在线文档管理系统: 一款针对文档无纸化办公系统，减少传统的纸质作为信息管理工具，能及时查询、修改、了解文档信息，解决获取信息便捷化、全面化的问题，提高效率。
主要的模块包括：
1、管理员角色：首页、个人中心、公告信息管理、部门信息管理、岗位管理、员工管理、文档信息管理。
2、员工角色：首页、个人中心、公告信息管理、文档信息管理。
使用Java语言进行编码，后台使用SpringBoot框架，MYSQL数据库设计。
本系统根据需求可以进行在线添加，删除或修改文档信息，这样既能节省时间，不用再像传统的方式耽误时间，提高管理员的工作效率，减少原有不必要的工作量
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、公告信息管理 04、部门信息管理 05、岗位管理 06、员工管理 07、文档信息管理 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的学生宿舍管理系统</title><url>/design/87/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 学生宿舍管理系统: 无纸化办公系统，搭配信息管理工具可以很好为学生服务，也可以解决学生宿舍信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，同时降低信息管理成本，实现信息管理计算机化。
主要的模块包括：
1、宿管员角色：首页、个人中心、学生管理、学生信息管理、公寓资产管理、资产损坏管理、资产新增管理、缴费信息管理、清理公共场所管理、日常事务管理、日常事务管理。
2、学生角色：首页、个人中心、学生信息管理、公寓资产管理、缴费信息管理、清理公共场所管理、日常事务管理、日常事务管理。
使用Java语言进行开发，采用SpringBoot框架，MYSQL数据库设计。
本系统不仅可以实时完成信息处理，还缩短学生宿舍信息管理流程，使其系统化和规范化。
同时还可以减少工作量，节约学生宿舍信息管理需要的人力和资金。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、学生管理 04、学生信息管理 05、公寓资产管理 06、资产损坏管理 07、资产新增管理 08、缴费信息管理 09、清理公共场所管理 10、日常事物管理 11、床位安排管理 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的学生读书笔记共享系统</title><url>/design/86/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 学生读书笔记共享系统：是一款方便、快捷、实用的系统，让用户更有针对性的获取到更多信息和详细，了解最新读书笔记共享信息。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、笔记分享管理、个人笔记管理、管理员管理、交流互动、系统管理。 用户角色：首页、个人中心、笔记分享管理、个人笔记管理、我的收藏管理。 2、前台功能：
首页、笔记分享、交流信息、个人中心、后台管理。 使用Java语言进行开发，采用B/S架构，后台使用SpringBoot框架，MYSQL数据库设计，新手上手更加简单，快速。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、用户管理 04、笔记分享管理 05、个人笔记管理 06、交流互动 07、公告信息 08、前台首页 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的大学生租房平台系统</title><url>/design/85/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 大学生租房平台系统：是一个集中管理房东和用户，使信息管理能够更加科学和规范，可以解决大学生租房信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、房东管理、信息审批管理、房源信息管理、订单信息管理、系统管理。 学生角色：首页、个人中心，房源收藏管理、订单信息管理。 房东角色：首页、个人中心、信息审批管理、房源信息管理、订单信息管理。 2、前台功能：
首页、个人中心、房源信息、后台管理。 使用Java语言进行编码，后台采用SpringBoot框架，MYSQL数据库设计，前台页面Vue技术开发。
本系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、学生管理 04、房东管理 05、信息审批管理 06、房源信息管理 07、订单信息管理 08、首页轮播图管理 09、前台首页 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的学生心理咨询评估系统</title><url>/design/84/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 学生心理咨询评估系统：可以实现定期给学生进行心理评估，帮助学生了解自己的心理情况，也保护学生尴尬和隐私，解决了管理者处理数据时间很长，数据存在错误不能及时纠正等问题，方便及提高管理者人员的工作效率。
主要的模块包括：
1、管理员角色：首页、个人中心，用户管理，试题管理，试卷管理，考试管理。
2、学生角色：首页、个人中心、考试管理（试卷列表、考试记录）。
本系统采用主流的JAVA语言开发，后台采用SpringBoot框架，MYSQL数据库设计，访问页面Vue技术开发。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、学生管理 04、试题管理 05、试卷管理 06、考试管理_错题本 07、考试管理_试卷列表 08、考试管理_考试记录 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的图书个性化推荐系统</title><url>/design/83/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 图书个性化推荐系统：可以实现图书个性化推荐，方便学生知道自己的喜好，也可以方便管理员进行更加方便快捷的管理书籍和学生方便借还书籍，还可以提高管理人员的工作效率。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、学生管理、图书分类管理、图书信息管理、图书预约管理、退换图书管理、管理员管理、留言板管理、系统管理。 学生角色：首页、个人中心、图书预约管理、退换图书管理、我的收藏管理。 2、前台首页：
首页、图书信息、好书推荐、留言反馈、个人中心、后台管理等功能。 本系统使用JAVA语言开发，采用SpringBoot框架，MYSQL数据库设计开发，代码简洁，小白可以快速上手。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、后台学生管理 04、后台图书分类管理 05、后台图书信息管理 06、后台图书预约管理 07、后台退还图书管理 08、留言板管理 09、好书推荐功能 10、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的医护人员排班系统</title><url>/design/82/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 医护人员排班系统：基于B/S架构使管理人员从繁重的工作中解脱出来，实现无纸化办公，能够有效的提高医护人员排班系统管理效率。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心，医院信息管理，医护信息管理，医护类型管理，排班信息管理，排班类型管理，科室信息管理，投诉信息管理。 用户角色：首页、个人中心、查看自己的排班信息，查看我的收藏信息。 2、前台首页：
首页、医院信息、医护信息、科室信息、投诉信息、论坛、个人中心、后台管理等功能。 本站是一个B/S模式系统，采用Spring Boot框架，MYSQL数据库设计开发，充分保证系统的稳定性。
系统具有界面清晰、操作简单，功能齐全的特点，使得医护人员排班系统管理工作系统化、规范化。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、后台医院信息管理 04、后台医护信息管理 05、后台医护类型管理 06、后台排班信息管理 07、后台排班类型管理 08、后台科室信息管理 09、后台投诉信息管理 10、前台页面 项目源码：关注公众号</content></entry><entry><title>毕业设计：基于SpringBoot的在线拍卖系统</title><url>/design/81/</url><categories><category>毕业设计</category></categories><tags><tag>毕业设计</tag><tag>课程设计</tag><tag>SpringBoot</tag><tag>Java</tag></tags><content type="html"> 一、系统介绍 在线拍卖系统：一个在线的拍卖网站，用户可以发布商品，进行拍卖，管理员可以对商品进行管理，对商品进行上架、下架、删除、修改等操作。
本系统的开发使获取在线拍卖系统信息能够更加方便快捷，同时也使在线拍卖系统信息变的更加系统化、有序化。系统界面较友好，易于操作。
主要的模块包括：
1、后台功能：
管理员角色：首页、个人中心、用户管理、商品类型管理、拍卖商品管理、历史竞拍管理、竞拍订单管理、留言板管理、系统管理， 用户角色：首页、个人中心、历史竞拍管理、竞拍订单管理、留言板管理， 2、前台首页：
首页、拍卖商品、竞拍公告、留言反馈、个人中心、后台管理等功能。 本文中数据库服务器端采用了Mysql作为后台数据库，使Web与数据库紧密联系起来。
在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
二、系统架构 前端：html | js | css | jquery | vue
后端：springboot | mybatis
环境：jdk1.8+ | mysql | maven
数据库表结构 代码运行 三、系统各功能 01、登录页面 02、后台首页 03、后台用户管理 04、后台商品类型管理 05、后台拍卖商品管理 06、后台历史竞拍管理 07、后台竞拍订单管理 08、后台竞拍公告 09、前台页面 项目源码：关注公众号</content></entry><entry><title>MacOS下使用pyinstaller打包PyQt5程序</title><url>/post/76/</url><categories><category>Python</category></categories><tags><tag>pyinstaller</tag><tag>PyQt5</tag><tag>MacOS</tag></tags><content type="html"><![CDATA[  1、准备 （1）PyQt5开发的程序
（2）使用该项目单独的虚拟环境，必免将一些不必要的依赖打包到应用中
# 1、创建python虚拟环境 python -m venv venv # 2、安装程序依赖，这个开发时都已安装 # 3、虚拟环境安装pyinstaller pip install pyinstaller 2、pyinstaller介绍 pyinstaller是一个开源工具，用于将Python程序转换为独立的可执行文件。
这些可执行文件可以在没有Python环境的情况下在Windows、Linux和macOS上运行。
pyinstaller通过分析Python脚本中的导入语句来确定程序需要的所有依赖项，并将这些依赖项以及脚本本身打包成一个或多个文件。
3、pyinstaller常用参数 命令查看参数：pyinstaller --help
常用参数：
pyinstaller常用参数 说明 -F(&ndash;onefile) 将程序打包成一个单独的可执行文件 -D(&ndash;onedir) 默认参数，与-F相反，将打包的结果放到一个文件夹中，文件夹里可以看到很多依赖文件 -w(&ndash;windowed) 隐藏命令行窗口 -c(&ndash;console) 显示命令行窗口 -p(&ndash;paths) 自己定义需要加载的路径，比如项目中有多个自建模块时需要加上这个参数，
多个文件可以使用:分割，也可以多次使用这个参数 -i(&ndash;icon) 程序图标，macos下图标文件为 icns 格式， windows 为ico 格式 -n(&ndash;name) 程序名称，不加该参数时，默认 .py 的文件名 &ndash;hidden-import 需要导入的隐藏模块 &ndash;add-data 将额外的数据文件添加到打包的应用程序中。 注：-F与-D参数不能同时使用，它们互斥。-w与-c参数不能同时使用，它们互斥。
4、打包 mac系统打包命令示例：
pyinstaller -w -p imgToWebp.py -p libwebpDesc.py -i &#39;app.icns&#39; -n &#39;ImageC&#39; --add-data &#39;resources:resources&#39; main.py 注意事项 （1）macos下打包时不建议使用-F参数，我是没打包成功，所以使用-D参数打包，默认参数可以不用写。
（2）使用--add-data 'resources:resources'表示将resources文件夹下内容，添加到应用中的resources文件夹下。
代码中获取资源路径需要修改，代码如下：
# 获取资源文件路径 def resources_path(relative_path): if getattr(sys,&#39;frozen&#39;,False): base_path = sys._MEIPASS else: base_path = os.path.abspath(&#34;.&#34;) return os.path.join(base_path,relative_path) 我的资源文件在resources文件夹下，使用时resources_path(&quot;resources&quot;)获取到了打包后资源文件夹的路径。
（3）mac下图标文件为icns格式，windows为ico格式
  ]]></content></entry><entry><title>Python小工具：图片转icns格式和ico格式</title><url>/post/77/</url><categories><category>Python</category></categories><tags><tag>icns格式</tag><tag>ico格式</tag></tags><content type="html"><![CDATA[  1、准备 （1）PyQt5开发的程序
（2）使用该项目单独的虚拟环境，必免将一些不必要的依赖打包到应用中
# 1、创建python虚拟环境 python -m venv venv # 2、安装程序依赖，这开发时都已安装 # 3、虚拟环境安装pyinstaller pip install pyinstaller 图片转icns格式： 一是：python代码转换，二是：shell脚本转换 python代码方式一：
import os import shutil import subprocess # 图片输入路径 img_path = &#34;&#34; # icns输出文件夹 icns_output_dir = &#34;&#34; img_dir = os.path.dirname(img_path) img_name = os.path.splitext(os.path.basename(img_path))[0] icns_temp = f&#39;{img_dir}/test.iconset&#39; if not os.path.exists(icns_temp): os.makedirs(icns_temp) if not os.path.exists(icns_output_dir): os.makedirs(icns_output_dir) ml = f&#39;&#39;&#39; sips -z 16 16 {img_path} --out {icns_temp}/icon_16x16.png sips -z 32 32 {img_path} --out {icns_temp}/icon_16x16@2x.png sips -z 32 32 {img_path} --out {icns_temp}/icon_32x32.png sips -z 64 64 {img_path} --out {icns_temp}/icon_32x32@2x.png sips -z 128 128 {img_path} --out {icns_temp}/icon_128x128.png sips -z 256 256 {img_path} --out {icns_temp}/icon_128x128@2x.png sips -z 256 256 {img_path} --out {icns_temp}/icon_256x256.png sips -z 512 512 {img_path} --out {icns_temp}/icon_256x256@2x.png sips -z 512 512 {img_path} --out {icns_temp}/icon_512x512.png sips -z 512 512 {img_path} --out {icns_temp}/icon_512x512@2x.png &#39;&#39;&#39; pic = subprocess.Popen(ml, shell=True) pic.wait() ml = f&#39;iconutil -c icns {icns_temp} -o {icns_output_dir}/{img_name}.icns&#39; icon = subprocess.Popen(ml, shell=True) icon.wait() #删除临时文件 if os.path.exists(icns_temp): shutil.rmtree(icns_temp) python代码方式二：
# 安装依赖 pip install pillow from PIL import Image # 源图片路径 source_image_path = &#39;source_image.png&#39; # 替换为你的图片文件名 # 目标ICO图片路径 target_ico_path = &#39;target_image.ico&#39; # 定义一个尺寸列表，可以是16, 32, 48, 64, 128, 256 sizes = [16, 32, 48, 64, 128, 256] # 打开图片 image = Image.open(source_image_path) # 转换为ICO格式 image.save(target_ico_path, &#39;ICO&#39;,sizes=sizes) print(f&#39;ICO图标已保存至： {target_ico_path}&#39;) shell脚本方式：
# !/bin/bash # 图片输入路径 input=$1; # icns输出文件夹 output=$2; if [ ! -f &#34;$input&#34; ]; then echo &#34;$input 文件不存在&#34; exit 0; fi current_folder=$(dirname &#34;$inupt&#34;) file_name_with_ext=$(basename &#34;$input&#34;) file_name=&#34;${file_name_with_ext%.*}&#34; if [ ! -d &#34;$output&#34; ]; then echo &#34;$output 文件夹不存在&#34; exit 0; fi mkdir icons.iconset tmp=&#34;$current_folder/icons.iconset&#34; setIconImage(){ sips -z 16 16 $input --out $tmp/icon_16x16.png sips -z 32 32 $input --out $tmp/icon_16x16@2x.png sips -z 32 32 $input --out $tmp/icon_32x32.png sips -z 64 64 $input --out $tmp/icon_32x32@2x.png sips -z 64 64 $input --out $tmp/icon_64x64.png sips -z 128 128 $input --out $tmp/icon_64x64@2x.png sips -z 128 128 $input --out $tmp/icon_128x128.png sips -z 256 256 $input --out $tmp/icon_128x128@2x.png sips -z 256 256 $input --out $tmp/icon_256x256.png sips -z 512 512 $input --out $tmp/icon_256x256@2x.png sips -z 512 512 $input --out $tmp/icon_512x512.png sips -z 1024 1024 $input --out $tmp/icon_512x512@2x.png } setIconImage iconutil -c icns $tmp -o &#34;$output/$file_name.icns&#34; rm -rf $tmp   ]]></content></entry><entry><title>PyQt5开发简单的图片转换器，将图片格式转换为webp格式</title><url>/post/75/</url><categories><category>Python</category></categories><tags><tag>PyQt5开发</tag><tag>图片转换器</tag><tag>webp格式</tag></tags><content type="html"><![CDATA[  1、准备 （1）在项目下创建python虚拟环境及安装PyQt5：
# 创建python虚拟环境 python -m venv venv # 在虚拟环境中安装PyQt5 pip install PyQt5 （2）Webp工具下载： webp下载地址 2、Webp介绍 WebP 是 Google 开发的图片格式，其设计目标是提高图片质量，降低图片大小。
3、简单图片转换器开发 （1）开发这个工具的原因：
个人博客网站经常使用图片，在博客网站上，图片的大小和格式都比较重要。
与其他格式图片对比发现，Webp格式图片的压缩率高，图片质量高，图片大小小，所以使用Webp格式图片。
其他格式图片转换为webp格式需要使用Webp转换工具，这个工具只是命令行操作，需要经常手动复制路径，很麻烦。
所以我就使用PyQt5简单的封装下制作一个简单的界面操作小工具，方便自己操作。
（2）项目结构
（3）界面设计 使用QtDesigner设计的界面虽然有点Low，但是可以满足基本需求的界面化操作，不必总是在命令行里复制、粘贴输入和输出路径参数。
（4）文件转换
ui文件转换为python文件： 这步操作是最简单的，只需之前配置好的辅助工具Pyuic，点几下就可以，每次ui文件修改了只需这么简单操作一下，就可以完成python文件的转换，使用方法如下：
qrc文件转换为python文件： 项目中暂时没有资源文件，这个就无需操作了，使用方法与ui文件转换一样。
（5）启动程序
启动方式有两种：一种是直接加载ui文件启动，另一种是将ui文件转换为python文件启动。
因为我使用了辅助工具Pyuic，每次修改ui文件后再编译为python文件非常方便，基本上我都采用将ui文件转换为python文件启动。
启动方式一：直接加载ui文件启动 import sys from PyQt5 import uic from PyQt5.QtWidgets import QApplication, QWidget class ImgWidget(QWidget): def __init__(self): super().__init__() uic.loadUi(&amp;#34;imgToWebp.ui&amp;#34;, self) if __name__ == &amp;#39;__main__&amp;#39;: app = …  ]]></content></entry><entry><title>PyCharm配置PyQt5的3个超级好用插件</title><url>/post/74/</url><categories><category>Python</category></categories><tags><tag>QtDesigner</tag><tag>Pyuic</tag><tag>Pyrcc</tag></tags><content type="html"> 1、环境准备 （1）创建python虚拟环境使用：python -m venv 虚拟环境名称
（2）激活并进入虚拟环境：
在MacOS或Linux系统下使用：source 虚拟环境的名称/bin/activate 在windows系统下使用：虚拟环境的名称/Scripts/activate （3）在终端或命令提示符中输入以下命令即可安装PyQt5及Qt工具包：
pip install PyQt5 pip install pyqt5-tools 注：如果虚拟环境经常使用可以使用固定路径，不必要建在项目目录下。我自己的配置是一个基础的环境（路径是固定的），所有项目都可以使用，另一种就是单独项目配置的环境（虚拟环境路径在项目下）。
以下配置我都是MacOS系统下的配置，其他系统请根据实际情况进行修改。
如上两张图所示，在PyCharm中，有两种路径进入External Tools添加工具。
使用pip安装好PyQt5依赖库和Qt工具包后，相应的QtDesigner、Pyuic、Pyrcc三个工具都会自动安装。我们只需要找路径配置就可以
2、PyCharm配置QtDesigner Name：QtDesigner // 扩展工具名称 Group：External Tools Description：通过Qt语言进行UI设计（支持拖拽式的UI设计）。 // 扩展工具功能描述 Program： 虚拟环境的路径/lib/python3.7/site-packages/qt5_applications/Qt/bin/Designer.app //扩展工具执行文件路径 Working directory：$FileDir$ //扩展工具工作目录为当前python工程的路径 如何使用： 在PyCharm中的工具栏Tools——&amp;amp;gt;External Tools——&amp;amp;gt;点击QtDesigner 就可以打开QtDesigner进行UI设计了。
3、PyCharm配置Pyuic Name：Pyuic // 扩展工具名称 Group：External Tools Description：将QtDesigner设计的ui文件转化成Python代码文件。 // 扩展工具功能描述 Program： 虚拟环境的路径/bin/pyuic5 // …</content></entry><entry><title>PyQt5入门,Python的GUI应用程序开发利器</title><url>/post/73/</url><categories><category>Python</category></categories><tags><tag>PyQt5</tag><tag>GUI库</tag></tags><content type="html"><![CDATA[  在众多的Python GUI库中，PyQt5无疑是其中的佼佼者。
通过简单的示例让大家快速上手PyQt5。
1、PyQt5介绍 PyQt5是一个用于创建图形用户界面（GUI）应用程序的Python库，它是基于Qt框架的。
PyQt5将Qt库的强大功能带到了Python编程语言中，使得开发者能够利用Python的简洁语法来构建美观且功能强大的GUI应用。
2、PyQt5的优势 （1）跨平台：PyQt5 支持多种操作系统，如 Windows、macOS、Linux 等。
（2）丰富的控件：PyQt5 提供了丰富的控件，如按钮、文本框、列表等，满足各种界面需求。
（3）信号与槽机制：PyQt5 通过信号与槽机制实现控件之间的通信，使得界面更新和事件处理更加高效。
（4）自定义样式：PyQt5 支持自定义样式，可以根据需求调整界面美观程度。
3、安装PyQt5 （1）创建python虚拟环境使用：python -m venv 虚拟环境名称
（2）激活并进入虚拟环境：
在MacOS或Linux系统下使用：source 虚拟环境的名称/bin/activate 在windows系统下使用：虚拟环境的名称/Scripts/activate （3）在终端或命令提示符中输入以下命令即可安装PyQt5：
pip install pyqt5 4、PyQt5的使用 （1）简单的窗口，并写上Hello world
import sys from PyQt5.QtWidgets import QApplication, QWidget, QLabel if __name__ == &amp;#39;__main__&amp;#39;: aap = QApplication(sys.argv) w = QWidget() w.setWindowTitle(&amp;#34;简单的窗口&amp;#34;) w.setGeometry(150, 150, 300, 200) # 四个值分别是：x轴，y轴，宽，高 label = QLabel(&amp;#34;Hello World&amp;#34;, w) # 指定这个控件名称及父窗口 label.move(100, 80) # 修改控件位置，两值分别是：x轴，y轴，位置起点是父窗口的左上脚 w.show() sys.exit(aap.exec_()) （2）创建窗口
在 PyQt5 中，创建窗 …  ]]></content></entry><entry><title>用Python的venv库管理虚拟环境</title><url>/post/72/</url><categories><category>Python</category></categories><tags><tag>venv</tag><tag>虚拟环境</tag></tags><content type="html"> Python的venv库是创建和管理虚拟环境。
venv库不需要安装，是python自带的模块。
1、venv库的主要特点 1、隔离性：一个虚拟环境和另一个虚拟环境之间完全独立，一个虚拟环境的包不会影响另一个虚拟环境的包。
2、可移植性：一个虚拟环境可以被复制到另一个系统上，而不用担心它与原来的系统发生冲突。
3、可操作性：通过venv库，可以轻松地创建、删除和使用虚拟环境。
4、可重复性：通过venv库，可以轻松地重复创建同一个虚拟环境。
2、venv的使用方法 （1）创建虚拟环境：
语法：python3 -m venv 虚拟环境的名称
示例：python3 -m venv venv ,表示创建名为venv的虚拟环境。
参数解释：
-m：表示使用模块模式，后面指定模块。
venv：venv是Python的内置模块，用于创建虚拟环境。
venv：表示创建的虚拟环境的名称。(可以使用绝对路径，也可以使用相对路径，相对路径是在命令执行的当前目录下创建的。)
（2）激活虚拟环境：
在MacOS或Linux系统下，激活虚拟环境的命令是：source 虚拟环境的名称/bin/activate
在windows系统下，激活虚拟环境的命令是：虚拟环境的名称/Scripts/activate
示例：source venv/bin/activate
（3）使用虚拟环境
未安装库时，使用pip list查看当前虚拟环境的包列表。 在虚拟环境安装PyQt5库和Qt工具包：
安装PyQt5库：pip install PyQt5 安装Qt工具包：pip install pyqt5-tools 安装PyQt5库和Qt工具包后，使用pip list查看当前虚拟环境的包列表。 从虚拟环境生成requirement.txt文件，这样生成的requirement.txt文件只包含虚拟环境中已安装的依赖包。
生成命令：pip freeze &amp;gt; requirement.txt
（4）退出虚拟环境
退出虚拟环境的命令是：deactivate</content></entry><entry><title>Redission入门：一款强大的Java分布式锁库</title><url>/post/66/</url><categories><category>Java库</category></categories><tags><tag>Redission入门</tag></tags><content type="html"><![CDATA[  在分布式系统中，锁的作用是确保多个节点在访问共享资源时能够正确同步，防止数据不一致。
随着业务的发展和系统的扩展，对锁的需求也日益增加。
介绍一款强大的Java分布式锁库——Redission。
1、什么是Redission？ Redission是一个基于Redis的分布式锁库，具有高性能、可靠、易用等特点。
它提供了多种锁类型和丰富的功能，可满足各种分布式场景下的锁需求。
我将简单从Redission的原理、使用方法和结合简单示例进行展示。
2、Redission原理 Redission主要通过Redis的哈希表、字符串和有序集合等数据结构来实现锁的功能。
哈希表用于存储锁的信息，字符串用于存储锁的值，有序集合用于实现锁的过期时间。
当客户端请求锁时，Redission会在Redis中创建一个唯一的锁标识，并根据锁的配置设置相应的过期时间。
当客户端释放锁时，Redission会删除对应的锁标识，使其他客户端可以获取该锁。
3、Redission使用 （1）添加依赖
在项目的pom.xml文件中添加redisson的依赖，还需要在项目中引入Redis客户端依赖，例如Lettuce或Jedis，我使用lettuce为例：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.redisson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.23.5&amp;lt;/version&amp;gt; &amp;lt;!-- 请根据实际情况选择版本 --&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.lettuce&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lettuce-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;6.2.6.RELEASE&amp;lt;/version&amp;gt; &amp;lt;!-- 请根据实际情况选择版本 --&amp;gt; &amp;lt;/dependency&amp;gt; （2）创建RedissonClient实例
Config config = new Config(); …  ]]></content></entry><entry><title>Druid入门：一款强大的Java数据连接池工具</title><url>/post/65/</url><categories><category>Java库</category></categories><tags><tag>Druid入门</tag></tags><content type="html"><![CDATA[  介绍Druid这个Java库，帮助了解其功能、特点以及如何使用。
面向新手人群，以通俗易懂的语言解释Druid的相关概念，并通过示例展示如何使用Druid实现数据连接池。
1、什么是Druid？ Druid是一个用于Java语言的数据库连接池工具。
它可以帮助我们管理和维护数据库连接，提高应用程序与数据库之间的交互效率。
使用Druid可以避免每次访问数据库时都手动创建和关闭连接，从而节省资源、提高性能。
2、Druid的特点 （1）强大的连接池功能：
Druid支持多种数据库（如MySQL、Oracle、SQL Server等），并提供了丰富的连接池配置选项，如最大连接数、最小连接数、最大等待时间等。
（2）监控与统计：
Druid提供了详细的监控功能，可以实时查看连接池的状态，如活跃连接数、闲置连接数、连接创建次数等。
Druid还支持自定义SQL语句统计，帮助开发者了解数据库的运行状况。
（3）扩展与自定义：
Druid允许开发者自定义SQL语句、连接初始化语句、连接销毁语句等，以满足不同场景的需求。
Druid支持扩展插件，方便开发者根据实际需求进行定制。
（4）高性能：
Druid采用优化算法，有效降低连接池的延迟和卡顿，提高应用程序的响应速度。
3、Druid使用 通过简单的示例，介绍如何使用Druid实现数据连接池。
（1）添加依赖
在项目的pom.xml文件中添加Druid的依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.20&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; （2）配置连接池
在Java代码中创建一个DruidDataSource对象，并配置连接池的相关参数：
import com.alibaba.druid.pool.DruidDataSource; public class DruidExample { public static DruidDataSource getDruidDataSource(){ DruidDataSource dataSource = new …  ]]></content></entry><entry><title>Hibernate入门：轻松掌握Java持久化技术</title><url>/post/61/</url><categories><category>Java库</category></categories><tags><tag>Hibernate入门</tag></tags><content type="html"><![CDATA[  介绍Hibernate这个强大的Java持久化库，学会Hibernate的核心概念和技巧，快速入门并掌握基本使用方法和高级功能。
1、Hibernate是什么 Hibernate是一个开源的Java持久化框架，它对JDBC进行了封装，让开发者只需要使用简单的Java对象和配置文件，就可以轻松地实现数据持久化操作。
Hibernate不仅简化了数据库操作，还提供了许多高级功能，如关联映射、事务管理、缓存机制等。
2、Hibernate的核心概念 1.实体类（Entity）：实体类是映射到数据库表的Java类，它包含了与表结构相对应的属性和方法。
2.映射文件（Mapping）：映射文件是用来描述实体类与数据库表之间关系的XML文件，它定义了实体类属性与数据库字段之间的映射关系。
3.会话（Session）：会话是Hibernate的核心接口，它代表了与数据库的连接，并负责执行数据库操作。
4.查询（Query）：Hibernate提供了一种面向对象的查询语言（HQL），通过会话对象可以执行HQL查询，并将查询结果映射为Java对象。
3、Hibernate的基本操作 1.添加数据
要向数据库中添加数据，需要创建一个实体类，编写映射文件，通过会话执行插入操作。
（1）创建实体类User.java
public class User { private Integer id; private String name; private Integer age; // 省略 getter 和 setter 方法 } （2）编写映射文件User.hbm.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE hibernate-mapping PUBLIC &amp;#34;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;#34; &amp;#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&amp;#34;&amp;gt; &amp;lt;hibernate-mapping&amp;gt; &amp;lt;class name=&amp;#34;User&amp;#34; table=&amp;#34;users&amp;#34;&amp;gt; &amp;lt;id …  ]]></content></entry><entry><title>MyBatis入门：让 Java 数据库操作更简单</title><url>/post/60/</url><categories><category>Java库</category></categories><tags><tag>MyBatis入门</tag></tags><content type="html"><![CDATA[  MyBatis是一个优秀的 Java 库，用于简化数据库操作。
本文将介绍 MyBatis 的基本概念、特点和使用方法，并通过示例展示如何使用 MyBatis 完成常见的数据库操作。
1、MyBatis 简介 MyBatis 是一个半ORM（对象关系映射）框架，它允许开发者通过简单的 XML 或注解来配置 SQL 语句，并将 SQL 语句与 Java 对象的方法关联起来。
MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的工作。
MyBatis 可以使用简单的 XML 或注解来配置和原始映射，将接口和 Java 的 POJOs（Plain Old Java Objects，普通的 Java 对象）映射成数据库中的记录。
2、MyBatis 特点 1.简单易学：MyBatis 的学习曲线较低，只需掌握基本的 SQL 语句和 Java 编程知识，就可以轻松上手。
2.灵活性：MyBatis 允许开发者自定义 SQL 语句，满足各种复杂的业务需求。
3.高效性能：MyBatis 的执行效率较高，因为它避免了 JDBC 的繁琐操作，并且可以通过缓存机制提高查询效率。
4.支持多种数据库：MyBatis 支持包括 MySQL、Oracle、SQL Server 在内的多种数据库。
3、MyBatis 使用方法 1.添加依赖,在项目的 pom.xml 文件中添加 MyBatis 的依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;!-- MyBatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.10&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL 驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.19&amp;lt;/version&amp;gt; …  ]]></content></entry><entry><title>一篇文章带你入门Fastjson2：Java库的“闪电”解析</title><url>/post/59/</url><categories><category>Java库</category></categories><tags><tag>Fastjson2入门</tag></tags><content type="html"><![CDATA[  介绍一个Java编程中非常实用的库——Fastjson2。
Fastjson2是一个由我国阿里巴巴团队开发的高效JSON解析库，它能够让你在处理JSON数据时，体验到飞一般的感觉。
1、Fastjson2的背景 在互联网开发领域，JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。
由于其简洁易读的特点，JSON成为了网络数据传输的事实标准。
当时在Java中处理JSON数据并不总是那么容易。为此Fastjson应运而生，它旨在简化Java开发者处理JSON数据的复杂度，提高处理速度。
Fastjson2是Fastjson项目的重要升级，与Fastjson1相比，性能有非常大的提升。
性能远超过其他流行JSON库，包括jackson/gson/org.json，
性能数据: https://github.com/alibaba/fastjson2/wiki/fastjson_benchmark 2、Fastjson2的特点 速度快：Fastjson2的解析速度非常快，比其他库如Jackson和Gson要快得多。 易使用：Fastjson2的API简单易用，你几乎可以无脑使用它。 功能全：Fastjson2支持各种复杂类型的JSON处理，包括泛型、枚举等。 可扩展：Fastjson2允许你自定义序列化和反序列化规则。 支持JDK新特性 完善的JSONPath支持，支持SQL:2016的JSONPath语法 支持Android 8+，客户端和服务器一套API 支持JSON Schema 3、Fastjson2的使用 1.添加依赖,在你的项目中添加Fastjson2的依赖。如果你使用Maven，可以在pom.xml文件中添加以下代码：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.fastjson2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.44&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.JSON字符串转Java对象
public class Test1 { public static void main(String[] args) …  ]]></content></entry><entry><title>HikariCP：一款高效的Java数据库连接池</title><url>/post/58/</url><categories><category>Java库</category></categories><tags><tag>HikariCP</tag></tags><content type="html"><![CDATA[  介绍一款广泛应用于Java应用程序的数据库连接池库——HikariCP。
在Java应用程序中，数据库连接池是一个至关重要的组件，用于管理和复用数据库连接。
使用数据库连接池可以减少连接和断开连接的开销，提高应用程序的性能和可伸缩性。
在众多数据库连接池库中，HikariCP因其高效性能和易用性而备受推崇。
介绍HikariCP的特点、优势以及如何使用它来优化你的Java数据库应用程序。
一、HikariCP的特点 1.高效性能
HikariCP采用了一种独特的连接池设计，使得连接的获取和释放变得非常快速。
与其他数据库连接池相比，HikariCP在连接的创建和销毁方面减少了大量的CPU开销，提高了应用程序的响应速度。
2.可伸缩性
HikariCP支持可伸缩的连接池配置，允许根据应用程序的需求动态调整连接池的大小。
可以根据应用程序的负载情况，自动增加或减少连接的数量，提高应用程序的吞吐量和可伸缩性。
3.灵活的配置
HikariCP提供了丰富的配置选项，允许根据应用程序的需求进行自定义。
可以根据数据库的类型、连接的属性以及连接池的行为进行配置，以满足不同场景下的需求。
4.安全性
HikariCP支持数据源的安全配置，包括SSL/TLS加密、密码编码以及连接的安全认证等。
可以保护数据库连接的安全，防止数据泄露和恶意攻击。
二、HikariCP的优势： 1.高性能
HikariCP在连接池设计上采用了优化算法，减少了连接的创建和销毁的开销，提高了连接的利用率。
这使得HikariCP在性能方面具有明显优势，能够提供更快的响应速度和更高的吞吐量。
2.易用性
HikariCP提供了简洁的API和丰富的配置选项，使得使用起来非常方便。
可以通过简单的配置即可实现高效的数据库连接管理，无需深入了解底层的细节。
3.社区支持
HikariCP拥有一个活跃的社区，提供了大量的文档、示例和最佳实践。
可以随时获取帮助和支持，解决在使用过程中遇到的问题。
三、使用HikariCP的示例： 下面是一个简单的示例，展示了如何使用HikariCP来配置和管理数据库连接池：
1.添加依赖：需要在项目的pom.xml文件中添加HikariCP的依赖项。
&amp;lt;dependencies&amp;gt; &amp;lt;!-- HikariCP --&amp;gt; &amp;lt;dependency&amp;gt; …  ]]></content></entry><entry><title>Java开发者必备：一款神器Dozer，让你轻松实现对象属性映射！</title><url>/post/30/</url><categories><category>Java库</category></categories><tags><tag>Dozer</tag></tags><content type="html"><![CDATA[  介绍一款Java领域内广泛使用的数据映射库——Dozer。
通过本文你将了解到Dozer的基本概念、使用方法和应用场景，更有详细的示例代码助你快速上手！
1、Dozer简介 Dozer是一个用于Java对象的映射工具，它可以帮助我们轻松地将一个对象的属性映射到另一个对象的对应属性。
在Java开发过程中，我们经常需要处理对象之间的转换和映射，而手动编写这些转换逻辑既繁琐又容易出错。
Dozer为我们提供了一种自动化、高效的方式来解决这个问题。
2、Dozer的核心概念 1.映射器（Mapper）：Dozer通过映射器来实现对象之间的映射。我们可以自定义映射器，也可以使用Dozer提供的默认映射器。
2.类型映射（Type Mapping）：Dozer支持基本数据类型、包装类、自定义对象等多种类型的映射。
3.属性映射（Property Mapping）：Dozer可以根据对象属性的名称、getter方法或setter方法来自动匹配映射关系。
4.复杂映射（Complex Mapping）：Dozer还支持嵌套映射、集合映射等复杂场景。
3、Dozer的使用方法 1.添加依赖，需要在项目的pom.xml文件中添加Dozer的依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;!-- Dozer依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.sf.dozer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dozer&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.创建映射器
创建一个Java类，并继承Dozer的Mapper接口。然后重写接口中的映射方法，实现自定义的映射逻辑。
import org.dozer.Mapper; import org.dozer Mapping; @Mapper public class MyMapper { @Mapping(source = &amp;#34;name&amp;#34;, target = &amp;#34;name&amp;#34;) public MyObject map(MyObject source) { …  ]]></content></entry><entry><title>ASM：深入Java字节码的世界，小白也能轻松掌握</title><url>/post/29/</url><categories><category>Java库</category></categories><tags><tag>字节码</tag></tags><content type="html"><![CDATA[  你是否曾在Java开发中遇到需要对字节码进行操作的需求？
是否为了实现某个功能而不得不深入研究Java字节码的奥秘？
如果是的话，那么你可能会感兴趣我要介绍的Java库——ASM。
ASM是一个强大的Java字节码操作库，它可以帮助我们轻松地读取、修改和生成Java字节码。
无论你是小白还是有一定基础的开发者，ASM都能为你带来极大的便利。
一篇关于ASM的入门介绍，让你轻松掌握这个强大的Java库。
1、ASM简介 ASM是一个用Java编写的库，主要用于分析和操作Java字节码。
通过ASM我们可以读取Java字节码文件，了解其结构，修改字节码以满足我们的需求，甚至可以生成全新的字节码文件。
ASM提供了丰富的API，使我们能够以编程的方式操作字节码，极大地提高了我们的工作效率。
2、ASM的核心组件 ClassReader：用于读取Java字节码文件，并获取其对应的Class对象。 ClassWriter：用于生成Java字节码文件，我们可以通过ClassWriter将修改后的字节码写入到新的文件中。 MethodVisitor：用于访问Java方法，包括方法的参数、返回值、异常等信息。 FieldVisitor：用于访问Java字段，包括字段的类型、修饰符等信息。 AnnotationVisitor：用于访问Java注解。 ConstructorVisitor：用于访问Java构造器。 3、ASM的使用示例 我将通过一个简单的示例，展示如何使用ASM来读取和修改Java字节码。
1.我们需要添加ASM的依赖。如果你使用Maven，可以在pom.xml文件中添加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.ow2.asm&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;asm&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;9.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.创建一个简单的Java类，例如：
public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;#34;Hello, World!&amp;#34;); } } 3.编 …  ]]></content></entry><entry><title>一窥Dozer的Java库：让Java对象映射更轻松</title><url>/post/28/</url><categories><category>Java库</category></categories><tags><tag>Dozer</tag></tags><content type="html"><![CDATA[  尽管各种新兴技术层出不穷，Java仍然稳居开发语言的前沿。
然而Java的对象映射问题一直让许多新手程序员头疼。
我要介绍的是拯救诸位于此困扰的利器——Dozer。
1、Dozer是什么？ Dozer是一个强大、简单易用的Java Bean到Java Bean映射工具，它使用Java反射API进行动态映射。
不论是同名属性映射，深层对象映射，或者是复制不同类型的对象都处理得游刃有余。
2、Dozer的优势 1、在源目标与目标类名称和字段名称相同时，能自动将值从一方映射到另一方。
2、对于字段类型不同的映射，它也能妥善应对。
3、提供了丰富的API，还支持自定义转换器，让你的映射更加自如。
3、使用Dozer 保持简洁的原则，我们用一段代码示例来看看如何使用Dozer。
1、需要在工程中引入Dozer。
&lt;dependency&gt; &lt;groupId&gt;com.github.dozermapper&lt;/groupId&gt; &lt;artifactId&gt;dozer-core&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; 2、创建两个Java Bean对象，Person和Employee。
public class Person { private String name; private int age; //...getter和setter } public class Employee { private String name; private int age; //...getter和setter } 3、实操使用：实现Person对象到Employee对象的映射了。
// 创建DozerBeanMapper对象 Mapper mapper = DozerBeanMapperBuilder.buildDefault(); Person p = new Person(); p.setName(&#34;小白&#34;); p.setAge(25); Employee e = mapper.map(p, Employee.class); System.out.println(e.getName()); System.out.println(e.getAge()); //以上代码能够成功地输出“小白”和“25”，证明映射工作已经成功地完成了。 ▽ 通过Dozer我们能够更快、更轻松地完成Java对象的映射。
不论是编程新手，还是在Java道路上已经走过一段距离的朋友，都可以使用一下这个强大的工具更快、更轻松地完成编程任务，可少加班早点下班。
良好的工具能够提升编程效率，让你有更多时间去处理更重要的事情。
希望Dozer能够为你的Java之路提供便利，让你的编程任务都能够如你所愿，甚至超出你的预期，让你的人生与代码都无往不利！
开源地址： https://github.com/DozerMapper/dozer   ]]></content></entry><entry><title>Guava：一款强大的Java库，让你的开发更高效</title><url>/post/27/</url><categories><category>Java库</category></categories><tags><tag>Guava</tag></tags><content type="html"><![CDATA[  Guava是一款由Google开源的Java库，提供了丰富的工具类和扩展类，帮助我们解决日常开发中遇到的各种问题。
本文将详细介绍Guava库的特点、常用工具类及其使用方法，让小白读者轻松上手。
1、Guava简介 Guava是一款由Google开源的Java库，旨在为Java开发者提供一系列便捷的工具类和扩展类，以提高开发效率。
Guava包含了很多实用的工具类，如集合类（multisets、multimaps、tables等）、数式编程风格（通过supplier、function、predicate、optional等实现）、缓存（CacheLoader和CacheBuilder等）、支持原生的Java类型、事件总线以及并发库扩展等，可以帮助我们轻松应对日常开发中的各种挑战。
2、Guava的安装与使用 1.添加依赖 要使用Guava库，需要在项目中添加其依赖。如果你使用Maven进行项目管理，可以在pom.xml文件中添加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;31.0.1-jre&amp;lt;/version&amp;gt; &amp;lt;!-- 请根据实际版本进行替换 --&amp;gt; &amp;lt;/dependency&amp;gt; 如果你使用Gradle，可以在build.gradle文件中添加以下依赖：
dependencies { implementation &amp;#39;com.google.guava:guava:31.0.1-jre&amp;#39; // 请根据实际版本进行替换 } 2.使用Guava工具类 Guava提供了很多实用的工具类，下面将介绍几个常用的工具类及其使用方法。
(1).增强java集合功能
Guava库向我们提供了一些更加丰富的集合类，比如诸如ImmutableSet、ImmutableList、ImmutableSortedSet、ImmutableMap以及更为泛化和强大的Multiset（可以存储相同元素的集合）、BiMap（可以将两个键映射到一个值）、Table（可以将一个键映射到另一个键的值）等。
(2).字符串处理
Guava库提供 …  ]]></content></entry><entry><title>spring事件</title><url>/post/79/</url><categories><category>Java</category></categories><tags/><content type="html"><![CDATA[  1、Spring简单事件使用步骤: 1、自定义事件 并继承 ApplicationEvent
2、定义事件的监听器类
3、发布事件
2、代码示例: Demo实体 package com.hh; @Data public class Demo { private String demoMsg; } 事件类 package com.hh; import org.springframework.context.ApplicationEvent; public class DemoEvent extends ApplicationEvent { private Demo demo; public Demo getDemo() { return demo; } public DemoEvent(Object source, Demo demo) { super(source); this.demo=demo; } } 监听器类 package com.hh; import org.springframework.context.event.EventListener; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Component; @Component public class DemoListener { @EventListener @Async public void sendMsg(DemoEvent demoEvent){ Demo demo = demoEvent.getDemo(); System.out.println(&#34;DemoListener接受到了EventPublisher发布的消息: &#34;+demo.getDemoMsg()); } } 发布类 package com.hh; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationEvent; import org.springframework.stereotype.Component; @Component public class EventPublisher&lt;T extends ApplicationEvent&gt; { @Autowired private ApplicationContext applicationContext; public void eventPublish(T event){ System.out.println(&#34;发布event事件: &#34;+event); applicationContext.publishEvent(event); } } 测试 package com.hh; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class DemoTest { @Autowired EventPublisher&lt;DemoEvent&gt; eventPublisher; @Test public void eventTest(){ Demo demo=new Demo(); demo.setDemoMsg(&#34;event测试事件!!&#34;); DemoEvent demoEvent = new DemoEvent(this,demo); eventPublisher.eventPublish(demoEvent); } }   ]]></content></entry><entry><title>创建非root用户</title><url>/post/80/</url><categories><category>Java</category></categories><tags/><content type="html"> 示例：创建一个名为elk的用户，该用户属于elk用户组，密码为111111
1、创建用户组elk
groupadd elk 2、创建用户elk并设置密码
useradd elk -g elk -p 111111 3、参数解释:
-g elk 设置其用户组为 elk -p 111111 设置其密码6个1 4、更改权限
# 更改 /opt 文件夹及内部文件的所属用户及组为 elk:elk chown -R elk:elk /opt 5、切换到非root用户elk
su elk</content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 编程之路 一枚不起眼有着梦想爱读书的程序猿，记录自己的编程小技巧分享。
编程之路，探索智慧的无尽旅程。
在这条路上，小猿编程秘籍解锁创新，磨砺思维，不断超越。
编程，开启你的未来可能。
其他渠道： Github 掘金 知乎 CSDN 公众号：小猿编程秘籍</content></entry><entry><title>计算机网络：面试真题实战</title><url>/post/25/</url><categories><category>计算机网络</category></categories><tags><tag>面试真题实战</tag></tags><content type="html"> 1、面试真题问答 以下问题都是基于之前写的计算机网络系文章做出简单问答
问1：TCP/IP协议群做了哪些事情？
1、报文拆分 2、增加协议头 3、数据传输 4、路由和寻址 5、数据重组 问2：TCP协议为什么是3次握手4次挥手？
3次握手 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 4次分手 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 问3：IPv4和Ipv6的区别？
地址不同：Ipv4 32位；Ipv6 128位 （地址空间、数目不同）。 地址分配不同：IPv4资源是稀缺的，分配需要竞争；IPv6可以给每个人分配很多地址。 寻址方式不同：IPv4通过子网掩码计算网络地址；IPv6有固定的计算方式划分网络。 地址解析策略不同：IPv4需要ARP；IPv6通过无状态的邻居发现。 DNS不同：IPv4是A记录；IPv6是AAAA记录。 问4：TCP和UDP的区别？
传输：TCP面向流；UDP面向报文 连接：TCP有会话；UDP无会话 头部开销：TCP开销大；UDP开销小 可靠性：TCP保证数据可靠到达；UDP不保证数据可靠到达 场景：TCP适合保证数据完整到达场景，如：文件传输；UDP适合随时发送数据，不要求数据完整到达场景，如：广播通信 问5：TCP如何确保数据顺序？ 为什么需要保证：TCP拆分封包的时候是顺序拆分的，但是包会无序的到达目的地。 方法1：利用(SEQ, ACK)编号确定封包的唯一性 方法2：利用滑动窗口存放没有排好序的封包，直到窗口中完全有序才发送ACK。如果有包丢失，就会一直不发ACK。 如果窗口大小是4，发送ABCD，如果只有BD到目的地，那么滑动窗口中是_B_D。
问6：如果网络延迟是30ms，那么Ping一个网站需要多少ms? 如果请求一个HTTPS协议的网站，TTFB至少ms? 问7：LRU是什么？ 缓存置换：缓存满了后，每次创建新的缓存条目，就会删除旧的缓存条目。 问8：什么是https中间人攻击? 问9：NIO有什么优势？
Reactive模型+非阻塞(减少线程切换） 内核级别拷贝内存到JVM（减少系统调用） …</content></entry><entry><title>计算机网络：同源策略</title><url>/post/24/</url><categories><category>计算机网络</category></categories><tags><tag>同源策略</tag></tags><content type="html"><![CDATA[  1、介绍 同源策略：禁止一个源(origin)的脚本和文档和另一个源的脚本和文档交互。 什么是同源：两个URL的协议(protocol)、端口(port)和域名(domain)都相同，这就是同源。 同源策略的目的：防止恶意的网站窃取用户的cookie，或者其他敏感信息。 同源策略的实现：浏览器会在同源的情况下，允许脚本和文档进行交互。 同源策略的限制：不能读取对方的cookie、localStorage、sessionStorage、indexedDB、webSocket、EventSource、XMLHttpRequest、location、history 等等。 2、问题回答 问1：如果两个源产生过多交互会有什么影响？ 影响很大的就是恶意的网站窃取用户的cookie，或者其他敏感信息。这样数据就不安全了，所以同源策略是非常重要的。
问2：应不应该允许网站提交cookie到不同源的服务器？ 这个是不允许的，但是你自己配置了跨域是可以的。
问3：为什么不禁用不同源的js？ 因为有些js是第三方提供的，我们引用cdn的js，引用组件。
问4：应不应该允许不同源的js修改dom？ 这个是允许的，比如百度统计，百度地图等，如果不允许不同源的js修改dom，那么就无法统计用户的地理位置，无法使用百度地图等功能。
问5：应不应该允许不同源的js获取远程图片内容？ 这个是不允许的，如果能远程执行代码，那么就有可能获取到敏感信息和人家私密数据，这个肯定不行的。
问6：应不应该允许网站提交数据到不同源的服务器？ 这个是不允许的，如果能提交数据，那么就会被别人收集你的数据，然后提交到自己的服务器上，这等于抢劫，不劳而获，这个也肯定不行的。
3、跨域请求技术 Jsonp技术
Jsonp的原理：就是利用script标签的src属性没有跨域限制来实现的。
Jsonp的优缺点：
缺点：只能get请求 优点：浏览器的兼容性好 Jsonp的实现及应用：
模拟服务端： server.js ，启动方式: node server.js （需要安装node.js）
//模拟服务端 let http = require(&amp;#34;http&amp;#34;) let url = require(&amp;#34;url&amp;#34;) //模拟数据 let data; http.createServer((req, res) …  ]]></content></entry><entry><title>计算机网络：加密和解密</title><url>/post/23/</url><categories><category>计算机网络</category></categories><tags><tag>加密和解密</tag></tags><content type="html"> 1、加密 概念：将明文信息变成不可读的密文内容，只有拥有解密方法的对象才能够将密文还原成加密前的内容。 举例子： 说明：例子中&amp;quot;每隔3个取1个字符解读&amp;quot;相当于秘钥。将加密后的密文通过秘钥还原为明文，这就是解密 2、加密解密算法 对称加密：加密/解密用一个秘钥，且加密方和解密方都知道秘钥，如DES,3DES等。 非对称加密：加密用一个秘钥，解密用另一个秘钥且加密方一般有2个秘钥，解密方有一个解密秘钥。非对称加密安全性高，但速度慢，如RSA算法。 摘要算法：摘要算法是一种特殊的加密算法，它接收任意长度的数据，并输出固定长度的消息摘要作为结果。就是将原文和摘要同时传输给接收方。 摘要算法3特点：公开、一致、难碰撞 场景举例 在现在互联网时代，各种数据都是非常重要的，数据的保护不言而喻。
那涉及到数据加密和解密的场景在生活中处处都有，比如：
密码保存 数据传输 互联网信任体系 A和B私下签协议
数字签名过程： 验证签名过程： 权威机构证书
A和B都去第三方机构注册账号，然后上传自己的公钥给第三方机构。 第三方机构可以给A和B办法一个证书，证书里含有他们的公钥。 信任链条
情况1：B机器上有预装证书，B和A签约的时候，就会用这个预装的根证书验证A证书的签名，要使用权威机构的公钥（而公钥在证书里）。 情况2：B机器上没有预装证书，而是预装了给权威机构颁发证书的机构的证书。 信任体系里面存在的漏洞
B安装盗版操作系统，系统中含有恶意机构的CA 黑客发的邮件，点击后安装CA</content></entry><entry><title>计算机网络：Linux网络指令</title><url>/post/22/</url><categories><category>计算机网络</category><category>Linux</category></categories><tags><tag>Linux网络指令</tag></tags><content type="html"> 1、ssh/scp ssh
概念：Secure Shell（安全外壳），安全外壳是一种网络安全技术，它为网络服务提供安全的远程登录和传输，它是一种加密的传输协议。 ssh加密通信原理： 客户端向服务器发送加密的登录请求，服务器验证用户的身份，并向客户端发送公钥。 客户端使用公钥加密登录信息，并发送给服务器。 服务器使用自己的私钥解密登录信息，并与用户的信息进行比较。 若信息匹配，则建立加密通道，并开始传输数据。 若信息不匹配，则拒绝登录。 查看命令使用手册： ssh --help man ssh 命令：ssh [选项] [user@]hostname [command] 常用的选项： -p：指定远程主机的端口号，默认是22。 -l：指定登录用户名，如果不指定，使用本地登录用户名。 -C：压缩传输数据。 -i: 指定私钥文件。 -4：使用IPv4地址进行通信。 -6: 使用IPv6地址进行通信。 scp
概念：Secure Copy（安全复制），安全复制是一种在网络上进行文件传输的安全方式。 查看命令使用手册： scp --help man scp 命令：scp [选项] [user@]hostname:file1 [user@]hostname:file2 常用的选项： -P：指定远程主机的端口号，默认是22。 -r：递归复制整个目录。 -C: 压缩传输数据。 -p：保留远程文件的修改时间、访问时间和权限。 -i：指定私钥文件。 -4：使用IPv4地址进行通信。 -6：使用IPv6地址进行通信。 三种传输方式： 本地文件到远程文件：scp file1 user@hostname:file2 远程文件到本地文件：scp user@hostname:file1 file2 源和目标都为远程文件：scp user@hostname:file1 user@hostname:file2 2、ifconfig/netstat ifconfig
概念：网络接口配置工具，用于配置和显示网络接口的各种参数。 查看命令使用手册： ifconfig --help man ifconfig 命令：ifconfig [网络接口] [选项] 常用的网络接口： up：启动网络接口 down：停止网络接口 inet [IP地址]：设置网络接口的IP地址 netmask [子网掩码]：设置网络接口的 …</content></entry><entry><title>计算机网络：HTTP协议入门</title><url>/post/21/</url><categories><category>计算机网络</category></categories><tags><tag>HTTP协议</tag></tags><content type="html"> 1、起源 1990年伯纳斯.李，发明了万维网(WWW)，写了第一个Web Server HTTP协议：浏览器和Web Server之间通信的协议 2、定义 HTTP协议(Hyper Text Transfer Protocol): 应用层协议 目标: 是处理客户端和服务端之间的通信 3、请求/响应 请求
一次请求，分成头(Header)和体(Body)。 下面是一个请求头+消息体的 响应
一次返回，也同样分(Header)和体(Body)。 下面是一个返回头+消息体 4、请求头/响应头 HTTP协议通过请求头和返回头控制协议工作。无论是请求头还是返回头都是Key/Value的形式。 常见头部 Content-Length：发送/接收Body内容的字节数。 User-Agent：这个字段可以帮助统计客户端用了什么浏览器、操作系统等 Content-Type：请求的时候，告知服务端数据的媒体类（MediaType/MIME Type)。返回的时候告知客户端，数据的媒体类型。 Origin：描述请求来源地址 Accept：是HTTP协议协商能力的体现，用于建议服务端返回何种媒体类型(MIME Type) Referer：告诉服务端打开当前页面的上一张页面的URL，非浏览器环境有时候不发送Referer（或者虚拟Referer,通常是爬虫)，常用于用户行为分析 Connection：决定HTTP连接（不是TCP连接）是否在当前事务完成后关闭。（Http1.0 默认是 close ，Http1.1 后默认是 keep-alive） 5、HTTP的方法和状态码 方法 GET：从服务器获取资源 POST：在服务器创建资源(幂等性) PUT：在服务器修改资源 DELETE：在服务器删除资源 OPTION ：跨域部分讲解 TRACE ：用于显示调试信息 多数网站不支持 CONNECT： 代理部分讲解 PATCH ：对资源进行部分更新(极少用) 状态码 1xx：提供信息 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务端错误 注： 常用状态码速查表 6、HTTP缓存 HTTP缓存最重要的配置项为Cache-Control HTTP 返回头。 不仅浏览器可以缓存，浏览器和服务器之间的HTTP代理服务器也可以缓存。 7、代理服务器 概念：代理服务器接收一个请求，然后把请求转发 …</content></entry><entry><title>计算机网络：Socket编程-NIO进行优化</title><url>/post/20/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写了计算机网络：Socket编程-多线程优化和请求响应对象封装，
有留心的伙伴就会发现，我先是简单写了一个HTTP服务，然后对这个HTTP服务进行面向对象封装，接着又在封装的基础上进行多线程的优化和请求响应对象的封装，这样一步一步的由简入深。
这篇也是继续深入优化，之前的代码都是使用ServerSocket这个类，从代码中可以看出，它是每个请求都需要单独的线程进行处理，ServerSocket是基于阻塞I/O模型。那有没有非阻塞模式类？
有的，Java NIO库中提供了ServerSocketChannel这个类，它是通过Selector来管理多个通道的，一个线程可以处理多个请求。
1、NIO 过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将Socket注册到Selector中，也将内容信息存入Buffer中，放入Channel中）-&gt; 7（工作线程通过响应式获取Channel里的信息）-&gt; 8（工作线程先读取Channel信息，处理完请求后将相关信息写入Buffer，通过Channel再传递给内核）-&gt; 9（内核监听到Socket文件写入信息然后再返回给请求方）
代码实现 package com.hh.http; import java.io.*; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Iterator; import java.util.Set; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * NIO进步优化 * * @author hang.yuan 2022/3/8 19:50 */ public class HttpServer4 { ServerSocketChannel ssc; public void listen(int port) throws IOException { ssc = ServerSocketChannel.open(); ssc.bind(new InetSocketAddress(port)); // Reactive / Reactor ssc.configureBlocking(false); Selector selector = Selector.open(); ssc.register(selector,ssc.validOps(),null); ByteBuffer buffer = ByteBuffer.allocate(1024*16); for(;;){ int numOfKeys = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()){ SelectionKey key = it.next(); if (key.isAcceptable()){ SocketChannel channel = ssc.accept(); if (channel == null){ continue; } // Kernel --&gt; mmap(buffer) --&gt; Channel --&gt; User(buffer) channel.configureBlocking(false); channel.register(selector,SelectionKey.OP_READ); }else { SocketChannel channel = (SocketChannel)key.channel(); //_ _ _ _ _ _ _ // P(position) // L buffer.clear(); channel.read(buffer); String request = new String(buffer.array()); //Logic ... buffer.clear(); buffer.put(&#34;HTTP/1.1 200 ok\n\nHello NIO!\n&#34;.getBytes()); // H T T P / 1 ... ! _ _ // P(L) // P L buffer.flip();//就是把指针反过来 channel.write(buffer); channel.close(); } } } } public static void main(String[] args) throws IOException { HttpServer4 server = new HttpServer4(); server.listen(8000); } } 自己也可以学着前几篇用ServerSocket写的HttpServer类优化步骤，依葫芦画瓢一样对ServerSocketChannel写的HttpServer类进一步优化，
  ]]></content></entry><entry><title>计算机网络：Socket编程-多线程优化和请求响应对象封装</title><url>/post/19/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写了计算机网络：Socket编程-面向对象封装，然后以下基于之前的代码进一步进行多线程优化和请求响应对象封装。
1、多线程优化 对之前面向对象封装的代码，添加多线程优化，代码实现：
package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * 加入多线程优化 * * @author hang.yuan 2022/3/8 18:50 */ public class HttpServer3 { ServerSocket serverSocket; Function&lt;String,String&gt; handler; ExecutorService executorService; public HttpServer3(Function&lt;String, String&gt; handler) { this.handler = handler; this.executorService = Executors.newFixedThreadPool(10); } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } void accept() throws IOException { // Blocking ... Socket socket = serverSocket.accept(); // 多线程工作 executorService.execute(()-&gt;{ try{ this.handler(socket); }catch (IOException e){ e.printStackTrace(); } }); } public void handler(Socket socket)throws IOException { try{ // Thread --&gt; Sleep --&gt; Other Threads System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String response = this.handler.apply(request); bufferedWriter.write(response); bufferedWriter.flush(); socket.close(); }catch (IOException e){ e.printStackTrace(); } } public static void main(String[] args) throws IOException { HttpServer3 server = new HttpServer3(req -&gt; { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } return &#34;HTTP/1.1 201 ok\n\nGood!\n&#34;; }); server.listen(8000); } } 2、Request和Response对象封装 代码进行多线程优化后，进一步对请求（Request）和响应（Response）对象的封装
HttpServer对象 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.Map; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * Request/Response 进步抽象 * * @author hang.yuan 2022/3/8 18:50 */ public class HttpServer31 { ServerSocket serverSocket; IHandlerInterface handler; ExecutorService executorService; public HttpServer31(IHandlerInterface handler) { this.handler = handler; this.executorService = Executors.newFixedThreadPool(5); } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } void accept() throws IOException { // Blocking ... Socket socket = serverSocket.accept(); executorService.execute(()-&gt;{ try{ this.handler(socket); }catch (IOException e){ e.printStackTrace(); } }); } public void handler(Socket socket)throws IOException { Request request = new Request(socket); Response response = new Response(socket); this.handler.handler(request,response); } public static void main(String[] args) throws IOException { HttpServer31 server = new HttpServer31((req,resp)-&gt;{ System.out.println(req.getHeaders()); resp.send(&#34;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Hello Word&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;&#34;); }); server.listen(8000); } } 逻辑处理接口 package com.hh.http; import java.io.IOException; /** * 接口 * * @author hang.yuan 2022/3/8 20:07 */ @FunctionalInterface public interface IHandlerInterface { void handler(Request request, Response response) throws IOException; } Request对象 package com.hh.http; import org.apache.commons.httpclient.Header; import org.apache.commons.httpclient.HttpParser; import java.io.*; import java.net.Socket; import java.util.HashMap; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 请求 * * @author hang.yuan 2022/3/8 19:21 */ public class Request { static Pattern methodRegex = Pattern.compile(&#34;(GET|POST|PUT|DELETE|OPTIONS|TRACE|HEAD)&#34;); private final String body; private final String method; private final Map&lt;String, String&gt; headers; public Request(Socket socket) throws IOException { InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String methodLine = HttpParser.readLine(inputStream, &#34;UTF-8&#34;); Matcher matcher = methodRegex.matcher(methodLine); matcher.find(); String method = matcher.group(); Header[] headers = HttpParser.parseHeaders(inputStream, &#34;UTF-8&#34;); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for (Header header : headers) { map.put(header.getName(),header.getValue()); } BufferedReader bufferedReader1 = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder sb = new StringBuilder(); char[] buffer = new char[1024]; while (inputStream.available()&gt;0){ bufferedReader1.read(buffer); sb.append(buffer); } this.body= sb.toString(); this.method=method; this.headers=map; } public String getBody() { return body; } public String getMethod() { return method; } public Map&lt;String, String&gt; getHeaders() { return headers; } } Response对象 package com.hh.http; import java.io.BufferedWriter; import java.io.IOException; import java.io.OutputStreamWriter; import java.net.Socket; import java.util.HashMap; import java.util.Map; /** * 响应 * * @author hang.yuan 2022/3/8 19:22 */ public class Response { Socket socket; private int status = 200; static Map&lt;Integer,String&gt; codeMap; public Response(Socket socket) { this.socket=socket; if (codeMap == null){ codeMap= new HashMap&lt;&gt;(); codeMap.put(200,&#34;OK&#34;); } } public void send(String msg) throws IOException { String resp = &#34;HTTP/1.1 &#34;+this.status+&#34; &#34;+ this.codeMap.get(this.status)+&#34;\n&#34;; resp += &#34;\n&#34;; resp += msg; this.sendRaw(resp); } public void sendRaw(String msg) throws IOException { BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(msg); bufferedWriter.flush(); socket.close(); } }   ]]></content></entry><entry><title>计算机网络：Socket编程-面向对象封装</title><url>/post/18/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写的 计算机网络：Socket编程-实现HTTP服务 来进行面向对象封装
1、代码实现 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.util.function.Function; /** * 面向对象封装 * * @author hang.yuan 2022/3/8 18:30 */ public class HttpServer2 { ServerSocket serverSocket; Function&lt;String,String&gt; handler; public HttpServer2(Function&lt;String, String&gt; handler) { this.handler = handler; } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } public void accept() { try{ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = serverSocket.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String response = this.handler.apply(request); bufferedWriter.write(response); bufferedWriter.flush(); socket.close(); }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) throws IOException { HttpServer2 server = new HttpServer2( req -&gt; { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } return &#34;HTTP/1.1 201 ok\n\nGood!\n&#34;; }); server.listen(8000); } } 2、测试 测性能工具 ab 开始测试 结果 使用更大的并发测试，发现Pending Queue被占满，直接拒绝请求了   ]]></content></entry><entry><title>计算机网络：Socket编程-实现HTTP服务</title><url>/post/17/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  1、目标 不用框架利用Socket编程实现一个HTTP服务框架 2、线程模型 图示： 1、操作系统接受到外部请求时，会把请求放到Pending Queue里面，慢慢积累，如果 Pending Queue被占满时，这里会发生拒绝请求；
2、某一时刻某个线程会触发Accept的系统调用，Accept的系统调用会从Pending Queue拿出一个请求，然后在内核空间形成一个Socket文件，Socket文件会形成资源的一个句柄对应这个文件，派发线程一直循环，不断的Accept将每个文件形成FD（Socket，用来操作文件资源的）；
3、将FD派发给工作线程，工作线程读取Socket中的内容，进行处理后，再给用户返回信息，返回时工作线程直接在Socket写入信息，不需要原路返回了；
4、内核监听到Socket的写入信息，然后再把信息返回给请求方。
过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将获取到的Socket派发到工作线程）-&gt; 7（工作线程先读取4中文件内容，处理完请求后将相关信息直接写入到4中文件中，）-&gt; 8（内核监听到Socket文件写入信息然后再返回给请求方）
3、代码实现（简单实现） HttpServer代码 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 简单版 * * @author hang.yuan 2022/3/8 17:58 */ public class HttpServer { public static void main(String[] args) throws IOException { ServerSocket socketServer = new ServerSocket(8000); //main Thread while (true){ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = socketServer.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(&#34;HTTP/1.1 200 ok\n\nhello word!\n&#34;); bufferedWriter.flush(); socket.close(); } } } 测试： 结果：
  ]]></content></entry><entry><title>计算机网络：常用HTTP状态码速查表</title><url>/post/9/</url><categories><category>计算机网络</category></categories><tags><tag>状态码</tag></tags><content type="html"> Code Reason-Phrase 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 307 Temporary Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 426 Upgrade Required 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported Informational 1xx 1xx(Informational) 状态码类别表示在完成所请求的动作并发送最终响应之前的通信连接状态或请求进度的临时响应。
1xx 响应由状态行之后的第一个空行（空行表示header 部分的结尾）终止。 由于HTTP/1.0 没有定义任何1xx状态码，因此服务器不得向HTTP/1.0客户端发送1xx响应。
即使客户端没有预期到，客户 …</content></entry><entry><title>计算机网络：TCP、UDP、IP抓包工具-wireshark</title><url>/post/16/</url><categories><category>计算机网络</category></categories><tags><tag>wireshark</tag></tags><content type="html"> 1、什么是Wireshark？ 是世界上应用最广泛的网络协议分析器。 在微观层面上看到整个网络正在发生的事情。 使用WinPCAP作为接口，直接与网卡进行数据报文交换。 2、wireshark抓包原理 单机：直接抓取本机网卡的网络流量。 交换机：通过端口镜像、ARP欺骗等方式获取网络流量。 端口镜像：利用交换机的接口，将网络流量转发到指定电脑的网卡上。 ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取网络流量。 3、功能集 深入检查数百个协议，并不断添加更多协议 实时捕获和离线分析 支持Windows、Linux、macOS、Solaris、FreeBSD、NetBSD和许多其他平台 提供GUI浏览，也可以通过TTY VoIP支持 Gzip支持 IpSec支持 &amp;hellip;&amp;hellip; 4、抓包界面 如上图： 菜单栏 工具栏 过滤栏 数据列表区：不同的协议使用了不同的颜色区分。 数据详细区 数据字节区 数据统计区 下载 软件下载： https://www.wireshark.org/download.html 中文文档： wireshark-中文手册.pdf 提取码: 6or7</content></entry><entry><title>计算机网络：UDP协议</title><url>/post/15/</url><categories><category>计算机网络</category></categories><tags><tag>UDP</tag></tags><content type="html"> 背景和介绍 背景 1980年由科学家David P. Reed提出 协议简单，搭建在IP协议之上 尽可能的减少通信机制，速度非常快 该协议的RFC只有两页 介绍 全称: User Datagram Protocol，用户数据报协议 定义：在传输层提供直接发送报文(Datagram)的能力。Datagram是数据传输的最小单位。 目标：发送报文，无法拆分数据 思考：为什么不直接调用IP协议？ IP协议只能把数据从一个网络接口发送到另一个网络接口，无法寻址到应用 封包格式 设计目标：允许用户直接发送报文的情况下最大限度的简化应用的设计
报文格式： Source Port：源端口号 Destination Port：目标端口号。 Length：消息体长度 Checksum：检查封包是否出错 Data octets：一个字节一个字节的数据。Octet是8位。 与TCP的区别 UDP TCP 本质 提供报文交换，简化协议 提供可靠的网络传输 可靠性 不可靠 可靠 顺序 无序 有序 负载 负载小 负载大 广播场景 合适 不合适，代价大 场景分析 聊天室是否适合UDP？ 不合适，聊天室并发高但流量不大，依赖可靠性
HTTP协议适不适合UDP？ 合适，HTTP3.0就是建立在UDP上的</content></entry><entry><title>计算机网络：IPv6协议</title><url>/post/14/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 背景 IPv4只能支持43亿设备，不够用。
工作原理 IPv6和IPv4两者工作原理相似，为切片、增加封包头、路由(寻址)几个阶段。 与IPv4的主要区别 地址
地址数量：IPv4有4个8位，共16位，IPv6有8个16位，共128位 分割符号： IPv4的地址用 . 分割，如 103.28.7.35 。每一个是8位，用0-255的数字表示。 IPv6的地址用 : 分割，如 0123:4567:89ab:cdef:0123:4567:89ab:cdef 。每个是一个16位的16进制数字，就是4个符。 IPv6地址： 寻址
全局单播
站点前缀（Site Prefix)：48bit，一般是由ISP（Internet Service Providor，运营商）或者RIR(Regional Internet Registry， 地区性互联网注册机构)。RIR将IP地址分配给运营商。 子网号（Subnet ID)：16bit，用于站点内部区分子网。 接口号（Interface ID)：64bit，用于站点内部区分设备。 本地单播
给定地址，本地网定位设备 ⚠️ 注意：Link-local必须以fe80开头 分组多播
需要以8个1，也就是 ff00 开头，后面跟上一个分组的编号。 所在的网络中已经定义了该分组编号，而且有设备可以识别这个编号。 拥有分组下设备的完整清单，并把数据发送给对应的设备们。 IPv4也支持分组多播，但需要网络配置整体配合。 新设备接入 新设备接入IPv6后，会使用IPv6的邻居发现协议(Neighbour Discover Protocol)为自己申请一个IP地址。当新设备需要发送信息到目的地时，还可以通过ND协议广播查询目标设备。然后如果需要路由，还可以通过ND查找路由器。 传统：ARP协议（Address Resolution Protocol，地址解析协议）。每个节点存储许多额外信息。
IPv6: 更加无状态化，减少数据冗余带来的风险和负担
优势 解决了IP地址耗尽的问题 解决了网络区域、站点划分的问题。 协议层支持多播。 Ipv6可以有专门的地址用作多播。 支持邻居发现协议，自动分配地址，做到了无状态接入设备。</content></entry><entry><title>计算机网络：IP协议</title><url>/post/13/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 概念 IP协议(Internet Protocol)：网络层协议。 IP协议可能遇到的问题： 封包损坏 丢包 重发 乱序 网络层需要解决的3个问题： 延迟 吞吐量 丢包率 IP协议目前主要有两种架构，IPv4和IPv6，IPv4是目前应用最广泛的互联网协议。 IP协议的工作原理 分片
把数据切分成片 适配底层传输网络 增加协议头 Type Of Service：服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。 IHL（Internet Header Length)：IP协议头的大小。 Total Length：报文(封包datagram)的长度 Identification：报文的ID，发送方分配，代表顺序 Fragment offset：描述是否要分包（拆分），和如何拆分。 Time To Live：封包存活的时间。 Protocol：描述上层的协议，比如TCP=6,UDP=17 Options：可选项 Checksum：检验封包的正确性 延迟、吞吐量、丢包率 寻址
寻址：给一个地址，然后找到这个东西 IPv4地址(32位)：逐级寻址 步骤： 路由
若寻找的IP地址不在局域网中，需要路由找到去往对应网络的路径。 IP地址和子网掩码位与的过程是由路由算法实现的。</content></entry><entry><title>计算机网络：TCP协议</title><url>/post/12/</url><categories><category>计算机网络</category></categories><tags><tag>TCP</tag></tags><content type="html"> 概述 TCP全名是(Transport Control Protocol)，是一个可以提供可靠的、支持全双工、连接导向的协议，因此在客户端和服务端之间传输数据的时候，是必须先建立一个连接的。 TCP的特点 连接 是虚拟、抽象的概念 能让两个通信的程序间确保彼此都在线 加快响应请求速度 连接也被称为会话(Session） 使通信更稳定、安全 消耗更多资源 全双工 单工：任何时刻数据只能单向发送 半双工：允许数据在两个方向上传输，在某一时刻，只允许数据在一个方向上传输 全双工：任何时刻都能双向发送数据 可靠的
可靠性指数据保证无损传输 使无序的数据恢复原有顺序 多播时每个接收方都获得无损副本 TCP协议的工作过程 建立连接的过程（三次握手） 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 断开连接的过程（四次挥手） 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 传输数据 报文拆分
应用层数据很大时无法一次性传输完 拆分后可实现并行传输 顺序保证
思考：如果TCP段特别多的时候，该如何进行排序？时间窗口 TCP序号：发送序号(Seq)、接收序号(Ack) 一个端的发送序号是另一个端的接受序号 TCP头部结构 结构图： 源端口：描述发送方机器上的应用
目标端口：描述接收方服务器上的应用
发送序号(Seq)/接收序号(Ack)
标志位
NS、CWR、ECE：TCP扩展协议 ECN：显示拥塞控制协议，有助于帮助解决延迟和丢包问题， URG：紧急标志位SYN（Synchronize Sequence Numbers)：同步序号，也就是在建立连接。 FIN： 终止连接 ACK（Achnowledgment)：响应。 PSH（push）：传送数据 RST（Reset Connection)： 重置连接 TCP协议周边配置 纠错能力：保证数据可靠性； TCP拥有一个16bit的Checksum字段 Checksum是一个函数，把原文映射到一个不可逆的16bit的编码中这样就可以知道原文传输过程中有没有发生变化 流控能力：协同两边速率，保证可靠性； 主要目标：让发送方和接收方协商一个合理的收发速率，让两边都可以稳定的工作。 利用滑动窗口 拥塞控制能力：确定网络的拥堵情况决定传输速度。</content></entry><entry><title>SSH还能内网穿透，实在是没想到</title><url>/post/7/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag><tag>内网穿透</tag></tags><content type="html"> 1、准备 两台机器(一台有公网IP A，一台是没有公网IP B)
2、操作 (1) A机器运行sshd ，将GatewayPorts设置为yes，并重启sshd
(2) B机器执行如下命令：
ssh -NR 9999:192.168.56.2:22 A机器的用户@A机器的Ip 参数解释： -N ：不执行任何命令 -R ： 将端口绑定到远程服务器,反向代理 9999 ：自己设定的在远程服务器的监听端口 192.168.56.2:22 ： 本地的服务ip和监听端口 A机器的用户@A机器的Ip ：远程服务器的用户和IP 3、测试 (1) 在A机器上执行netstat -lntp 可以看到9999端口被监听
(2) 测试A机器上使用隧道连接B机器
ssh -p 9999 B机器的用户@192.168.56.2 注：只是自己测试玩一玩的，不要抱很大希望能生产使用</content></entry><entry><title>计算机网络：互联网协议群</title><url>/post/11/</url><categories><category>计算机网络</category></categories><tags><tag>TCP/IP协议</tag></tags><content type="html"> 概述 OSI无实际可行方案 有人就提出了TCP协议 TCP/IP协议群解决的5个问题 报文拆分
数据量大，网络底层设备不支持 复用路径 增加协议头
数据分块后在接收端需要重组，所以需要使用头部来添加一些描述字段 数据在相邻设备间数据传递 路由和寻址
路由算法：通过算法寻找下一个要到达的节点 数组重组 TCP/IP协议群的5层模型 5层模型图： 5层模型与OSI7层模型区别 删除了会话层，会话是虚拟概念，不是必须的 删除了表示层，数据压缩、数据格式转换不是应用必须的 TCP/IP协议群可选性 传输层：TCP协议、UDP协议、TLS/SSL、SCTP等 网络层：IP协议(ipv4和ipv6)、ICMP协议、IPSec协议</content></entry><entry><title>计算机网络：OSI七层模型</title><url>/post/10/</url><categories><category>计算机网络</category></categories><tags><tag>7层模型</tag></tags><content type="html"> 1、OSI模型是什么？ OSI模型指的是Open System Interconnection Reference Model，即开放式系统互联模型。它是世界上第一个试图在世界范围内规范网络标准的框架。
2、7层模型详解 OSI模型图示： 应用层
应用层位于OSI模型最上方 只关心业务逻辑，不关心数据传输 例如：张三给小花微信发送消息 表现层
负责协商用于传输的数据格式，并转换数据格式 会话层
负责管理两个连网实体间的连接 功能及特点：建立连接，维持通信，释放连接 传输层
负责将数据从一个实体（服务器或者应用）传输到另一个实体，但不负责数据传输的方式。 能力： 数据分隔重组：将数据拆分后按顺序重组 纠错：在数据传输过程中出现问题后采取方式进行纠正 管理连接：处理数据的频繁交换 流量控制：控制传输数据的速率 端口寻址：标明参与传输的实体的端口号 网络层
负责把一个封包从一个IP地址传输到另一个IP地址 思考：一个节点接收到一个封包之后，它怎么把这个封包传递到下个节点？ 路由算法 数据链路层
确保两个临近设备间数据的传输，并隐藏底层实现 帧同步：两个设备之间传输时的协商速率问题 数据纠错 物理层
封装和隐藏具体的传输手段，并且提供稳定的传输接口 比如：电缆、光纤、蓝牙等 3、OSI的问题 分层设计较为臃肿，并非每一层都为必要的，所以有了 应用层、表示层、会话层合为应用层</content></entry><entry><title>centos7安装docker并设置开机启动</title><url>/post/63/</url><categories><category>Linux</category></categories><tags><tag>Docker</tag></tags><content type="html"> 1、准备 一台可以上网的centos7服务器
2.安装命令 yum -y install docker 2.1 启动docker命令
#启动 service docker start #重启 service docker restart 2.2 停止docker命令
service docker stop 3、设置开机启动 systemctl enable docker 4、重启linux服务器 shutdown -r now 5、检查docker是否启动状态 systemctl status docker</content></entry><entry><title>设计模式</title><url>/post/62/</url><categories><category>Java</category></categories><tags><tag>设计模式</tag></tags><content type="html"> 设计模式（Design pattern）： 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。
1、设计模式的分类 设计模式分为三大类：
创建型模式： 单例模式 、 工厂方法模式 、 抽象工厂模式 、 建造者模式 、 原型模式 。
结构型模式： 适配器模式 、 装饰模式 、 代理模式 、 外观模式 、 桥接模式 、 组合模式 、 享元模式 。
行为型模式： 策略模式 、 模板方法模式 、 观察者模式 、 迭代器模式 、 责任链模式 、 命令模式 、 备忘录模式 、 状态模式 、 访问者模式 、 中介者模式 、解释器模式。
2、设计模式的7大原则 开闭原则 开闭原则：就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类
里氏替换原则 里氏替换原则：主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。
依赖倒置原则 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。
单一职责原则 单一职责原则：核心就是控制类的粒度大小、将对象解耦、提高其内聚性。
接口隔离原则 接口隔离原则： 是为了约束接口、降低类对接口的依赖性，提高类的内聚性、降低它们之间的耦合性
迪米特法则 迪米特法则：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。其目的是降低类之间的耦合度，提 …</content></entry><entry><title>rsync数据同步备份工具</title><url>/post/5/</url><categories><category>工具</category></categories><tags><tag>rsync</tag><tag>数据同步备份</tag></tags><content type="html"><![CDATA[  1、介绍rsync工具 1.1 rsync是什么：
一款开源的，快速的，多功能的，可以实现全量和增量的本地或远程数据同步备份工具。
1.2 使用范围 :
unix,linux,windows等多种操作系统
1.3 优点：
1.具有本地和远程两台主机之间数据快速复制同步，备份功能
2.能实现增量备份，具有独特的quick check算法
1.4 工作方式：
1.单个本机之间数据传输，类似于cp命令。
2.借助rcp,ssh通道传输数据，类似于scp。
3.以守护进程（socket）方式传输数据。
2、实践 示例：以虚拟机与本地机器（自己实体电脑）数据备份为例
2.1 简单说明：
自己电脑内安装VirtualBox虚拟机通过共享文件的方式把虚拟机内产生的数据备份到自己电脑的磁盘上
2.2 环境：
台式机一台，安装VirtualBox虚拟机
2.3 准备脚本(databak.sh)
/usr/bin/rsync --timeout=60 --progress --log-file=&#39;/opt/logs/rsync.log&#39; --log-file-format=&#39;%t %f %b&#39; -azvP /opt/all_data /media/sf_2/ 2.4 脚本命令解释：
该命令使用rsync工具将/opt/all_data目录及其内容同步到/media/sf_2/目录。
具体参数解释如下：
&ndash;timeout=60：设置连接超时时间为60秒。 &ndash;progress：显示进度条。 &ndash;log-file=&rsquo;/opt/logs/rsync.log&rsquo;：将rsync的日志记录到/opt/logs/rsync.log文件中。 &ndash;log-file-format=&rsquo;%t %f %b&rsquo;：日志文件的格式为时间、文件名和字节大小。 -a 以递归方式传输文件，并保持所有文件的属性 -z 传输时进行压缩以提高传输效率 -v 详细模式输出 -P 显示同步的过程及传输时的进度等信息 2.5 crontab简单操作命令：
crontab -l 查看 crontab -e 编辑 service crond restart 重启 2.6 crontab定时任务，数据备份命令：
0 3 * * * /usr/bin/sh /opt/databak.sh &gt; /dev/null 2&gt;&amp;1 2.7 cron表达式解释：
表示每天凌晨0点用shell执行/opt/databak.sh脚本，并将输出重定向到/null。
具体解释如下：
0：表示分钟数，即0分。 3：表示小时数，即0-23小时之间的第3个小时。 *：表示日期（月份、星期等）的通配符，表示每小时执行。 *：表示日期（月份、星期等）的通配符，表示每天执行。 &gt; /dev/null：将标准输出重定向到/null，即不输出任何结果。 2&gt;&amp;1：将错误输出重定向到标准输出，即仍然保留错误输出，只是不输出正常输出。   ]]></content></entry><entry><title>Git之merge和rebase命令</title><url>/post/70/</url><categories><category>工具</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[  开发一个新的功能(拉分支开发)为例介绍merge和rebase
1、merge 1、A分支拉取test分支开发
2、新建test分支：git checkout -b test
3、test分支开发完成，合并test分支到A分支
4、切到A分支：git checkout A
5、合并test分支 ：git merge test
6、查看一下分支提交历史，会看到一个分叉的分支
* | \ * * | | | / * 2、rebase 1、A分支拉取test分支开发
2、新建test分支 ：git checkout -b test
3、在test分支上执行: git rebase A(以A为基础，将test分支上的修改增加到A分支上，并生成新的版本。)
4、有冲突，先解决冲突，再git rebase --continue
5、再查看一下提交历史,(HEAD-&gt;test)提交记录已经是一条完美的直线。
* (HEAD-&gt;test) | * | * 6、切到A分支：git checkout A
7、合并test分支： git merge test
8、再查看一下提交历史,(HEAD-&gt;A,test)
* (HEAD-&gt;A,test) | * | * 9、收尾，删除test分支：git branch -d test
  ]]></content></entry><entry><title>使用git将本地项目推送到码云仓库</title><url>/post/69/</url><categories><category>工具</category></categories><tags><tag>Git</tag></tags><content type="html"><![CDATA[  1、步骤 以下命令我是基于mac的终端执行的，也可在windows上的CMD窗口或者git的客户端git bash窗口中执行。
（1）打开Git Bash, 生成公钥
ssh-keygen -t rsa -C &#34;码云注册邮箱&#34; （2）添加到本地公钥
ssh-agent bash ssh-add ~/.ssh/id_rsa （3）查看公钥内容
cat ~/.ssh/id_rsa.pub （4）复制公钥内容并配置到码云上
（5）在码云上创建新的项目，设置为私有或公有
（6）进入本地项目文件，打开命令窗口
git init （7）等初始化完成后将项目添加到本地仓库中
git add . （8）查看一下git状态，看是否添加成功
git status （9）commit到本地仓库
git commit -am &#34;提交时描述信息&#34; （10）连接到远程码云仓库
git remote add origin 仓库地址 # 注：仓库地址可以从码云项目中的克隆/下载找到，选择SSH （11）如果是第一次执行，可以先需要pull一下
git pull （12）将本地代码push到码云的master主分支上
git push -u -f origin master   ]]></content></entry><entry><title>12.Java中的字符串缓冲区和正则表达式</title><url>/post/55/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>缓冲区</tag><tag>正则表达式</tag></tags><content type="html"> 1、字符串缓冲区 1.1 概念：
就是用来保存临时的字符数据的空间；
1.2 Java的字符串缓冲区类：
StringBuffer：是线程安全的，效率相对比较低；如果在多线程环境下，对线程安全有要求，就要使用StringBuffer；
StringBuilder：是线程不安全的，效率相对比较高；如果在单线程环境下，或者对线程安全没有要求，就可以使用StringBuilder；
1.3 操作：缓冲区是一个容器，对容器的数据操作，一般都有四种操作
增：表示向容器中添加数据 删：表示从容器中移除数据 改：表示修改容器中的数据 查：表示从容器中获取数据 对于字符串缓冲区来说，开发中常用到的方法主要就是toString、append、insert、revers、substring和setLength这几个方法；
其他的用到的时候知道怎么查API文档就行了
2、正则表达式 2.1 概念：
就是使用一些特殊符号组成的一种匹配规则，可以用来对字符串进行匹配的；
2.2 正则的写法：
一般字符： 表示匹配自身；如：a,表示匹配的字符传的值只能是a；所有普通字符串，都可以看作是一个正则表达式，匹配的是它自身； 字符类： 使用中括号[]和里面的内容组成，表示一个字符的取值范围；如：[a-z]：表示被匹配的字符的值可以是所有的小写字母； 预定义字符： 使用特殊符号或转义字符组成的表示特殊匹配范围的规则，如：. 表示匹配所有字符；\d表示匹配0-9的所有数字； 边界符： 表示匹配一些字符串的边界，如：^：表示匹配一行的开始；$：表示匹配一行的结束； 数量词： 前面必须跟一个规则，表示这个规则可以重复的次数；如：\d+：表示最少有一个数字；.?：表示最多有一个任意字符； 运算符: 组
有的时候，希望可以调用前面已经定义好的规则，让调用的地方匹配的内容和前面一致，就可以使用组
概念：就是使用小括号括起来的一段规则；后面调用是使用组出现的顺序的序号来调用的； 调用的格式是：\\组号 在同一个语句中，后面的正则表达式也可以引用前面正则表达式中定义的规则，使用的格式是：$组号 2.3 常见应用
匹配字符串 /** 需求：验证手机号码是否合法： 手机号码的规则： 1、号码是11位数字； 2、号码只能以1开头； 3、号码的第二位可以是：3，4，5，7，8； 4、从第三位开始后面的数字都可以是0到9的任意数 …</content></entry><entry><title>ssh免密码登录</title><url>/post/67/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag></tags><content type="html"> 示例：两台linux主机，主机A要免密码登录到主机B
1、准备工作 两台linux主机A、B(也可以是虚拟机) 2、密钥文件生成 生成A，B两机器的各自密钥文件，生成方法如下：
[root@hangzhi ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #按回车键跳过 Created directory &amp;#39;/root/.ssh&amp;#39;. Enter passphrase (empty for no passphrase): #按回车键跳过 Enter same passphrase again: #按回车键跳过 Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:AAH7q02rnbC3EFBrwhoBQuPzQ1NPRM9fnw3aQAnl/PU root@hangzhi The key&amp;#39;s randomart image is: +---[RSA 2048]----+ |*oo.ooo+ .oo. | |+o.o..o o +. | |+++o .. o +.. .| |.=+.. . . .=.o+| |. .o. S .. ooE| | ... | | o o | | O.o | | +o*. | +----[SHA256]-----+ 3、配置密钥文件 示例是主机A要免密码登录到主机B，所以要在主机B的认证文件中配置主机A的密钥
在主机B上编辑/root/.ssh/authorized_keys文件， 将主机A的/root/.ssh/id_rsa.pub的密钥粘贴进去即可</content></entry><entry><title>11.Java中的String类讲解</title><url>/post/54/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag></tags><content type="html"> 使用面向对象的方式写程序，很多时候都是在直接使用别人写好的类；
JDK中提供了大量类供我们使用，不过我们不需要去学习所有的类，只需要掌握开发中常用的几个类就行了；
要用其他类只要会查API文档就行了；
1、简介 在Java中，我们使用最多的数据，除了基本类型，就是字符串了；字符串使用String类描述，
1、使用String类，不需要手动导包；
2、String类直接继承Object类；
3、String类使用final关键字修饰，不能被子类继承；
4、java中，所有字符串，都是String类的对象；
5、String对象创建之后，里面的数据不能改变；
6、如果需要经常修改字符串，应该使用字符串缓冲区；
7、相同字面值（指的就是一个字符串中双引号括起来的字符）的字符串对象，内存中只会保存一份，多个相同字面值的字符串，内存中实际是共享的；
2、String对象的内存图解 3、String类的简单问题 String str1 = “abc”； 在常量池中创建了一个字符串对象，然后将这个对象的内存地址赋值给变量str1
String str2 = new String(“abc”); 在堆内存中也创建一个对象，然后这个对象里面是常量池中字符串对象的内存地址，然后将堆内存中的对象的内存地址赋值给变量str2
String str3 = “abc”; 这个没有创建对象，直接将常量池中已经创建的对象的内存地址赋值给变量str3
问：执行这几行代码总共会创建几个对象？ 两个对象
问：str1 == str2输出什么？ false
问：str1 == str3 输出什么？ true
4、String的常用方法 4.1 获取方法
int length(); //获取字符串的长度 char charAt( int index ) //根据指定的下标获取对应的字符数据 int indexOf( int ch ) //获取指定的字符在字符串中从前往后第一次出现的下标 int indexOf( int ch ， int fromIndex ) //获取指定的字符在字符串中从指定的位置往后第一次出现的下标 int indexOf( String str ) //获取指定的字符串在字符串中从前往后第一次出现的下标 int indexOf( String str ，int fromIndex ) …</content></entry><entry><title>10.Java中如何处理异常</title><url>/post/53/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>异常类</tag></tags><content type="html"> 1、介绍 1.1 概念：
异常，就是不正常情况；程序中出现不符合预期的情况就是异常；
1.2 作用：
可以针对程序中出现的问题作出相应处理，提高程序健壮性； 在程序中发生异常的地方通过日志技术将问题记录下来，帮助开发者快速排查错误； 2、异常体系&amp;amp;amp;分类 2.1 体系
Throwable：java异常体系的最高父类；java中所有可被抛出、捕获或声明的异常类，都要继承这个类或它的子类； Error：错误，表示程序中严重的不能被JVM处理的问题；遇到这种问题，JVM都会停止运行； Exception：异常，表示程序中可以被JVM处理的问题；如果程序中抛出该类或它的子类的异常，编译时就会检查有没有书写处理的代码；如果没有写，就会报错； RuntimeException：表示运行时异常；该类和它的子类表示的异常，在编译期不会检查； 非RuntimeException：表示编译期异常； 2.2 分类
编译期异常 概念：指的是Exception及其子类（不包括RuntimeException和它的子类）表示的异常； 特点：如果在程序中使用throw关键字显示的抛出这类异常，编译时编译器会检查有没有书写处理代码，如果没有就会报错；（也就是说，程序中如果抛出这类异常，必须处理） 运行期异常： 概念：指的是RuntimeException和它的子类表示的异常； 特点：如果程序中使用throw关键字显示的抛出这类异常，不管书写处理代码没有，编译时编译器都不管； 编译期异常和运行期异常，指的是编译的时候，是否检查书写了处理代码；
2.3 图解： 3、自定义异常 因为JDK中提供的异常类太多，不方便记忆和使用，所以需要自定义异常
Error表示 程序中严重的不应该处理的问题；
Exception表示程序中应该自己能够处理的问题；
所以，一般自定义异常，可以继承Exception，而不要去继承Error；
3.1 自定义异常的步骤:
1.定义一个类，让它继承Exception或RuntimeException；
2.创建一个构造函数，接收一个表示异常信息的参数；
3.调用父类的有参构造函数，将接收的异常信息传递给父类的构造函数；
4.示例：
//需求：创建一个描述人的信息的类，需要对年龄的合法性进行判断； class WrongAgeException extends …</content></entry><entry><title>8.Java基础知识：面向对象04</title><url>/post/51/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>面向对象</tag></tags><content type="html"> 1、抽象类 1.1 概念：将abstract关键字写在class前面的类叫抽象类
抽象函数格式:
抽象函数没有函数体,连大括号都没有
抽象函数用abstract关键字修饰,写在返回值类型前面
如果一个函数描述不清，不知道具体该如何实现，就要定义为抽象函数；
如果一个类中存在抽象函数，这个类就是描述不清的，也要定义为抽象类
1.2 特点:
1.抽象类不能实例化(不能创建对象),只能由子类继承
2.子类继承抽象类,必须实现父类的抽象函数;否则子类也是抽象的
3.抽象函数不能直接使用,必须通过子类的继承使用
1.3 部分问题
1.抽象类一定是父类吗?
是的；
因为抽象类本来就是多个不同子类不断向上抽取，最终发现无法具体实现而得到的；
如果要使用抽象类，必须有子类继承它，然后实现所有抽象函数；
2.抽象类可以书写那些成员?
任意成员
3.抽象类中可以不书写抽象方法吗？
可以
4.抽象关键字abstract不能和哪些关键字共存？
private；final：因为抽象函数必须被子类重写； 而private和final修饰的函数都不能被重写；
static：因为static修饰的函数是静态的，不需要对象就可以直接使用；
如果抽象函数是静态的，也就可以直接通过类名调用；而调用一个抽象函数没有意义
5.一个类什么时候需要定义为抽象类？
1、类中存在抽象函数；
2、如果一个类中没有抽象函数，但是不希望被实例化，也需要定义为抽象类；
3、如果一个类不希望创建对象，就可以定义为一个抽象类；
6.抽象类可以继承非抽象类吗?
可以
2、多态 2.1 概念：
指的就是同一个事物可以有多种不同的表示形态；
2.2 java中的多态：
父类引用指向子类对象；（接口类型引用指向实现类对象）
2.3 使用前提：
两个类型之间必须有继承关系（或者存在接口的实现关系）
2.4 类型转换：
自动向上转型： 可以直接将子类型引用赋值给父类型变量，可以自动进行，叫做自动向上转型；
class Fu{} class Zi extends Fu{} Zi zi = new Zi(); Fu f = zi;//这行代码就发生了自动向上转型 强制向下转型： java中允许将父类型引用赋值给子类型变量，叫做向下转型；但是这种转型不能自动实现，需要强制进行，所以叫做强制向下转型；
class Fu{} class Zi …</content></entry><entry><title>9.Java基础知识：面向对象05</title><url>/post/52/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>面向对象</tag></tags><content type="html"> 1、内部类 1.1 概念：
就是一个类定义在其他类里面的类；包含其他类的类，叫做外部类；被外部类包含的类，叫做内部类；
1.2 分类（根据书写位置分）
1.2.1 成员内部类（根据修饰符的不同分）
静态成员内部类： 使用static修饰的内部类就是静态成员内部类；
静态成员内部类，也和外部类的对象无关；
静态成员内部类中可以书写任何成员；
在外部类以外的类中使用静态成员内部类，和使用普通类一样，只需要在类名前添加外部类的类名；
在外部类中，不管是静态函数还是非静态函数，使用静态成员内部类的静态成员，都是直接通过类名使用；
使用静态成员内部类的非静态成员，都是通过内部类的对象使用；
创建内部类的对象，都可以直接创建，因为和外部类的对象无关；
非静态成员内部类： 不使用static关键字修饰的成员内部类就叫做非静态成员内部类；
非静态成员内部类，必须依赖外部类的对象存在
非静态成员内部类中，只能书写非静态成员和常量变量，不能书写静态成员（除非是常量变量）
私有成员内部类： 使用private关键字修饰的成员内部类就是私有成员内部类；
这里私有只是限制这个成员内部类不能在外部类之外的地方使用，其它的用法和前面讲的静态成员内部类和非静态成员内部类的用法一样；
1.2.2 局部内部类
概念：定义在局部位置（函数里面）的内部类就叫做局部内部类；
局部内部类中可以书写的成员，和非静态成员内部类一样，只能书写非静态成员，不能书写静态成员，除非是常量变量；
在外部类的静态函数中定义的局部内部类，可以直接使用外部类的静态成员，不能直接使用外部类的非静态成员，需要通过外部类的对象使用；
在外部类的非静态函数中定义的局部内部类，可以直接使用外部类的静态和非静态成员；
2、匿名内部类 2.1 匿名内部类，就是一种格式：
class A{}//表示定义一个A类 new A()//表示创建A类的一个对象 new A(){}//表示创建A类的一个匿名子类的对象，后面大括号中的内容，就是匿名子类中的内容； interface Inter{}//表示创建了一个接口Inter new Inter(){} //表示创建了接口Inter的一个匿名实现类的对象，后面大括号中的内容，就是匿名实现类中的内容； 2.2 示例
interface Inter{ public void show(); } class …</content></entry><entry><title>7.Java基础知识：面向对象03</title><url>/post/50/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>面向对象</tag></tags><content type="html"> 1、代码块 1.1 概念：就是使用大括号括起来的一段代码；
1.2 格式
{ 代码； } 1.3 分类（代码块的按照书写位置）：
局部代码块 书写在一个类的局部位置（函数里面的）的代码块就是局部代码块；
局部代码块，因为定义在函数里面，所以不能直接使用，而是通过调用它所在的函数来执行；
局部代码块，可以用来限定变量的使用范围；
成员代码块（根据是否使用static关键字修饰再分类） 静态代码块：静态代码块直接写在类里面，使用static关键字修饰。
构造代码块：也是直接写在类中，但是不需要static关键字修饰。
1.4 类加载顺序 1.5 对象创建过程 2、单例设计 2.1 概念：
单例设计模式：解决的就是在程序运行过程中，一个类最多只能创建一个对象的问题；
2.2 步骤：
1.私有化构造函数；
2.在本类中创建唯一实例对象，使用一个私有静态的成员变量保存
3.对外提供一个公开的静态的函数获供别人获取这个唯一实例对象
2.3 代码实现
饿汉式 class Single{ //1.私有化构造函数 private Single(){} //2.在本类中创建唯一实例对象，使用一个静态私有成员变量保存 private static Single single = new Single(); //3.对外提供一个公开的静态函数 public static Single getInstance(){ return single; } } 懒汉式 class Single{ //1.私有化构造函数 private Single(){} //2.在本类中创建唯一实例对象，使用一个静态私有成员变量保存 private static Single single = null; //3.对外提供一个公开的静态函数 public static Single getInstance(){ if(single == null){ single = new Single(); } return single; } } 3、继承 3.1 概念：
java中的继承指的是使用extends关键字在两个类之间建立的一种关系；其中，继承其他类的类，叫做子类（派生类），被其他类继承的类叫做父类（超类、基类）；
3.2 格式
class Fu{}//表示被继承的类，是父类 class Zi extends …</content></entry><entry><title>6.Java基础知识：面向对象02</title><url>/post/49/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>面向对象</tag></tags><content type="html"> 1、封装 1.1 概念： 封装，就是包装的意思
1.2 用法：
java中的封装： 函数：封装了一段实现功能的代码；
类：封装了函数和成员变量；
如果外界需要访问被封装的成员变量，就需要在类中提供公开的get和set方法
封装的好处：提高代码复用性；隐藏内部实现细节，提高安全性；
private关键字 一个访问权限修饰符，表示被修饰的成员（成员变量、函数）是私有的，只能在定义它的类中使用，不能被其他地方使用；
修饰成员变量，直接将private关键字写在成员变量的数据类型前面；
修饰函数，写在函数最前面；
public关键字 一个访问权限修饰符，表示被修饰的成员是公开的，所有地方都能使用；
public可以修饰成员变量、函数和类；如果修饰类，这个类的类名必须和java的文件名一致；所以一个java文件中可以写多个类，但最多只能由一个public的类；
set和get函数 格式：
set的方法名：set + 变量名（变量名首字母大写）
get的方法名：get + 变量名（变量名首字母大写）
2、构造函数 2.1 概念和作用
概念：构造函数，又叫做构造器，就是在对象创建的时候由JVM自动调用的函数；
作用：构造函数就是用来在创建对象的时候给对象的成员变量赋值用的
2.2 写法
修饰符： 可以使用访问权限修饰符，不能使用static关键字修饰；
返回值类型： 构造函数没有返回值类型；void都不能写；（要区分普通函数和构造函数，就看有没有返回值类型）
函数名： 构造函数的函数名，必须和类名完全一致；
参数列表： 构造函数可以重载，参数列表根据需求，需要怎么写就怎么写；
return语句： 有return语句，也是通过return语句结束出栈；一般都不需要写；
2.3 过程
1.JVM执行时遇到new关键字，首先要到堆内存中开辟对象空间，然后将类中的成员变量加载到对象空间中，分配变量空间，赋默认值；
2.根据new关键字后面的代码，调用相应的构造函数进栈执行；
3.构造函数进栈执行，先执行隐藏步，然后执行构造函数中的代码，等构造函数结束出栈，对象创建完成
隐藏步：
1.执行super()语句，调用父类构造函数；
2.给对象空间中的成员变量显示赋值；
3.如果有构造代码块，要执行构造代码块；
默认构造函数 实际上，在java中，每一个类都至少有一个构造函数；一个类要创建对象， …</content></entry><entry><title>5.Java基础知识：面向对象01</title><url>/post/48/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>面向对象</tag></tags><content type="html"> 1、面向过程和面向对象 1.1 面向过程
按照这种思想写程序，我们就要先分析整个程序有哪些功能组成，然后分别写函数实现每一个功能，最后按顺序调用这些函数，实现整个功能；
1.2 面向对象
是一种解决问题的思想；按照这种思想解决问题，我们关心的是事情中有哪些参与者
1.3 举例：
例如：吃饺子 面向过程的方法： 1、包饺子：买菜、洗菜，买面粉；先剁馅，再和面；包饺子； 2、煮饺子：烧开水，下饺子； 3、吃饺子： 4、收拾：收拾碗筷； 面向对象的方法： 1、有饺子：找个饺子馆，告诉老板要吃什么馅，多少个饺子，然后等； 2、吃饺子：服务员端上饺子，开吃； 按照面向过程的方式写程序，我们要亲自写函数实现每一步功能 而按照面向对象的方式写程序，我们一般都是在使用别人已经写好的 1.4 区别：
关注点不同： 面向过程：关心的是事件中的每一步功能怎么做；
面向对象：关心的是事件中的每一步功能有没有什么对象已经实现好了，然后直接拿来使用；
效率不同： 面向过程：因为自己要参与每一步的实现，所以效率比较慢；
面向对象：因为大多数都是调用别人已经实现好的功能，所以效率比较高；
开发质量： 面向过程：因为是自己一步步实现的，大多数情况会有地方会出问题；
面向对象：因为大多数都是调用别人写好的功能，而这些功能一般都经过大量的验证，质量有保证；
使用范围不同： 面向过程：适合解决需求简单的问题；
面向对象：更适合解决复杂的需求；
注意：面向对象里面也有过程存在；面向对象是基于过程的，二者并不排斥；
2、对象在需求中的使用 使用伪代码描述 人吃饺子 场景：
1.找对象 名词： 人 饺子 对象： 人 饺子 2.描述对象： 人｛ 吃（饺子）｛｝ ｝ 饺子｛｝ 3.模拟场景： // 创建人和饺子的对象 人 小明 = new 人（）； 饺子 东北饺子 = new 饺子（）； //模拟场景 小明.吃（东北饺子）； 3、对象在代码中的体现 /** 1.找对象 名词： 人 饺子 对象： 人 饺子 2.描述对象： 人｛ 吃（饺子）｛｝ ｝ 饺子｛｝ 3.模拟场景： // 创建人和饺子的对象 人 小明 = new 人（）； 饺子 东北饺子 = new 饺子（）； //模拟场景 小明.吃（东北饺子）； */ // 使用面向对象思想，用伪代码描述一个场景； class Person{ void …</content></entry><entry><title>轻量级Docker图形页面管理之Portainer搭建</title><url>/post/64/</url><categories><category>Docker</category></categories><tags><tag>Portainer搭建</tag></tags><content type="html"> 1、docker搜索 [root@hangzhi ~]# docker search portainer 2、选择 docker.io/portainer/portainer 下载最新版 [root@hangzhi ~]# docker pull docker.io/portainer/portainer 3、新建挂载目录 [root@hangzhi ~]# mkdir -p /opt/all_data/portainer/data 4、启动容器命令 docker run -d -p 19000:9000 --restart=always \ --name portainer \ -v /var/run/docker.sock:/var/run/docker.sock \ -v /opt/all_data/portainer/data:/data \ --hostname portainer portainer/portainer:latest 参数说明：
-v /var/run/docker.sock:/var/run/docker.sock:把宿主机的Docker守护进程(Docker daemon)默认监听的Unix域套接字挂载到容器中 -v /opt/all_data/portainer/data:/data:把宿主机/opt/all_data/portainer/data数据卷挂载到容器/data目录 5、web界面 1.登陆 http://ip:19000，设置管理员账号和密码。
2.单机版在新页面选择 Local 即可完成安装，集群选择Remote然后输入SWARM的IP地址，点击Connect完成安装。</content></entry><entry><title>docker安装Redis（单机版）</title><url>/post/71/</url><categories><category>Docker</category></categories><tags><tag>Redis</tag></tags><content type="html"> 1、拉取最新镜像 docker pull redis:latest 2、创建外挂配置和数据文件夹 mkdir -p /opt/redis/config mkdir -p /opt/redis/data 官网redis.conf下载 在/opt/redis/config目录下，下载官网配置文件再修改，修改内容如下：
bind 0.0.0.0 # 这是redis可以任何ip都可以访问， port 6379 #访问端口，最好不要使用默认端口 requirepass 123456 #设置密码，不要太简单 maxmemory 157286400 #设置内存，默认单位bytes ，如果maxmemory值为0，表示不做限制 其他配置请参考官方 3、启动命令 docker run -p 16379:16379 --name redis \ -v /opt/redis/conf/redis.conf:/etc/redis/redis.conf \ -v /opt/redis/data:/data \ -d --hostname redis redis:latest redis-server /etc/redis/redis.conf --appendonly yes</content></entry><entry><title>4.Java基础知识：数组</title><url>/post/47/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>数组</tag></tags><content type="html"><![CDATA[  1、数组 1.1 介绍：
把具有相同类型的若干变量按有序的形式组织起来,这些按序排列的同类数据元素的集合称为数组。
1.2 格式一：
元素类型[] 数组名 = new 元素类型[元素个数或数组长度]; 示例 : int[] arr = new int[5]; 如何存储数据到数组之中： 语法 :数组名[元素的下标] = 数据;
如何去取存储在数组之中的数据： 语法 : 数组名[元素的下标];
如何遍历数组的元素: public class Demo { public static void main(String[] args) { // 1. 元素类型[] 数组名 = new 元素类型[元素个数或数组长度]; int[] arr = new int[5]; //存数据 arr[0] = 98; arr[1] = 88; arr[2] = 100; arr[3] = 80; arr[4] = 99; //取数据 System.out.println(&amp;#34;arr[0]=&amp;#34; + arr[0]); System.out.println(&amp;#34;arr[1]=&amp;#34; + arr[1]); System.out.println(&amp;#34;arr[2]=&amp;#34; + arr[2]); System.out.println(&amp;#34;arr[3]=&amp;#34; + arr[3]); System.out.println(&amp;#34;arr[4]=&amp;#34; + arr[4]); System.out.println(&amp;#34;arr.length=&amp;#34; + arr.length); //遍历 for (int i = 0; i &amp;lt; arr.length; i++) { System.out.println(arr[i]); } } } 1.3 格式二：
元素类型[] 数组名 = new 元素类型[] {元素, 元素, ......}; 示例 : int[] arr = new int[]{1, 3, 5, 7, 9}; int[] arr = {1, 3, 5, 7, 9}; 1.4 总结
数组是用来干嘛的？ 数组是用来存储多个相同类型的数据。
什么时候使用数组？ 当有一组数据， 并且这组数据的意义是相同的， 意义相同，肯定类型就是一样的。
如何创建数 …  ]]></content></entry><entry><title>Linux下安装jupyter</title><url>/post/1/</url><categories><category>Linux</category></categories><tags><tag>jupyter</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  1.安装jupyter # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install jupyter 2.生成jupyter配置文件 # root用户： jupyter notebook –generate-config –allow-root # 非root用户 jupyter notebook –generate-config #输出信息：Writing default config to: /root/.jupyter/jupyter_notebook_config.py # 配置文件地址： /root/.jupyter/jupyter_notebook_config.py 3.打开ipython,生成密码 [root@hangzhi ~]# ipython In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: #此处输入密码 Verify password: #此处输入之前输入的密码 Out[2]: &#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; #这个秘钥要copy备用 4.修改配置文件 [root@hangzhi ~]# vi /root/.jupyter/jupyter_notebook_config.py # notebook服务会监听的IP地址 c.NotebookApp.ip = &#39;&#39; #工作目录，自己选定 c.NotebookApp.notebook_dir = &#39;/opt/jupyter/jupyter_work&#39; c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 #上面生成的秘钥 c.NotebookApp.password = u&#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; 5.启动jupyter # root用户 jupyter notebook –allow-root # 非root用户 jupyter notebook 后台启动脚本 # root用户 nohup jupyter notebook --allow-root &gt; /opt/logs/jupyter.log 2&gt;&amp;1 &amp; 停止脚本 #!/bin/bash #停止服务名称 SERVER_NAME=jupyter-notebook PIDS=`ps -ef | grep jupyter |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep jupyter` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34; 6.浏览器访问 ip:8888 即可访问了，需输入密码就可以   ]]></content></entry><entry><title>3.Java基础知识：函数</title><url>/post/46/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>函数</tag></tags><content type="html"><![CDATA[  1、函数 1.1 介绍：
就是定义在 类中 的 具有特定功能 的一段 独立小程序，与main函数同级别。
1.2 语法：
修饰符 返回值类型 函数名(参数类型 形式参数1, 参数类型 形式参数2, ...) { 执行语句; return 返回值; } 返回值类型 : 函数运行后结果的数据类型。 参数类型 : 是形式参数的数据类型。 形式参数 : 是一个变量,用于存储调用函数时传递给函数的实际参数。 实际参数 : 传递给形式参数的具体数值。 return : 用于结束函数。
注意 : 如果函数返回值类型为 void, 默认可以不写 return; 但,系统会默认在结束处自动添加 return 关键字。 返回值 : 该函数运算后的结果.该结果会返回给调用者。 1.3 函数的作用 :
将一段需要被重用的代码封装在函数之中, 什么时候想要执行这段代码, 只需要调用这个函数就可以了.并且函数可以实现在调用时传入参数信息,并且在运算完成之后返回结果信息给调用者.
1.4 带一个参数的函数
public class Demo { public static void main(String[] args) { oddOrEven(9); oddOrEven(10); } // 判断奇偶数 public static void oddOrEven(int num) { // 判断思路 : 用这个额数模以2,等于0,就是偶数,否则就是奇数 if (num % 2 == 0) { System.out.println(&amp;#34;num:&amp;#34; + num + &amp;#34;是一个偶数&amp;#34;); } else { System.out.println(&amp;#34;num:&amp;#34; + num + &amp;#34;是一个奇数&amp;#34;); } } } 1.5 带多个参数的函数
public class Demo { public static void main(String[] args) { // 调用自定义函数 oddAndEven(131); int r = getSum(10, 20); System.out.println(&amp;#34;r=&amp;#34; + r); int max = getMax(40, 20); System.out.println(&amp;#34;max=&amp;#34; …  ]]></content></entry><entry><title>1.Java基础概述</title><url>/post/44/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag></tags><content type="html"> 1、简介 Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。
后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。
2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 &amp;amp;ldquo;2&amp;amp;rdquo;：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。
2、Java 三个体系： Java SE（Java 2 Platform Standard Edition）标准版【J2SE】 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE，是其它两者的基础。
Java ME（Java 2 Platform Micro Edition）小型版、微型版【J2ME】 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME。
Java EE（Java 2 Platform Enterprise Edition）企业版【J2EE】 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE。
三种技术的关系： 3、Java语言的特性 简单性（简洁有效、易学） Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。
面向对象（强制面向对象） Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制。
Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。
分布式处理（适合分布式计算） Java语言支持Internet应用的开发，在基本的Java应用编程接口中有 …</content></entry><entry><title>2.Java基础知识：语法</title><url>/post/45/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag><tag>语法</tag></tags><content type="html"> 1、Java中的关键字 关键字 说明 abstract 表明类或者成员方法具有抽象属性 assert 用来进行程序调试 boolean 基本数据类型之一，布尔类型 break 提前跳出一个块 byte 基本数据类型之一，字节类型 case 用在switch语句之中，表示其中的一个分支 catch 用在异常处理中，用来捕捉异常 char 基本数据类型之一，字符类型 class 类 const 保留关键字，没有具体含义 continue 回到一个块的开始处 default 默认，例如，用在switch语句中，表明一个默认的分支 do 用在do-while循环结构中 double 基本数据类型之一，双精度浮点数类型 else 用在条件语句中，表明当条件不成立时的分支 enum 枚举 extends 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口 final 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变 finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块 float 基本数据类型之一，单精度浮点数类型 for 一种循环结构的引导词 goto 保留关键字，没有具体含义 if 条件语句的引导词 implements 表明一个类实现了给定的接口 import 表明要访问指定的类或包 instanceof 用来测试一个对象是否是指定类型的实例对象 int 基本数据类型之一，整数类型 interface 接口 long 基本数据类型之一，长整数类型 native 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 new 用来创建新实例对象 package 包 private 一种访问控制方式：私用模式 protected 一种访问控制方式：保护模式 public 一种访问控制方式：共用模式 return 从成员方法中返回数据 short 基本数据类型之一,短整数类型 static 表明具有静态属性 strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 super 表明当前对象的父类型的引用或者父类型的构造方法 switch 分支语句结构的引导词 synchronized 表明一段代码需要同步执行 this 指向当前实例对象 …</content></entry><entry><title>13.Python处理高级数据结构和数据分析常用扩展库：Pandas</title><url>/post/43/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、Pandas介绍 Pandas是一个用于处理高级数据结构和数据分析的Python库。基于Numpy构建的一种工具，纳入了大量模块和库一些标准的数据模型，提高python处理大数据的性能。广泛应用于金融、经济、数据分析、统计等商业领域，为从业者提供了便捷。
特点：
支持Dataframe格式，自定义索引，Dataframe是一种高效快速的数据结构对象 可以将不同格式的数据文件加载到内存中 可处理时间序列或非时间序列数据 可基于标签来切片索引，获得大数据集子集 可进行高性能数据分组、聚合、添加、删除 未对齐及索引方式不同的数据可按轴自动对齐 灵活处理数据缺失、重组、空格 2、Pandas安装 # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install pandas 3、Series数据结构 Series类似一维数组，数组由数据与其索引标签组成，索引在左侧，值在右侧。
3.1、创建Series数组
import pandas as pd import numpy as np # 创建Series数组 s1 = pd.Series([1,2,3,4]) print(&amp;#34;s1:&amp;#34;,s1) # 创建Series数组并设置index参数 s2 = pd.Series([1,2,3,4],index=[&amp;#39;一&amp;#39;,&amp;#39;二&amp;#39;,&amp;#39;三&amp;#39;,&amp;#39;四&amp;#39;]) print(&amp;#34;s2:&amp;#34;,s2) 3.2、Series的索引和切片
通过Series的value和index属性可以获取Series中的索引和数值
# Series索引和切片 print(&amp;#39;s2的索引：&amp;#39;,s2.index) print(&amp;#39;s2的值：&amp;#39;,s2.values) # 通过索引获取值或者修改（索引是不可以修改的） # 单索引 print(&amp;#39;s2中二对应的值&amp;#39;,s2[&amp;#39;二&amp;#39;]) s2[&amp;#39;二&amp;#39;] = 5 print(&amp;#39;s2中二对应的值&amp;#39;,s2[&amp;#39;二&amp;#39;]) # 多索引 print(&amp;#39;s2中二、四对应的值&amp;#39;,s2[[&amp;#39;二&amp;#39;,&amp;#39; …  ]]></content></entry><entry><title>12.Python科学计算和数据分析的常用扩展库：Numpy</title><url>/post/42/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、Numpy介绍 Numpy (Numerical Python) 是python中的一个基础工具包，用以进行科学计算及数据分析， Numpy中单一数据类型的多维数组以ndarray的形式存储，可进行快速矢量算术运算， Numpy还可用于磁盘数据的读写以及内存映射文件的操作，实现数据的快速读写与输出， Numpy也是数据分析必不可少的工具，可以进行数据清洗、数据转换等矢量化数组运算。 2、Numpy安装 # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install numpy 3、创建ndarray数组 ndarray：数组中的所有对象必须是相同类型的，创建ndarray数组可以使用array函数传入python序列对象实现
3.1、一维数组
import numpy as np # 创建一维数组 a = [1, 2, 3, 4, 5] arr1 = np.array(a) print(&amp;#34;创建一维数组：\n&amp;#34;, arr1) 3.2、多维数组
# 创建多维数组 b = [[1, 2, 3], [4, 5, 6]] arr2 = np.array(b) print(&amp;#34;创建多维数组：\n&amp;#34;, arr2) 3.3、shape函数
shape函数是查看每个数组各维度的大小，返回值是一个元组对象，数组是一维数组，返回值是(n,)，
n表示数组的长度，数组是二维数组，返回值是(n1,n2) ，n1表示行数，n2表示列数，
对于三维数组就是包含多少个二维数组，后两个数字表示二维数组的行与列 返回值是(n1,n2,n3)， n1表示几个二维数组，n2表示二维数组的行，n3表示二维数组列
# shape print(&amp;#34;arr1 shape: &amp;#34;, arr1.shape) print(&amp;#34;arr2 shape: &amp;#34;, arr2.shape) 3.4、reshape函数
reshape函数可以更改数组的结构，原数组的shape仍然保持不变，原数组与新数组是共享同一数据储存内存区域，
所以对其中一个数组元素修改，都会同时引起另一个数组内容的改变
# reshape arr2_reshape = arr2.reshape(3,2) …  ]]></content></entry><entry><title>gitlab的fork派生使用</title><url>/post/78/</url><categories><category>工具</category></categories><tags><tag>gitlab</tag><tag>fork使用</tag></tags><content type="html"> 1、从原库Fork（派生）到自己的仓库
2、将Fork（派生）库Clone到到本地
git clone Fork(派生)库的地址 3、添加对原库的远程仓库，使Clone的本地库与远程库相关联
查看当前远程仓库： git remote -v 然后会显示，Fork的两个链接
添加原库的远程仓库： git remote add 原库的别名 原库的地址 再查看一下当前远程仓库,就会多了两个远程仓库
4、本地库获取原库的更新
下面介绍fetch+merge的方法： （1）步骤一
# 获取 `原库的别名` 下的 `原库的分支名` 的更新内容。 git fetch 原库的别名 原库的分支名 （2）步骤二
# 将更新的 `原库的别名` 下的 `原库的分支名` 合并到当前的本地的分支上 git merge 原库的别名/原库的分支名 5、将更新后的本地库通过add，commit，push，一条龙服务上传到自己的Fork（派生）库，实现对Fork（派生）库的更新
6、将本地库的更新到Fork库后，合并到原库，实现提交自己的代码到原库</content></entry><entry><title>frp实现内网穿透详细配置</title><url>/post/8/</url><categories><category>工具</category></categories><tags><tag>frp</tag><tag>内网穿透</tag></tags><content type="html"> 1、条件 需要一个有公网IP的云服务器（我的是腾讯云）
2、frp下载及介绍 (1) frp下载：https://github.com/fatedier/frp/releases 下载最新版，根据自己的服务器下载对应版本（我的是linux64系统）
wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gz (2) 解压压缩包
tar -zxvf frp_0.34.3_linux_amd64.tar.gz mv frp_0.34.3_linux_amd64 frpServer 包结构介绍：
服务器端：
frps： 服务器端服务启动文件 frps_full.ini： 启动配置文件（全版） frps.ini ：启动配置文件（简版） 客户端（Linux版）：
frpc ：客户端服务启动文件 frpc_full.ini ：启动配置文件（全版） frpc.ini ：启动配置文件（简版） 3、进入解压文件夹 cd frpServer 4、服务端配置及运行 4.1 修改端口，frps.ini文件
[common] bind_port = 9999 # bind_port是服务器的端口，我们最好不要使用默认端口 4.2 运行服务
直接运行： # frp解压文件夹目录下运行，也可以使用全路径 # 相对路径 ./frps -c frps.ini # 绝对路径 /opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini 后台运行： nohup ./frpc -c ./frpc.ini &amp;amp;amp; 4.3 配置系统启动时自动启动
在/lib/systemd/system文件夹下创建frps.service文件
编辑frps.service文件，输入以下内容(注：ExecStart 使用绝对路径 )：
[Unit] Description=frp service After=network.target [Service] TimeoutStartSec=30 ExecStart=/opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini …</content></entry><entry><title>解决自己的云服务器经常被登录问题</title><url>/post/6/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag></tags><content type="html"> 1、解决过程 1.1 环境：
腾讯centos云服务器
1.2 原因：
每次登录云服务器时系统都会提示，这是被各种尝试登录导致的（简单说就是你的服务器被攻击了）
Last failed login: Tue Dec 29 21:06:17 CST 2020 from 182.78.163.21 on ssh:notty There were 6751 failed login attempts since the last successful login. Last login: Sat Dec 26 01:17:59 2020 from 120.230.83.193 1.3 解决办法：
使用密钥登录可以解决
1.4 步骤如下：
（1）生成ssh密钥：
[root@hangzhi ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #此处直接回车就可以 Enter passphrase (empty for no passphrase): #设置解密钥密码 Enter same passphrase again: #再此输入一样密码确认 Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:9vRVtZ9uUUinLq+0byUMYDo8XZpZQ/t2iDbrGjcjMNc root@hangzhi The key&amp;#39;s randomart image is: +---[RSA 2048]----+ | .. . o| | o +o +o| | . + B..o.o| | = =..+ o+| | Soo Eo*oo| | . * o B+.o| | + B .= | | * =o | | ..+o. | +----[SHA256]-----+ （2）查看生成的密钥：
[root@hangzhi ~]# cd /root/.ssh/ [root@hangzhi .ssh]# ll total 12 -rw-r--r--. 1 root root 0 Mar 7 2018 authorized_keys -rw------- 1 root root 1766 Dec 29 21:13 id_rsa #私钥 -rw-r--r-- 1 root root 394 Dec 29 21:13 id_rsa.pub #公钥 -rw-r--r-- 1 root root 176 Jan 6 2019 known_hosts （3）将公钥追加到authorized_keys文件中：
[root@hangzhi .ssh]# cat id_rsa.pub &amp;gt;&amp;gt; /root/.ssh/authorized_keys （4）将权限改为只有当前用户可读可写，保证安全：
[root@hangzhi .ssh]# chmod 600 authorized_keys （5）打开ssh的密钥登录功能：
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys #将上面2行前面的注释去掉，然后保存 # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service （6）然后使用客户端配置密钥登录，如果成功接着下一步，不成功重复上面步骤
（7）关闭ssh密码登录（注意：只有配置成功后才操作这个步，不然没成功关闭这个会导致不能登录服务器 ）
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config PasswordAuthentication yes 修改为: PasswordAuthentication no # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service</content></entry><entry><title>11.Python爬虫必学的网络编程知识</title><url>/post/41/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、基础知识 HTTP：（HyperText Transport Protocol）是超文本传输协议缩写
URL：（Uniform Resource Locator）是统一资源定位符的缩写
HTTP请求方式
对比项 GET POST 提交方式 提交的参数数据放在URL之后，使用?与URL进行分割，多个参数之间使用&amp;amp;分隔 提交的参数数据不放在URL中提交，模拟提交表单数据 提交数据长度 受限 无限制 安全性 安全性低，提交的数据与URL混合在一起提交，很容易被发现 安全性高 状态码：常见的状态码
200:表示请求成功，成功返回请求资源 404:表示请求的资源不存在 500:服务器错误 2、urllib库 urllib库内置模块：
模块 说明 urllib.request HTTP请求模块，在程序中模拟浏览器发送HTTP请求 urllib.error 异常模块，捕获由于HTTP请求问题产生的异常，并进行处理 urllib.parse URL解析模块，提供了处理URL的工具函数 urllib.robotparser robots.txt解析模块，网站通过robots.txt文件设置爬虫可爬取的网页 2.1、urllib.request.urlopen函数
常用参数：
url：目标URL访问地址
data：默认是None，表示GET方式发送请求，data有值，表示POST方式发送请求
timeout：访问超时时间
GET请求
import urllib.request #data没值是GET res = urllib.request.urlopen(&amp;#34;http://www.baidu.com&amp;#34;) print(res.read().decode(&amp;#34;utf8&amp;#34;)) POST请求 import urllib.request # 请求数据 param_dict = {&amp;#34;key&amp;#34;:&amp;#34;hello world&amp;#34;} # 调用urlencode函数将字典类型数据转成字符串 param_str = urllib.parse.urlencode(param_dict) #将传输数据封装成一个bytes对象 param_datas=bytes(param_str,encoding=&amp;#34;utf8&amp;#34;) #data有值 …  ]]></content></entry><entry><title>VirtualBox虚拟机导出及磁盘扩展</title><url>/post/4/</url><categories><category>Linux</category><category>虚拟机</category></categories><tags><tag>VirtualBox虚拟机</tag><tag>磁盘扩展</tag></tags><content type="html"> VirtualBox虚拟机导出 VirtualBox虚拟机的迁移除了复制还有一种通用方式是导出
复制的方式可以看之前写的：VirtualBox虚拟机迁移/复制（带快照）
简单方便的导出方式(推荐)，因为适用其他虚拟机,如:VMWare
VirtualBox虚拟机磁盘扩展 1.创建磁盘和添加磁盘
对于创建时使用哪种磁盘文件，如下图介绍（我自己使用的VMDK ：
2.查看能不能识别磁盘
3.对磁盘分区
fdisk /dev/sdb 选N进行分区 两个选项，e为分逻辑分区，p为主分区，（我选择的是p） 选1，说明是创建第一个分区，起始位置默认直接回车 下一个是让你选择究竟要分多大空间给这个分区，直接回车就默认全部分给他，单位按MB来算 选W 保存退出 4.查看分好区的磁盘
fdisk -l 查看 能看到/dev/sdb1了就ok 5.对分区好磁盘格式化
mkfs.ext4 /dev/sdb1 对这个分区进行格式化 格式化成ext4格式，如果你想其他格式就自己改 6.创建磁盘挂载的文件夹
mkdir /mnt/sdb1 （这个是要将硬盘挂载的地方，位置随意） 7.将挂载文件夹与磁盘关联
mount /dev/sdb1 /mnt/sdb1 （挂载这个硬盘到这个位置上） df -h就能看到硬盘了 8.设置开机自动挂载磁盘
vi /etc/fstab 让系统可以开机后自动将硬盘挂载上去 最后一行添加：/dev/sdb1 /mnt/sdb1 ext4 defaults 0 0 然后保存退出</content></entry><entry><title>docker搭建maven私服--nexus</title><url>/post/68/</url><categories><category>Docker</category></categories><tags><tag>nexus</tag></tags><content type="html"><![CDATA[  1、准备 一台可以上网的服务器（或者虚拟机、个人电脑等）并安装有docker
2、查找镜像 docker search nexus 3、选取第一个镜像拉取 docker pull sonatype/nexus3 4、查看拉取的镜像 docker images 5、启动nexus镜像 docker run -p 5000:5000 -p 8081:8081 --name nexus \ --restart=always \ -v /opt/nexus-data:/nexus-data \ -d --hostname nexus sonatype/nexus3 默认密码： admin/admin123
参数解释：
5000：是用于镜像仓库的服务端口 8081：是nexus的访问端口 -v：将nexus镜像的数据挂载到主机的目录下 6、查看容器日志 docker logs nexus 7、Nexus 3.x 镜像权限问题 问题：
[root@localhost opt]# docker logs nexus mkdir: cannot create directory &#39;../sonatype-work/nexus3/log&#39;: Permission denied mkdir: cannot create directory &#39;../sonatype-work/nexus3/tmp&#39;: Permission denied Java HotSpot(TM) 64-Bit Server VM warning: Cannot open file ../sonatype-work/nexus3/log/jvm.log due to No such file or directory Warning: Cannot open log file: ../sonatype-work/nexus3/log/jvm.log Warning: Forcing option -XX:LogFile=/tmp/jvm.log Unable to update instance pid: Unable to create directory /nexus-data/instances /nexus-data/log/karaf.log (No such file or directory) Unable to update instance pid: Unable to create directory /nexus-data/instances 解决方法：
#将目录权限归属设定为 200 chown -R 200 /opt/nexus-data/ 最新的Nexus 3.x还支持Docker仓库
  ]]></content></entry><entry><title>VirtualBox虚拟机迁移/复制（带快照）</title><url>/post/3/</url><categories><category>Linux</category><category>虚拟机</category></categories><tags><tag>VirtualBox虚拟机</tag></tags><content type="html"> 本次虚拟机迁移是基于VirtualBox虚拟机，如果要尝试安装和创建虚拟机可以去搜索：virtualbox的安装与使用、安装镜像创建虚拟机
1、VirtualBox的结构介绍 xxx.vdi : 这个文件是磁盘映像，创建虚拟机的时候创建的
xxx.vbox 和 xxx.vbox-prev：这个两文件虚拟机的配置文件，记录了所以配置信息，如快照，虚拟磁盘等，核心文件是.vbox文件
xxx.vmdk : 这个文件是虚拟机磁盘，是用来扩展机器存储空间，创建虚拟机一般是没有次文件的
{UUID}.vdi ：磁盘映像文件的快照
{UUID}.vmdk : 虚拟机磁盘文件的快照
注：迁移有风险，迁移时要多细心
2、不带快照 2.1 迁移到不同机器
（1）迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到不同机器，由于是在不同的机器上进行迁移，是不涉及到镜像文件的UUID相同情况，因此比较简单，只需要打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
（2）在新机器上的VirtualBox软件中注册刚修改的文件，有.vmdk 文件也需要注册，否则不注册。如下图：
新机的迁移就这么简单完成了。
2.2 迁移到本机机器不同目录
（1）迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到本机机器不同目录，由于是在本机机器上进行迁移，涉及到镜像文件的UUID相同情况，因此需要分两步走：一是修改文件路径，二是修改文件UUID
修改文件路径：打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
修改文件UUID：将.vdi、.vmdk(没有这个文件，可以忽略)文件重新生成UUID
VirtualBox软件安装目录下执行如下命令重新生成UUID
// 重新生成centos7(two).vdi的UUID VBoxManage internalcommands sethduuid &amp;amp;#34;F:\VirtualBox\centos7(two)\centos7(two).vdi&amp;amp;#34; // 重新生成sda7.vmdk的UUID VBoxManage internalcommands sethduuid …</content></entry><entry><title>10.Python的一大利器：正则表达式</title><url>/post/40/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、re模块 re模块中封装了很多正则表达式相关的函数，非常方便的使用正则表达式对字符串进行各种规则匹配检查，常用一个函数是match函数
match(patten,string)函数： 用于对字符串进行正则匹配，patten表示正则表达式，string表示待匹配字符串，匹配成功返回Match对象，否则返回None
# match 函数 （从左开始匹配，没匹配成功，不会向后面匹配，匹配失败） import re str1 = &amp;#34;hello python&amp;#34; str2 = &amp;#34;python hello python&amp;#34; rs1 = re.match(&amp;#34;python&amp;#34;,str1) rs2 = re.match(&amp;#34;python&amp;#34;,str2) print(rs1) # None print(rs2) # &amp;lt;re.Match object; span=(0, 6), match=&amp;#39;python&amp;#39;&amp;gt; #取值 print(rs2.group()) #python 2、单字符匹配 常用单字符匹配符号：
符号 说明 . 匹配除\n之外的任意字符 \d 匹配0到9之间的一个数字，等价于[0~9] \D 匹配一个非数字字符，等价于[^0~9] \s 匹配任意空白字符，如：空格、制表符\t、换行\n等 \S 匹配任意非空白字符 \w 匹配单词字符，包括字母、数字、下划线 \W 匹配非单词字符 [] 匹配[]中列举的字符 # 单字符匹配 import re rs = re.match(&amp;#39;.&amp;#39;,&amp;#39;1&amp;#39;) # 匹配一个包含数字的字符串 print(rs.group()) rs = re.match(&amp;#39;.&amp;#39;,&amp;#39;a&amp;#39;) # 匹配一个包含单字符的字符串 print(rs.group()) rs = re.match(&amp;#39;.&amp;#39;,&amp;#39;abc&amp;#39;) # 匹配一个包含多字符的字符串 print(rs.group()) # 多字符匹配 rs = re.match(&amp;#39;...&amp;#39;,&amp;#39;abc&amp;#39;) # 匹配一个包含多字符的字符串 print(rs.group()) #匹配任意空白字符 rs = …  ]]></content></entry><entry><title>9.Python必学的文件处理知识</title><url>/post/39/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、读写文件 1.1、打开文件
open函数打开文件，返回文件对象。open 函数打开文件三种常用模式：
只读模式，使用r表示，用于读取文件内容，不能向文件中写入数据 只写模式，使用w表示，用于将数据覆盖写入文件中 追加模式，使用a表示，用于将数据追加写入文件的末尾 注：打开一个不存在的文件时，只读模式会报不存在文件异常，只写和追加模式都会创建一个写文件
# 打开不存在的文件 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;r&amp;#39;) # 报错：FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;test.txt&amp;#39; f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) #创建文件 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;a&amp;#39;) #创建文件 1.2、写文件
write()方法： 写入文件的内容不会自动换行，且调用一次只能将一个字符串写入文件
# 写入数据到文件 # 第一次 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) f.write(&amp;#39;hello&amp;#39;) f.write(&amp;#39;world&amp;#39;) f.write(&amp;#39;!&amp;#39;) # 第二次（覆盖第一次写入数据） f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) f.write(&amp;#39;你&amp;#39;) f.write(&amp;#39;好&amp;#39;) # 使用追加 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;a&amp;#39;) f.write(&amp;#39;你&amp;#39;) f.write(&amp;#39;好&amp;#39;) # 写入换行,使用换行符 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) f.write(&amp;#39;hello\n&amp;#39;) f.write(&amp;#39;world\n&amp;#39;) f.write(&amp;#39;!\n&amp;#39;) writelines()方法： 可以将一个序列中的多个字符串一次写入文件中
# 使用writelines()函数,调一次写入 f = …  ]]></content></entry><entry><title>8.Python常用的时间和日期模块</title><url>/post/38/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"> 1、time模块 1.1、time函数
调用time函数，返回当前的时间戳，返回的时间戳是以秒为单位的浮点数
import time print(time.time()) #获取当前时间戳 1.2、localtime函数
可传入一个可选参数，以秒为单位的时间戳
传入参数，将时间戳格式化为本地时间，返回一个struct_time元组
不传入参数，将当前时间戳格式化为本地时间，返回一个struct_time元组
struct_time属性描述：
属性 含义 值 tm_year 年份 4位数字表示： 2020 tm_mon 月份 1-12数字表示：12 tm_mday 日期 1-31数字表示：5 tm_hour 小时 0-23数字表示：12 tm_min 分钟 0-59数字表示：30 tm_sec 秒 0-60数字表示：30 tm_wday 一周的第几天 0-6数字表示，0表示周一：5 tm_yday 一年的第几天 1-366数字表示：300 tm_isdst 是否是夏令时 默认值为-1，0表示不是，1表示是 import time date_time1 = time.localtime() print(date_time1) ts=time.time() date_time2=time.localtime(ts) print(date_time2) 1.3、strftime函数
strftime(fmt[,struct_time])函数是可以按照自定义的格式化参数将时间格式化，fmt是函数入参的自定义格式化参数，struct_time可选，不传表示当前时间格式化
时间格式化符号： 格式化符号 含义 %y 两位数的年份表示 %Y 四位数的年份表示 %m 月份 %d 日期 %H 24小时制小时数 %I 12小时制小时数 %M 分钟数 %S 秒 %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 一年内的第几天 %p 显示本地时间的AM或PM %U 一年中的第几周 %w 星期（0-6）0表示星期日 %W 一年中的星期数：星期一是一个星期的开始 %x 本地日期表示 20/12/5 %X 本地时间表示：10:10:10 %Z 当前时区的名称 import time # …</content></entry><entry><title>7.Python如何处理异常</title><url>/post/37/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、异常捕获 1.1、语法格式
# 单个异常 try: 可能产生异常的代码 except 异常类型名称 as 对异常类型名称重新命名: 异常处理 # 多个异常 try: 可能产生异常的代码 except (异常类型名称1,异常类型名称2,...) as 对异常类型名称重新命名: 异常处理 1.2、捕获单个异常
# 处理打开一个文件产生的有可能产生异常 try: open(&amp;#39;test.txt&amp;#39;) print(&amp;#39;打开文件成功！&amp;#39;) except FileNotFoundError as error: print(&amp;#39;捕获到异常&amp;#39;,error) print(&amp;#39;结束&amp;#39;) 1.3、捕获多个异常
# 处理打开一个文件产生的有可能产生异常和打印一个不存在变量异常 try: # 打开文件 open(&amp;#39;test.txt&amp;#39;) #打印不存在变量 print(file) except (FileNotFoundError,NameError) as error: print(&amp;#39;捕获到异常&amp;#39;,error) print(&amp;#39;结束&amp;#39;) 1.4、捕获全部异常
# 处理打开一个文件产生的有可能产生异常和打印一个不存在变量异常 try: # 打开文件 open(&amp;#39;test.txt&amp;#39;) #打印不存在变量 print(file) except NameError as error: # 只捕获了NameError异常，没捕获FileNotFoundError异常 print(&amp;#39;捕获到部分异常&amp;#39;,error) except Exception as e: print(&amp;#39;捕获到全部异常&amp;#39;,e) print(&amp;#39;结束&amp;#39;) 2、finally语句 如果某段代码必须要执行，不管是否有异常产生都要执行，那就需要使用finally语句了
#有异常 try: # 打开文件 f = open(&amp;#39;test.txt&amp;#39;) print(&amp;#39;打开文件成功！&amp;#39;) except FileNotFoundError as error: print(&amp;#39;捕获到异常&amp;#39;,error) finally: print(&amp;#39;关闭打开文 …  ]]></content></entry><entry><title>6.Python面向对象编程</title><url>/post/36/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、面向对象编程 面向对象编程（Object Oriented Programming，简称：OOP ）是一种解决软件复用的设计和编程方法，就是根据现实社会中的事物，抽象出事物的属性和功能，
后然将抽象出来的属性和功能封装成对象的属性和方法，在软件中通过复用对象实例提高软件的开发效率 ，很多高级编程语言都遵循面向对象的编程方法。
2、类和对象 2.1、类：是一类事物的抽象，定义了一类事物的属性和行为
类的构成：类名、属性、方法 定义： class 类名: def 方法名(self[,参数列表]): 方法体 ...... 注意事项： 1.定义类时，使用class关键字声明这是一个类
2.类名的命名规则：通常按照约定的“大驼峰”命名法。例：class ElectricCar 电动车类
3.定义方法时，方法的第一个参数默认为self，表示对象自身
4.通过对象调用方法时，不需要在方法中传入self参数，python解释器会自动传入
class Cat: def eat(self): print(&amp;#34;吃鱼。。。&amp;#34;) def drink(self): print(&amp;#34;喝水。。。&amp;#34;) def run(self): print(&amp;#34;跳舞。。。&amp;#34;) 2.2、对象：是通过类创建的一个具体事物，具有状态和行为，可以做具体事情。
创建对象的过程：是在内存中开辟一块区域存储这个对象，这块内存区域有它的对应内存地址，通过内存地址就能找到这块区域存储的这个对象。
对象的引用：就是把存储这个对象的内存地址告诉了变量，这个变量就指向了内存中的这个对象，通过这个变量就可以找到它所指的这个对象，所以这个变量叫这个对象的引用。
# 根据Cat类创建对象 xiaohe=Cat() #调用对象的方法 xiaohe.eat() xiaohe.drink() xiaohe.run() #对比一个类创建多对象是否相同 xiaobai=Cat() #id(对象)可以获取对象的内存地址 print(&amp;#34;xiaohe的id：{}&amp;#34;.format(id(xiaohe))) print(&amp;#34;xiaobai的id：{}&amp;#34;.format(id(xiaobai))) 2.3、类与对象的关系：类相当于创建对象的基础条件，根据类可以创建多个对象。 …  ]]></content></entry><entry><title>5.Python模块认识</title><url>/post/35/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、包 在Python中一个包内要创建__init__.py文件，来区分是包还是普通文件夹。一个项目中可以有多个包，每个包都可以含有子包或者多个模块，如图：
2、模块 在Python中一个以.py结尾的文件就是一个模块，不同包下可以用相同名称的模块，模块之间使用包名.模块名来区分。
引入模块的方法： 描述 引入方法 引入单个模块 Import 模块名称 引入多个模块 Import 模块名称1,模块名称1,&hellip; 引入模块中的指定函数或者类等 from 模块名称1 import func,&hellip;
from 模块名称1 import class,&hellip; 3、__init__.py 模块 使用Pycharm创建包时会自动创建一个__init__.py模块
__init__.py作用：模块内可以是空白用识别一个包，还可以在模块内定义关于包和模块相关的一些初始化操作
4、__name__ 变量 Python 内部定义了一个__name__变量（name前后分别是两个下划线），Python源码文件使用决定了__name__变量的取值
当Python源码文件直接运行时，__name__变量的值等于&quot;__main__&quot; 当Python源码文件作为模块在其他地方被引入时，__name__变量的值等于被引入模块名称 5、Python主入口解释 Python属于脚本语言，Python程序在执行时与其他语言不同，Python程序没有编译过程，不需要将程序编译成二进制再运行。
而是Python解释器根据Python代码文件从第一行开始由上到下逐行运行，整个程序没有统一的主入口
  ]]></content></entry><entry><title>4.Python函数使用</title><url>/post/34/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、函数定义和调用 1.1、定义函数的语法格式
def 函数名称(参数): 函数体代码 return 返回值 #定义函数 def user_info(): print(&amp;#34;姓名：张三&amp;#34;) print(&amp;#34;性别：男&amp;#34;) print(&amp;#34;年龄：18&amp;#34;) #函数调用 user_info() 2、函数参数 2.1、缺省参数：
函数定义时，设置带有默认值的参数，调用时，缺省参数可以不传入，没传使用默认值，传了实参就使用实参
def sum(y,x=10): rs=x+y print(&amp;#34;{}+{}={}&amp;#34;.format(x,y,rs)) # 只传入一个参数y的值 sum(10) # 传入缺省参数的实参20 sum(10,20) 2.2、命名参数：
指在调用带有参函数时，通过指定参数名称传入参数的值，并且可以不按照函数定义的参数顺序传入实参
def sum(y,x): rs=x+y print(&amp;#34;{}+{}={}&amp;#34;.format(x,y,rs)) # 不按照参数定义的顺序，通过指定参数名称传入，指定参数名称必须与定义的形参名称相同 sum(x=10,y=20) sum(y=20,x=10) 2.3、带参函数：
函数定义时，可以在小括号内设置函数需要的参数，调用时安装顺序和个数传入
def user_info(name,sex,age): print(&amp;#34;姓名：&amp;#34;,name) print(&amp;#34;性别：&amp;#34;,sex) print(&amp;#34;年龄：&amp;#34;,age) # 调用 name=&amp;#34;张三&amp;#34; sex=&amp;#34;男&amp;#34; age=18 user_info(name,sex,age) 2.4、不定长参数
带有一个*的不定长参数 # 计算多个数字和 def any_num_sum(*args): print(&amp;#34;args参数值：&amp;#34;,args) print(&amp;#34;args参数类型：&amp;#34;,type(args)) rs=0 if len(args)&amp;gt;0: for arg in args: rs += arg print(&amp;#34;总和：&amp;#34;，rs) # 调用 any_num_sum(10,20) …  ]]></content></entry><entry><title>启动和停止shell脚本</title><url>/post/2/</url><categories><category>Linux</category></categories><tags><tag>shell脚本</tag></tags><content type="html"><![CDATA[  start.sh 定义变量: 服务名/部署路径/服务输出日志路径/启动文件路径 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 没启动继续下面的 设置JVM参数: JAVA_OPTS 后台启动应用: nohup java -jar 命令 再次检查是否启动 shell脚本示例: #!/bin/bash #启动服务名称 SERVER_NAME=test #服务部署路径 DEPLOY_DIR=/opt/app/test # 服务日志输出路径 STDOUT_FILE=${DEPLOY_DIR}/logs/test.log #服务启动的jar或war WAR_FILE=${DEPLOY_DIR}/test.jar PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -n &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The ${SERVER_NAME} already started!&#34; echo &#34;&gt;&gt;&gt; PID: $PIDS&#34; exit 1 fi #jvm参数配置 JAVA_OPTS=&#34;-server -Xmx2g -Xms2g &#34; echo -e &#34;&gt;&gt;&gt; Starting the ${SERVER_NAME} ...\c&#34; nohup java $JAVA_OPTS -jar ${WAR_FILE} &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39; | wc -l` if [ $COUNT -gt 0 ]; then break fi done PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39;` echo &#34;OK ! --&gt;&gt;&gt; PID: $PIDS --&gt;&gt;&gt; STDOUT: $STDOUT_FILE &#34; stop.sh 定义变量: 部署服务路径/停止服务名称 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 启动继续下面的 kill掉进程 再次检查进程是否存在 shell脚本示例: #!/bin/bash #服务部署路径 DEPLOY_DIR=/opt/app/test #停止服务名称 SERVER_NAME=test PIDS=`ps -ef | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep java` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34;   ]]></content></entry><entry><title>3.Python容器使用入门</title><url>/post/33/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、列表 1.1、列表定义
列表用来顺序存储相同或者不同类型数据的集合，列表内存储的元素是有序的，列表使用一对[ ]表示，列表中存储的每个值叫元素，元素之间使用逗号隔开
# 存储相同数据类型 name_list=[&amp;#34;张三&amp;#34;,&amp;#34;李四&amp;#34;,&amp;#34;王五&amp;#34;] # 打印数据类型 print(type(name_list)) print(name_list) #存储不同数据类型 info=[&amp;#34;张三&amp;#34;,&amp;#34;男&amp;#34;,20] print(info) 1.2、向列表添加元素
info_list=[[&amp;#34;张三&amp;#34;,&amp;#34;男&amp;#34;,20],[&amp;#34;王五&amp;#34;,&amp;#34;男&amp;#34;,16]] # 1.append()方法 new_info=[&amp;#34;李四&amp;#34;,&amp;#34;男&amp;#34;,18] info_list.append(new_info) print(info_list) # 2.insert()方法 new_info=[&amp;#34;小美&amp;#34;,&amp;#34;女&amp;#34;,18] info_list.insert(1,new_info) print(info_list) # 3.extend()方法 new_infos=[[&amp;#34;马六&amp;#34;,&amp;#34;男&amp;#34;,18],[&amp;#34;小黑&amp;#34;,&amp;#34;女&amp;#34;,18]] info_list.extend(new_infos) print(info_list) # 4.使用+号拼接 str_list1=[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] str_list2=[&amp;#34;e&amp;#34;,&amp;#34;f&amp;#34;,&amp;#34;g&amp;#34;] str_list3=str_list1+str_list2 print(str_list3) 1.3、修改列表中元素值
# 索引修改元素值 info_list=[&amp;#34;小美&amp;#34;,&amp;#34;女&amp;#34;,20] #年龄涨一岁 info_list[2]+=1 print(info_list) 1.4、查询列表中元素
# 根据索引查询 info_list=[&amp;#34;小美&amp;#34;,&amp;#34;女&amp;#34;,20] …  ]]></content></entry><entry><title>2.Python语法基础知识</title><url>/post/32/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、注释 注释是我们自己语言来描述一段代码的实现逻辑，介绍这段代码具体实现的什么功能，方便我们维护和清晰地了解这段代码，增强程序的可读性
1.1、单行注释 ：用于注释一行文字或者代码，单行注释格式以 # 号开头
# 打印一行文字 print(&amp;#34;hello world&amp;#34;) # print(&amp;#34;hello world&amp;#34;) 1.2、多行注释 ：用于注释多行文字或者代码块，格式以三个英文单引号（&amp;rsquo;&amp;rsquo;&amp;rsquo;）开头，三个英文单引号（&amp;rsquo;&amp;rsquo;&amp;rsquo;）结束
&amp;#39;&amp;#39;&amp;#39; 使用多行注释 打印一行文字 &amp;#39;&amp;#39;&amp;#39; print(&amp;#34;hello world!&amp;#34;) 2、关键字与标识符 2.1、关键字
False、None、True、and、as、assert、break、class、 continue、def、del、elif、else、except、finally、for、 from、global、if、import、in、is、lambda、nonlocal、not、 or、pass、raise、return、try、while、with、yield 2.2、标识符
开发者自定义的一些符号和名称等称为标识符（如：变量名、函数名、类名等），标识符由字母、数字、下划线组成。
定义标识符的注意事项：
不能以数字开头 标识符区分大小写 不能使用Python内置关键字作为标识符名称 为了提高可读性，见名知其意 3、变量 变量就是一个装有不同类型数值的容器
3.1、变量定义
#定义姓名变量 name=&amp;#34;张三&amp;#34; #定义年龄变量 age=20 #定义性别变量 sex=&amp;#34;男&amp;#34; #打印信息 print(&amp;#34;姓名: &amp;#34;,name) print(&amp;#34;年龄: &amp;#34;,age) print(&amp;#34;性别: &amp;#34;,sex) 3.2、赋值
# 如果不是第一次出现，表示给这个变量重新赋值 #定义年龄变量 age=20 print(&amp;#34;年龄: &amp;#34;,age) #年龄增加2岁 age=age+2; print(&amp;#34;重新赋值后的年龄: &amp;#34;,age) 4、数据类型 python提供的标准数据类型：数据 …  ]]></content></entry><entry><title>1.Python开发基础工具</title><url>/post/31/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"> 1、Python3 安装包 Python3中文文档： https://docs.python.org/zh-cn/3/ Python官网下载： https://www.python.org/downloads Python3安装自行百度 2、Anaconda anaconda官网 ： https://www.anaconda.com/products/individual 简介： Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。
Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。
Anaconda具有如下特点： 开源 安装过程简单 高性能使用Python和R语言 免费的社区支持 3、PyCharm PyCharm下载： https://www.jetbrains.com/pycharm/download/ 简介： PyCharm是一种Python IDE（集成开发软件），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，
比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。
此外该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。</content></entry></search>