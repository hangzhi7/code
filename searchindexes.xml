<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>一篇文章带你入门Fastjson2：Java库的“闪电”解析</title><url>/post/59/</url><categories><category>Java库</category></categories><tags/><content type="html"><![CDATA[  介绍一个Java编程中非常实用的库——Fastjson2。
Fastjson2是一个由我国阿里巴巴团队开发的高效JSON解析库，它能够让你在处理JSON数据时，体验到飞一般的感觉。
1、Fastjson2的背景 在互联网开发领域，JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。
由于其简洁易读的特点，JSON成为了网络数据传输的事实标准。
当时在Java中处理JSON数据并不总是那么容易。为此Fastjson应运而生，它旨在简化Java开发者处理JSON数据的复杂度，提高处理速度。
Fastjson2是Fastjson项目的重要升级，与Fastjson1相比，性能有非常大的提升。
性能远超过其他流行JSON库，包括jackson/gson/org.json，
性能数据: https://github.com/alibaba/fastjson2/wiki/fastjson_benchmark 2、Fastjson2的特点 速度快：Fastjson2的解析速度非常快，比其他库如Jackson和Gson要快得多。 易使用：Fastjson2的API简单易用，你几乎可以无脑使用它。 功能全：Fastjson2支持各种复杂类型的JSON处理，包括泛型、枚举等。 可扩展：Fastjson2允许你自定义序列化和反序列化规则。 支持JDK新特性 完善的JSONPath支持，支持SQL:2016的JSONPath语法 支持Android 8+，客户端和服务器一套API 支持JSON Schema 3、Fastjson2的使用 1.添加依赖,在你的项目中添加Fastjson2的依赖。如果你使用Maven，可以在pom.xml文件中添加以下代码：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.fastjson2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.44&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.JSON字符串转Java对象
public class Test1 { public static void main(String[] args) …  ]]></content></entry><entry><title>Java开发者必备：一款神器Dozer，让你轻松实现对象属性映射！</title><url>/post/30/</url><categories><category>Java库</category></categories><tags/><content type="html"><![CDATA[  介绍一款Java领域内广泛使用的数据映射库——Dozer。
通过本文你将了解到Dozer的基本概念、使用方法和应用场景，更有详细的示例代码助你快速上手！
1、Dozer简介 Dozer是一个用于Java对象的映射工具，它可以帮助我们轻松地将一个对象的属性映射到另一个对象的对应属性。
在Java开发过程中，我们经常需要处理对象之间的转换和映射，而手动编写这些转换逻辑既繁琐又容易出错。
Dozer为我们提供了一种自动化、高效的方式来解决这个问题。
2、Dozer的核心概念 1.映射器（Mapper）：Dozer通过映射器来实现对象之间的映射。我们可以自定义映射器，也可以使用Dozer提供的默认映射器。
2.类型映射（Type Mapping）：Dozer支持基本数据类型、包装类、自定义对象等多种类型的映射。
3.属性映射（Property Mapping）：Dozer可以根据对象属性的名称、getter方法或setter方法来自动匹配映射关系。
4.复杂映射（Complex Mapping）：Dozer还支持嵌套映射、集合映射等复杂场景。
3、Dozer的使用方法 1.添加依赖，需要在项目的pom.xml文件中添加Dozer的依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;!-- Dozer依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.sf.dozer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dozer&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.创建映射器
创建一个Java类，并继承Dozer的Mapper接口。然后重写接口中的映射方法，实现自定义的映射逻辑。
import org.dozer.Mapper; import org.dozer Mapping; @Mapper public class MyMapper { @Mapping(source = &amp;#34;name&amp;#34;, target = &amp;#34;name&amp;#34;) public MyObject map(MyObject source) { …  ]]></content></entry><entry><title>ASM：深入Java字节码的世界，小白也能轻松掌握</title><url>/post/29/</url><categories><category>Java库</category></categories><tags><tag>字节码</tag></tags><content type="html"><![CDATA[  你是否曾在Java开发中遇到需要对字节码进行操作的需求？
是否为了实现某个功能而不得不深入研究Java字节码的奥秘？
如果是的话，那么你可能会感兴趣我要介绍的Java库——ASM。
ASM是一个强大的Java字节码操作库，它可以帮助我们轻松地读取、修改和生成Java字节码。
无论你是小白还是有一定基础的开发者，ASM都能为你带来极大的便利。
一篇关于ASM的入门介绍，让你轻松掌握这个强大的Java库。
1、ASM简介 ASM是一个用Java编写的库，主要用于分析和操作Java字节码。
通过ASM我们可以读取Java字节码文件，了解其结构，修改字节码以满足我们的需求，甚至可以生成全新的字节码文件。
ASM提供了丰富的API，使我们能够以编程的方式操作字节码，极大地提高了我们的工作效率。
2、ASM的核心组件 ClassReader：用于读取Java字节码文件，并获取其对应的Class对象。 ClassWriter：用于生成Java字节码文件，我们可以通过ClassWriter将修改后的字节码写入到新的文件中。 MethodVisitor：用于访问Java方法，包括方法的参数、返回值、异常等信息。 FieldVisitor：用于访问Java字段，包括字段的类型、修饰符等信息。 AnnotationVisitor：用于访问Java注解。 ConstructorVisitor：用于访问Java构造器。 3、ASM的使用示例 我将通过一个简单的示例，展示如何使用ASM来读取和修改Java字节码。
1.我们需要添加ASM的依赖。如果你使用Maven，可以在pom.xml文件中添加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.ow2.asm&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;asm&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;9.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.创建一个简单的Java类，例如：
public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;#34;Hello, World!&amp;#34;); } } 3.编 …  ]]></content></entry><entry><title>1.Python开发基础工具</title><url>/post/31/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"> 1、Python3 安装包 Python3中文文档： https://docs.python.org/zh-cn/3/ Python官网下载： https://www.python.org/downloads Python3安装自行百度 2、Anaconda anaconda官网 ： https://www.anaconda.com/products/individual 简介： Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。
Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。
Anaconda具有如下特点： 开源 安装过程简单 高性能使用Python和R语言 免费的社区支持 3、PyCharm PyCharm下载： https://www.jetbrains.com/pycharm/download/ 简介： PyCharm是一种Python IDE（集成开发软件），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，
比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。
此外该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。</content></entry><entry><title>一窥Dozer的Java库：让Java对象映射更轻松</title><url>/post/28/</url><categories><category>Java库</category></categories><tags/><content type="html"><![CDATA[  尽管各种新兴技术层出不穷，Java仍然稳居开发语言的前沿。
然而Java的对象映射问题一直让许多新手程序员头疼。
我要介绍的是拯救诸位于此困扰的利器——Dozer。
1、Dozer是什么？ Dozer是一个强大、简单易用的Java Bean到Java Bean映射工具，它使用Java反射API进行动态映射。
不论是同名属性映射，深层对象映射，或者是复制不同类型的对象都处理得游刃有余。
2、Dozer的优势 1、在源目标与目标类名称和字段名称相同时，能自动将值从一方映射到另一方。
2、对于字段类型不同的映射，它也能妥善应对。
3、提供了丰富的API，还支持自定义转换器，让你的映射更加自如。
3、使用Dozer 保持简洁的原则，我们用一段代码示例来看看如何使用Dozer。
1、需要在工程中引入Dozer。
&lt;dependency&gt; &lt;groupId&gt;com.github.dozermapper&lt;/groupId&gt; &lt;artifactId&gt;dozer-core&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; 2、创建两个Java Bean对象，Person和Employee。
public class Person { private String name; private int age; //...getter和setter } public class Employee { private String name; private int age; //...getter和setter } 3、实操使用：实现Person对象到Employee对象的映射了。
// 创建DozerBeanMapper对象 Mapper mapper = DozerBeanMapperBuilder.buildDefault(); Person p = new Person(); p.setName(&#34;小白&#34;); p.setAge(25); Employee e = mapper.map(p, Employee.class); System.out.println(e.getName()); System.out.println(e.getAge()); //以上代码能够成功地输出“小白”和“25”，证明映射工作已经成功地完成了。 ▽ 通过Dozer我们能够更快、更轻松地完成Java对象的映射。
不论是编程新手，还是在Java道路上已经走过一段距离的朋友，都可以使用一下这个强大的工具更快、更轻松地完成编程任务，可少加班早点下班。
良好的工具能够提升编程效率，让你有更多时间去处理更重要的事情。
希望Dozer能够为你的Java之路提供便利，让你的编程任务都能够如你所愿，甚至超出你的预期，让你的人生与代码都无往不利！
开源地址： https://github.com/DozerMapper/dozer   ]]></content></entry><entry><title>Guava：一款强大的Java库，让你的开发更高效</title><url>/post/27/</url><categories><category>Java库</category></categories><tags/><content type="html"><![CDATA[  Guava是一款由Google开源的Java库，提供了丰富的工具类和扩展类，帮助我们解决日常开发中遇到的各种问题。
本文将详细介绍Guava库的特点、常用工具类及其使用方法，让小白读者轻松上手。
1、Guava简介 Guava是一款由Google开源的Java库，旨在为Java开发者提供一系列便捷的工具类和扩展类，以提高开发效率。
Guava包含了很多实用的工具类，如集合类（multisets、multimaps、tables等）、数式编程风格（通过supplier、function、predicate、optional等实现）、缓存（CacheLoader和CacheBuilder等）、支持原生的Java类型、事件总线以及并发库扩展等，可以帮助我们轻松应对日常开发中的各种挑战。
2、Guava的安装与使用 1.添加依赖 要使用Guava库，需要在项目中添加其依赖。如果你使用Maven进行项目管理，可以在pom.xml文件中添加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;31.0.1-jre&amp;lt;/version&amp;gt; &amp;lt;!-- 请根据实际版本进行替换 --&amp;gt; &amp;lt;/dependency&amp;gt; 如果你使用Gradle，可以在build.gradle文件中添加以下依赖：
dependencies { implementation &amp;#39;com.google.guava:guava:31.0.1-jre&amp;#39; // 请根据实际版本进行替换 } 2.使用Guava工具类 Guava提供了很多实用的工具类，下面将介绍几个常用的工具类及其使用方法。
(1).增强java集合功能
Guava库向我们提供了一些更加丰富的集合类，比如诸如ImmutableSet、ImmutableList、ImmutableSortedSet、ImmutableMap以及更为泛化和强大的Multiset（可以存储相同元素的集合）、BiMap（可以将两个键映射到一个值）、Table（可以将一个键映射到另一个键的值）等。
(2).字符串处理
Guava库提供 …  ]]></content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 编程之路 一枚不起眼有着梦想爱读书的程序猿，记录自己的编程小技巧分享。
编程之路，探索智慧的无尽旅程。
在这条路上，小猿编程秘籍解锁创新，磨砺思维，不断超越。
编程，开启你的未来可能。
其他渠道： Github 掘金 知乎 CSDN 公众号：小猿编程秘籍 风情园 风情园致力于一个汇聚、分享知识的风情园。
知识如同一座宝库，不断挖掘，方能收获智慧之光。
风情园各园：编程、读书、AI、生活、财富、杂货</content></entry><entry><title>计算机网络：面试真题实战</title><url>/post/25/</url><categories><category>计算机网络</category></categories><tags/><content type="html"> 1、面试真题问答 以下问题都是基于之前写的计算机网络系文章做出简单问答
问1：TCP/IP协议群做了哪些事情？
1、报文拆分 2、增加协议头 3、数据传输 4、路由和寻址 5、数据重组 问2：TCP协议为什么是3次握手4次挥手？
3次握手 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 4次分手 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 问3：IPv4和Ipv6的区别？
地址不同：Ipv4 32位；Ipv6 128位 （地址空间、数目不同）。 地址分配不同：IPv4资源是稀缺的，分配需要竞争；IPv6可以给每个人分配很多地址。 寻址方式不同：IPv4通过子网掩码计算网络地址；IPv6有固定的计算方式划分网络。 地址解析策略不同：IPv4需要ARP；IPv6通过无状态的邻居发现。 DNS不同：IPv4是A记录；IPv6是AAAA记录。 问4：TCP和UDP的区别？
传输：TCP面向流；UDP面向报文 连接：TCP有会话；UDP无会话 头部开销：TCP开销大；UDP开销小 可靠性：TCP保证数据可靠到达；UDP不保证数据可靠到达 场景：TCP适合保证数据完整到达场景，如：文件传输；UDP适合随时发送数据，不要求数据完整到达场景，如：广播通信 问5：TCP如何确保数据顺序？ 为什么需要保证：TCP拆分封包的时候是顺序拆分的，但是包会无序的到达目的地。 方法1：利用(SEQ, ACK)编号确定封包的唯一性 方法2：利用滑动窗口存放没有排好序的封包，直到窗口中完全有序才发送ACK。如果有包丢失，就会一直不发ACK。 如果窗口大小是4，发送ABCD，如果只有BD到目的地，那么滑动窗口中是_B_D。
问6：如果网络延迟是30ms，那么Ping一个网站需要多少ms? 如果请求一个HTTPS协议的网站，TTFB至少ms? 问7：LRU是什么？ 缓存置换：缓存满了后，每次创建新的缓存条目，就会删除旧的缓存条目。 问8：什么是https中间人攻击? 问9：NIO有什么优势？
Reactive模型+非阻塞(减少线程切换） 内核级别拷贝内存到JVM（减少系统调用） …</content></entry><entry><title>计算机网络：同源策略</title><url>/post/24/</url><categories><category>计算机网络</category></categories><tags/><content type="html"><![CDATA[  1、介绍 同源策略：禁止一个源(origin)的脚本和文档和另一个源的脚本和文档交互。 什么是同源：两个URL的协议(protocol)、端口(port)和域名(domain)都相同，这就是同源。 同源策略的目的：防止恶意的网站窃取用户的cookie，或者其他敏感信息。 同源策略的实现：浏览器会在同源的情况下，允许脚本和文档进行交互。 同源策略的限制：不能读取对方的cookie、localStorage、sessionStorage、indexedDB、webSocket、EventSource、XMLHttpRequest、location、history 等等。 2、问题回答 问1：如果两个源产生过多交互会有什么影响？ 影响很大的就是恶意的网站窃取用户的cookie，或者其他敏感信息。这样数据就不安全了，所以同源策略是非常重要的。
问2：应不应该允许网站提交cookie到不同源的服务器？ 这个是不允许的，但是你自己配置了跨域是可以的。
问3：为什么不禁用不同源的js？ 因为有些js是第三方提供的，我们引用cdn的js，引用组件。
问4：应不应该允许不同源的js修改dom？ 这个是允许的，比如百度统计，百度地图等，如果不允许不同源的js修改dom，那么就无法统计用户的地理位置，无法使用百度地图等功能。
问5：应不应该允许不同源的js获取远程图片内容？ 这个是不允许的，如果能远程执行代码，那么就有可能获取到敏感信息和人家私密数据，这个肯定不行的。
问6：应不应该允许网站提交数据到不同源的服务器？ 这个是不允许的，如果能提交数据，那么就会被别人收集你的数据，然后提交到自己的服务器上，这等于抢劫，不劳而获，这个也肯定不行的。
3、跨域请求技术 Jsonp技术
Jsonp的原理：就是利用script标签的src属性没有跨域限制来实现的。
Jsonp的优缺点：
缺点：只能get请求 优点：浏览器的兼容性好 Jsonp的实现及应用：
模拟服务端： server.js ，启动方式: node server.js （需要安装node.js）
//模拟服务端 let http = require(&amp;#34;http&amp;#34;) let url = require(&amp;#34;url&amp;#34;) //模拟数据 let data; http.createServer((req, res) …  ]]></content></entry><entry><title>计算机网络：加密和解密</title><url>/post/23/</url><categories><category>计算机网络</category></categories><tags><tag>加密和解密</tag></tags><content type="html"> 1、加密 概念：将明文信息变成不可读的密文内容，只有拥有解密方法的对象才能够将密文还原成加密前的内容。 举例子： 说明：例子中&amp;quot;每隔3个取1个字符解读&amp;quot;相当于秘钥。将加密后的密文通过秘钥还原为明文，这就是解密 2、加密解密算法 对称加密：加密/解密用一个秘钥，且加密方和解密方都知道秘钥，如DES,3DES等。 非对称加密：加密用一个秘钥，解密用另一个秘钥且加密方一般有2个秘钥，解密方有一个解密秘钥。非对称加密安全性高，但速度慢，如RSA算法。 摘要算法：摘要算法是一种特殊的加密算法，它接收任意长度的数据，并输出固定长度的消息摘要作为结果。就是将原文和摘要同时传输给接收方。 摘要算法3特点：公开、一致、难碰撞 场景举例 在现在互联网时代，各种数据都是非常重要的，数据的保护不言而喻。
那涉及到数据加密和解密的场景在生活中处处都有，比如：
密码保存 数据传输 互联网信任体系 A和B私下签协议
数字签名过程： 验证签名过程： 权威机构证书
A和B都去第三方机构注册账号，然后上传自己的公钥给第三方机构。 第三方机构可以给A和B办法一个证书，证书里含有他们的公钥。 信任链条
情况1：B机器上有预装证书，B和A签约的时候，就会用这个预装的根证书验证A证书的签名，要使用权威机构的公钥（而公钥在证书里）。 情况2：B机器上没有预装证书，而是预装了给权威机构颁发证书的机构的证书。 信任体系里面存在的漏洞
B安装盗版操作系统，系统中含有恶意机构的CA 黑客发的邮件，点击后安装CA</content></entry><entry><title>计算机网络：Linux网络指令</title><url>/post/22/</url><categories><category>计算机网络</category><category>Linux</category></categories><tags><tag>Linux网络指令</tag></tags><content type="html"> 1、ssh/scp ssh
概念：Secure Shell（安全外壳），安全外壳是一种网络安全技术，它为网络服务提供安全的远程登录和传输，它是一种加密的传输协议。 ssh加密通信原理： 客户端向服务器发送加密的登录请求，服务器验证用户的身份，并向客户端发送公钥。 客户端使用公钥加密登录信息，并发送给服务器。 服务器使用自己的私钥解密登录信息，并与用户的信息进行比较。 若信息匹配，则建立加密通道，并开始传输数据。 若信息不匹配，则拒绝登录。 查看命令使用手册： ssh --help man ssh 命令：ssh [选项] [user@]hostname [command] 常用的选项： -p：指定远程主机的端口号，默认是22。 -l：指定登录用户名，如果不指定，使用本地登录用户名。 -C：压缩传输数据。 -i: 指定私钥文件。 -4：使用IPv4地址进行通信。 -6: 使用IPv6地址进行通信。 scp
概念：Secure Copy（安全复制），安全复制是一种在网络上进行文件传输的安全方式。 查看命令使用手册： scp --help man scp 命令：scp [选项] [user@]hostname:file1 [user@]hostname:file2 常用的选项： -P：指定远程主机的端口号，默认是22。 -r：递归复制整个目录。 -C: 压缩传输数据。 -p：保留远程文件的修改时间、访问时间和权限。 -i：指定私钥文件。 -4：使用IPv4地址进行通信。 -6：使用IPv6地址进行通信。 三种传输方式： 本地文件到远程文件：scp file1 user@hostname:file2 远程文件到本地文件：scp user@hostname:file1 file2 源和目标都为远程文件：scp user@hostname:file1 user@hostname:file2 2、ifconfig/netstat ifconfig
概念：网络接口配置工具，用于配置和显示网络接口的各种参数。 查看命令使用手册： ifconfig --help man ifconfig 命令：ifconfig [网络接口] [选项] 常用的网络接口： up：启动网络接口 down：停止网络接口 inet [IP地址]：设置网络接口的IP地址 netmask [子网掩码]：设置网络接口的 …</content></entry><entry><title>计算机网络：HTTP协议入门</title><url>/post/21/</url><categories><category>计算机网络</category></categories><tags><tag>HTTP协议</tag></tags><content type="html"> 1、起源 1990年伯纳斯.李，发明了万维网(WWW)，写了第一个Web Server HTTP协议：浏览器和Web Server之间通信的协议 2、定义 HTTP协议(Hyper Text Transfer Protocol): 应用层协议 目标: 是处理客户端和服务端之间的通信 3、请求/响应 请求
一次请求，分成头(Header)和体(Body)。 下面是一个请求头+消息体的 响应
一次返回，也同样分(Header)和体(Body)。 下面是一个返回头+消息体 4、请求头/响应头 HTTP协议通过请求头和返回头控制协议工作。无论是请求头还是返回头都是Key/Value的形式。 常见头部 Content-Length：发送/接收Body内容的字节数。 User-Agent：这个字段可以帮助统计客户端用了什么浏览器、操作系统等 Content-Type：请求的时候，告知服务端数据的媒体类（MediaType/MIME Type)。返回的时候告知客户端，数据的媒体类型。 Origin：描述请求来源地址 Accept：是HTTP协议协商能力的体现，用于建议服务端返回何种媒体类型(MIME Type) Referer：告诉服务端打开当前页面的上一张页面的URL，非浏览器环境有时候不发送Referer（或者虚拟Referer,通常是爬虫)，常用于用户行为分析 Connection：决定HTTP连接（不是TCP连接）是否在当前事务完成后关闭。（Http1.0 默认是 close ，Http1.1 后默认是 keep-alive） 5、HTTP的方法和状态码 方法 GET：从服务器获取资源 POST：在服务器创建资源(幂等性) PUT：在服务器修改资源 DELETE：在服务器删除资源 OPTION ：跨域部分讲解 TRACE ：用于显示调试信息 多数网站不支持 CONNECT： 代理部分讲解 PATCH ：对资源进行部分更新(极少用) 状态码 1xx：提供信息 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务端错误 注： 常用状态码速查表 6、HTTP缓存 HTTP缓存最重要的配置项为Cache-Control HTTP 返回头。 不仅浏览器可以缓存，浏览器和服务器之间的HTTP代理服务器也可以缓存。 7、代理服务器 概念：代理服务器接收一个请求，然后把请求转发 …</content></entry><entry><title>计算机网络：Socket编程-NIO进行优化</title><url>/post/20/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写了计算机网络：Socket编程-多线程优化和请求响应对象封装，
有留心的伙伴就会发现，我先是简单写了一个HTTP服务，然后对这个HTTP服务进行面向对象封装，接着又在封装的基础上进行多线程的优化和请求响应对象的封装，这样一步一步的由简入深。
这篇也是继续深入优化，之前的代码都是使用ServerSocket这个类，从代码中可以看出，它是每个请求都需要单独的线程进行处理，ServerSocket是基于阻塞I/O模型。那有没有非阻塞模式类？
有的，Java NIO库中提供了ServerSocketChannel这个类，它是通过Selector来管理多个通道的，一个线程可以处理多个请求。
1、NIO 过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将Socket注册到Selector中，也将内容信息存入Buffer中，放入Channel中）-&gt; 7（工作线程通过响应式获取Channel里的信息）-&gt; 8（工作线程先读取Channel信息，处理完请求后将相关信息写入Buffer，通过Channel再传递给内核）-&gt; 9（内核监听到Socket文件写入信息然后再返回给请求方）
代码实现 package com.hh.http; import java.io.*; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Iterator; import java.util.Set; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * NIO进步优化 * * @author hang.yuan 2022/3/8 19:50 */ public class HttpServer4 { ServerSocketChannel ssc; public void listen(int port) throws IOException { ssc = ServerSocketChannel.open(); ssc.bind(new InetSocketAddress(port)); // Reactive / Reactor ssc.configureBlocking(false); Selector selector = Selector.open(); ssc.register(selector,ssc.validOps(),null); ByteBuffer buffer = ByteBuffer.allocate(1024*16); for(;;){ int numOfKeys = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()){ SelectionKey key = it.next(); if (key.isAcceptable()){ SocketChannel channel = ssc.accept(); if (channel == null){ continue; } // Kernel --&gt; mmap(buffer) --&gt; Channel --&gt; User(buffer) channel.configureBlocking(false); channel.register(selector,SelectionKey.OP_READ); }else { SocketChannel channel = (SocketChannel)key.channel(); //_ _ _ _ _ _ _ // P(position) // L buffer.clear(); channel.read(buffer); String request = new String(buffer.array()); //Logic ... buffer.clear(); buffer.put(&#34;HTTP/1.1 200 ok\n\nHello NIO!\n&#34;.getBytes()); // H T T P / 1 ... ! _ _ // P(L) // P L buffer.flip();//就是把指针反过来 channel.write(buffer); channel.close(); } } } } public static void main(String[] args) throws IOException { HttpServer4 server = new HttpServer4(); server.listen(8000); } } 自己也可以学着前几篇用ServerSocket写的HttpServer类优化步骤，依葫芦画瓢一样对ServerSocketChannel写的HttpServer类进一步优化，
  ]]></content></entry><entry><title>计算机网络：Socket编程-多线程优化和请求响应对象封装</title><url>/post/19/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写了计算机网络：Socket编程-面向对象封装，然后以下基于之前的代码进一步进行多线程优化和请求响应对象封装。
1、多线程优化 对之前面向对象封装的代码，添加多线程优化，代码实现：
package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * 加入多线程优化 * * @author hang.yuan 2022/3/8 18:50 */ public class HttpServer3 { ServerSocket serverSocket; Function&lt;String,String&gt; handler; ExecutorService executorService; public HttpServer3(Function&lt;String, String&gt; handler) { this.handler = handler; this.executorService = Executors.newFixedThreadPool(10); } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } void accept() throws IOException { // Blocking ... Socket socket = serverSocket.accept(); // 多线程工作 executorService.execute(()-&gt;{ try{ this.handler(socket); }catch (IOException e){ e.printStackTrace(); } }); } public void handler(Socket socket)throws IOException { try{ // Thread --&gt; Sleep --&gt; Other Threads System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String response = this.handler.apply(request); bufferedWriter.write(response); bufferedWriter.flush(); socket.close(); }catch (IOException e){ e.printStackTrace(); } } public static void main(String[] args) throws IOException { HttpServer3 server = new HttpServer3(req -&gt; { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } return &#34;HTTP/1.1 201 ok\n\nGood!\n&#34;; }); server.listen(8000); } } 2、Request和Response对象封装 代码进行多线程优化后，进一步对请求（Request）和响应（Response）对象的封装
HttpServer对象 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.Map; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * Request/Response 进步抽象 * * @author hang.yuan 2022/3/8 18:50 */ public class HttpServer31 { ServerSocket serverSocket; IHandlerInterface handler; ExecutorService executorService; public HttpServer31(IHandlerInterface handler) { this.handler = handler; this.executorService = Executors.newFixedThreadPool(5); } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } void accept() throws IOException { // Blocking ... Socket socket = serverSocket.accept(); executorService.execute(()-&gt;{ try{ this.handler(socket); }catch (IOException e){ e.printStackTrace(); } }); } public void handler(Socket socket)throws IOException { Request request = new Request(socket); Response response = new Response(socket); this.handler.handler(request,response); } public static void main(String[] args) throws IOException { HttpServer31 server = new HttpServer31((req,resp)-&gt;{ System.out.println(req.getHeaders()); resp.send(&#34;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Hello Word&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;&#34;); }); server.listen(8000); } } 逻辑处理接口 package com.hh.http; import java.io.IOException; /** * 接口 * * @author hang.yuan 2022/3/8 20:07 */ @FunctionalInterface public interface IHandlerInterface { void handler(Request request, Response response) throws IOException; } Request对象 package com.hh.http; import org.apache.commons.httpclient.Header; import org.apache.commons.httpclient.HttpParser; import java.io.*; import java.net.Socket; import java.util.HashMap; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 请求 * * @author hang.yuan 2022/3/8 19:21 */ public class Request { static Pattern methodRegex = Pattern.compile(&#34;(GET|POST|PUT|DELETE|OPTIONS|TRACE|HEAD)&#34;); private final String body; private final String method; private final Map&lt;String, String&gt; headers; public Request(Socket socket) throws IOException { InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String methodLine = HttpParser.readLine(inputStream, &#34;UTF-8&#34;); Matcher matcher = methodRegex.matcher(methodLine); matcher.find(); String method = matcher.group(); Header[] headers = HttpParser.parseHeaders(inputStream, &#34;UTF-8&#34;); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for (Header header : headers) { map.put(header.getName(),header.getValue()); } BufferedReader bufferedReader1 = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder sb = new StringBuilder(); char[] buffer = new char[1024]; while (inputStream.available()&gt;0){ bufferedReader1.read(buffer); sb.append(buffer); } this.body= sb.toString(); this.method=method; this.headers=map; } public String getBody() { return body; } public String getMethod() { return method; } public Map&lt;String, String&gt; getHeaders() { return headers; } } Response对象 package com.hh.http; import java.io.BufferedWriter; import java.io.IOException; import java.io.OutputStreamWriter; import java.net.Socket; import java.util.HashMap; import java.util.Map; /** * 响应 * * @author hang.yuan 2022/3/8 19:22 */ public class Response { Socket socket; private int status = 200; static Map&lt;Integer,String&gt; codeMap; public Response(Socket socket) { this.socket=socket; if (codeMap == null){ codeMap= new HashMap&lt;&gt;(); codeMap.put(200,&#34;OK&#34;); } } public void send(String msg) throws IOException { String resp = &#34;HTTP/1.1 &#34;+this.status+&#34; &#34;+ this.codeMap.get(this.status)+&#34;\n&#34;; resp += &#34;\n&#34;; resp += msg; this.sendRaw(resp); } public void sendRaw(String msg) throws IOException { BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(msg); bufferedWriter.flush(); socket.close(); } }   ]]></content></entry><entry><title>计算机网络：Socket编程-面向对象封装</title><url>/post/18/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写的 计算机网络：Socket编程-实现HTTP服务 来进行面向对象封装
1、代码实现 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.util.function.Function; /** * 面向对象封装 * * @author hang.yuan 2022/3/8 18:30 */ public class HttpServer2 { ServerSocket serverSocket; Function&lt;String,String&gt; handler; public HttpServer2(Function&lt;String, String&gt; handler) { this.handler = handler; } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } public void accept() { try{ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = serverSocket.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String response = this.handler.apply(request); bufferedWriter.write(response); bufferedWriter.flush(); socket.close(); }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) throws IOException { HttpServer2 server = new HttpServer2( req -&gt; { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } return &#34;HTTP/1.1 201 ok\n\nGood!\n&#34;; }); server.listen(8000); } } 2、测试 测性能工具 ab 开始测试 结果 使用更大的并发测试，发现Pending Queue被占满，直接拒绝请求了   ]]></content></entry><entry><title>计算机网络：Socket编程-实现HTTP服务</title><url>/post/17/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  1、目标 不用框架利用Socket编程实现一个HTTP服务框架 2、线程模型 图示： 1、操作系统接受到外部请求时，会把请求放到Pending Queue里面，慢慢积累，如果 Pending Queue被占满时，这里会发生拒绝请求；
2、某一时刻某个线程会触发Accept的系统调用，Accept的系统调用会从Pending Queue拿出一个请求，然后在内核空间形成一个Socket文件，Socket文件会形成资源的一个句柄对应这个文件，派发线程一直循环，不断的Accept将每个文件形成FD（Socket，用来操作文件资源的）；
3、将FD派发给工作线程，工作线程读取Socket中的内容，进行处理后，再给用户返回信息，返回时工作线程直接在Socket写入信息，不需要原路返回了；
4、内核监听到Socket的写入信息，然后再把信息返回给请求方。
过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将获取到的Socket派发到工作线程）-&gt; 7（工作线程先读取4中文件内容，处理完请求后将相关信息直接写入到4中文件中，）-&gt; 8（内核监听到Socket文件写入信息然后再返回给请求方）
3、代码实现（简单实现） HttpServer代码 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 简单版 * * @author hang.yuan 2022/3/8 17:58 */ public class HttpServer { public static void main(String[] args) throws IOException { ServerSocket socketServer = new ServerSocket(8000); //main Thread while (true){ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = socketServer.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(&#34;HTTP/1.1 200 ok\n\nhello word!\n&#34;); bufferedWriter.flush(); socket.close(); } } } 测试： 结果：
  ]]></content></entry><entry><title>计算机网络：常用HTTP状态码速查表</title><url>/post/9/</url><categories><category>计算机网络</category></categories><tags><tag>状态码</tag></tags><content type="html"> Code Reason-Phrase 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 307 Temporary Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 426 Upgrade Required 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported Informational 1xx 1xx(Informational) 状态码类别表示在完成所请求的动作并发送最终响应之前的通信连接状态或请求进度的临时响应。
1xx 响应由状态行之后的第一个空行（空行表示header 部分的结尾）终止。 由于HTTP/1.0 没有定义任何1xx状态码，因此服务器不得向HTTP/1.0客户端发送1xx响应。
即使客户端没有预期到，客户 …</content></entry><entry><title>计算机网络：TCP、UDP、IP抓包工具-wireshark</title><url>/post/16/</url><categories><category>计算机网络</category></categories><tags><tag>wireshark</tag></tags><content type="html"> 1、什么是Wireshark？ 是世界上应用最广泛的网络协议分析器。 在微观层面上看到整个网络正在发生的事情。 使用WinPCAP作为接口，直接与网卡进行数据报文交换。 2、wireshark抓包原理 单机：直接抓取本机网卡的网络流量。 交换机：通过端口镜像、ARP欺骗等方式获取网络流量。 端口镜像：利用交换机的接口，将网络流量转发到指定电脑的网卡上。 ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取网络流量。 3、功能集 深入检查数百个协议，并不断添加更多协议 实时捕获和离线分析 支持Windows、Linux、macOS、Solaris、FreeBSD、NetBSD和许多其他平台 提供GUI浏览，也可以通过TTY VoIP支持 Gzip支持 IpSec支持 &amp;hellip;&amp;hellip; 4、抓包界面 如上图： 菜单栏 工具栏 过滤栏 数据列表区：不同的协议使用了不同的颜色区分。 数据详细区 数据字节区 数据统计区 下载 软件下载： https://www.wireshark.org/download.html 中文文档： wireshark-中文手册.pdf 提取码: 6or7</content></entry><entry><title>计算机网络：UDP协议</title><url>/post/15/</url><categories><category>计算机网络</category></categories><tags><tag>UDP</tag></tags><content type="html"> 背景和介绍 背景 1980年由科学家David P. Reed提出 协议简单，搭建在IP协议之上 尽可能的减少通信机制，速度非常快 该协议的RFC只有两页 介绍 全称: User Datagram Protocol，用户数据报协议 定义：在传输层提供直接发送报文(Datagram)的能力。Datagram是数据传输的最小单位。 目标：发送报文，无法拆分数据 思考：为什么不直接调用IP协议？ IP协议只能把数据从一个网络接口发送到另一个网络接口，无法寻址到应用 封包格式 设计目标：允许用户直接发送报文的情况下最大限度的简化应用的设计
报文格式： Source Port：源端口号 Destination Port：目标端口号。 Length：消息体长度 Checksum：检查封包是否出错 Data octets：一个字节一个字节的数据。Octet是8位。 与TCP的区别 UDP TCP 本质 提供报文交换，简化协议 提供可靠的网络传输 可靠性 不可靠 可靠 顺序 无序 有序 负载 负载小 负载大 广播场景 合适 不合适，代价大 场景分析 聊天室是否适合UDP？ 不合适，聊天室并发高但流量不大，依赖可靠性
HTTP协议适不适合UDP？ 合适，HTTP3.0就是建立在UDP上的</content></entry><entry><title>计算机网络：IPv6协议</title><url>/post/14/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 背景 IPv4只能支持43亿设备，不够用。
工作原理 IPv6和IPv4两者工作原理相似，为切片、增加封包头、路由(寻址)几个阶段。 与IPv4的主要区别 地址
地址数量：IPv4有4个8位，共16位，IPv6有8个16位，共128位 分割符号： IPv4的地址用 . 分割，如 103.28.7.35 。每一个是8位，用0-255的数字表示。 IPv6的地址用 : 分割，如 0123:4567:89ab:cdef:0123:4567:89ab:cdef 。每个是一个16位的16进制数字，就是4个符。 IPv6地址： 寻址
全局单播
站点前缀（Site Prefix)：48bit，一般是由ISP（Internet Service Providor，运营商）或者RIR(Regional Internet Registry， 地区性互联网注册机构)。RIR将IP地址分配给运营商。 子网号（Subnet ID)：16bit，用于站点内部区分子网。 接口号（Interface ID)：64bit，用于站点内部区分设备。 本地单播
给定地址，本地网定位设备 ⚠️ 注意：Link-local必须以fe80开头 分组多播
需要以8个1，也就是 ff00 开头，后面跟上一个分组的编号。 所在的网络中已经定义了该分组编号，而且有设备可以识别这个编号。 拥有分组下设备的完整清单，并把数据发送给对应的设备们。 IPv4也支持分组多播，但需要网络配置整体配合。 新设备接入 新设备接入IPv6后，会使用IPv6的邻居发现协议(Neighbour Discover Protocol)为自己申请一个IP地址。当新设备需要发送信息到目的地时，还可以通过ND协议广播查询目标设备。然后如果需要路由，还可以通过ND查找路由器。 传统：ARP协议（Address Resolution Protocol，地址解析协议）。每个节点存储许多额外信息。
IPv6: 更加无状态化，减少数据冗余带来的风险和负担
优势 解决了IP地址耗尽的问题 解决了网络区域、站点划分的问题。 协议层支持多播。 Ipv6可以有专门的地址用作多播。 支持邻居发现协议，自动分配地址，做到了无状态接入设备。</content></entry><entry><title>计算机网络：IP协议</title><url>/post/13/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 概念 IP协议(Internet Protocol)：网络层协议。 IP协议可能遇到的问题： 封包损坏 丢包 重发 乱序 网络层需要解决的3个问题： 延迟 吞吐量 丢包率 IP协议目前主要有两种架构，IPv4和IPv6，IPv4是目前应用最广泛的互联网协议。 IP协议的工作原理 分片
把数据切分成片 适配底层传输网络 增加协议头 Type Of Service：服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。 IHL（Internet Header Length)：IP协议头的大小。 Total Length：报文(封包datagram)的长度 Identification：报文的ID，发送方分配，代表顺序 Fragment offset：描述是否要分包（拆分），和如何拆分。 Time To Live：封包存活的时间。 Protocol：描述上层的协议，比如TCP=6,UDP=17 Options：可选项 Checksum：检验封包的正确性 延迟、吞吐量、丢包率 寻址
寻址：给一个地址，然后找到这个东西 IPv4地址(32位)：逐级寻址 步骤： 路由
若寻找的IP地址不在局域网中，需要路由找到去往对应网络的路径。 IP地址和子网掩码位与的过程是由路由算法实现的。</content></entry><entry><title>计算机网络：TCP协议</title><url>/post/12/</url><categories><category>计算机网络</category></categories><tags><tag>TCP</tag></tags><content type="html"> 概述 TCP全名是(Transport Control Protocol)，是一个可以提供可靠的、支持全双工、连接导向的协议，因此在客户端和服务端之间传输数据的时候，是必须先建立一个连接的。 TCP的特点 连接 是虚拟、抽象的概念 能让两个通信的程序间确保彼此都在线 加快响应请求速度 连接也被称为会话(Session） 使通信更稳定、安全 消耗更多资源 全双工 单工：任何时刻数据只能单向发送 半双工：允许数据在两个方向上传输，在某一时刻，只允许数据在一个方向上传输 全双工：任何时刻都能双向发送数据 可靠的
可靠性指数据保证无损传输 使无序的数据恢复原有顺序 多播时每个接收方都获得无损副本 TCP协议的工作过程 建立连接的过程（三次握手） 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 断开连接的过程（四次挥手） 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 传输数据 报文拆分
应用层数据很大时无法一次性传输完 拆分后可实现并行传输 顺序保证
思考：如果TCP段特别多的时候，该如何进行排序？时间窗口 TCP序号：发送序号(Seq)、接收序号(Ack) 一个端的发送序号是另一个端的接受序号 TCP头部结构 结构图： 源端口：描述发送方机器上的应用
目标端口：描述接收方服务器上的应用
发送序号(Seq)/接收序号(Ack)
标志位
NS、CWR、ECE：TCP扩展协议 ECN：显示拥塞控制协议，有助于帮助解决延迟和丢包问题， URG：紧急标志位SYN（Synchronize Sequence Numbers)：同步序号，也就是在建立连接。 FIN： 终止连接 ACK（Achnowledgment)：响应。 PSH（push）：传送数据 RST（Reset Connection)： 重置连接 TCP协议周边配置 纠错能力：保证数据可靠性； TCP拥有一个16bit的Checksum字段 Checksum是一个函数，把原文映射到一个不可逆的16bit的编码中这样就可以知道原文传输过程中有没有发生变化 流控能力：协同两边速率，保证可靠性； 主要目标：让发送方和接收方协商一个合理的收发速率，让两边都可以稳定的工作。 利用滑动窗口 拥塞控制能力：确定网络的拥堵情况决定传输速度。</content></entry><entry><title>SSH还能内网穿透，实在是没想到</title><url>/post/7/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag><tag>内网穿透</tag></tags><content type="html"> 1、准备 两台机器(一台有公网IP A，一台是没有公网IP B)
2、操作 (1) A机器运行sshd ，将GatewayPorts设置为yes，并重启sshd
(2) B机器执行如下命令：
ssh -NR 9999:192.168.56.2:22 A机器的用户@A机器的Ip 参数解释： -N ：不执行任何命令 -R ： 将端口绑定到远程服务器,反向代理 9999 ：自己设定的在远程服务器的监听端口 192.168.56.2:22 ： 本地的服务ip和监听端口 A机器的用户@A机器的Ip ：远程服务器的用户和IP 3、测试 (1) 在A机器上执行netstat -lntp 可以看到9999端口被监听
(2) 测试A机器上使用隧道连接B机器
ssh -p 9999 B机器的用户@192.168.56.2 注：只是自己测试玩一玩的，不要抱很大希望能生产使用</content></entry><entry><title>计算机网络：互联网协议群</title><url>/post/11/</url><categories><category>计算机网络</category></categories><tags><tag>TCP/IP协议</tag></tags><content type="html"> 概述 OSI无实际可行方案 有人就提出了TCP协议 TCP/IP协议群解决的5个问题 报文拆分
数据量大，网络底层设备不支持 复用路径 增加协议头
数据分块后在接收端需要重组，所以需要使用头部来添加一些描述字段 数据在相邻设备间数据传递 路由和寻址
路由算法：通过算法寻找下一个要到达的节点 数组重组 TCP/IP协议群的5层模型 5层模型图： 5层模型与OSI7层模型区别 删除了会话层，会话是虚拟概念，不是必须的 删除了表示层，数据压缩、数据格式转换不是应用必须的 TCP/IP协议群可选性 传输层：TCP协议、UDP协议、TLS/SSL、SCTP等 网络层：IP协议(ipv4和ipv6)、ICMP协议、IPSec协议</content></entry><entry><title>计算机网络：OSI七层模型</title><url>/post/10/</url><categories><category>计算机网络</category></categories><tags><tag>7层模型</tag></tags><content type="html"> 1、OSI模型是什么？ OSI模型指的是Open System Interconnection Reference Model，即开放式系统互联模型。它是世界上第一个试图在世界范围内规范网络标准的框架。
2、7层模型详解 OSI模型图示： 应用层
应用层位于OSI模型最上方 只关心业务逻辑，不关心数据传输 例如：张三给小花微信发送消息 表现层
负责协商用于传输的数据格式，并转换数据格式 会话层
负责管理两个连网实体间的连接 功能及特点：建立连接，维持通信，释放连接 传输层
负责将数据从一个实体（服务器或者应用）传输到另一个实体，但不负责数据传输的方式。 能力： 数据分隔重组：将数据拆分后按顺序重组 纠错：在数据传输过程中出现问题后采取方式进行纠正 管理连接：处理数据的频繁交换 流量控制：控制传输数据的速率 端口寻址：标明参与传输的实体的端口号 网络层
负责把一个封包从一个IP地址传输到另一个IP地址 思考：一个节点接收到一个封包之后，它怎么把这个封包传递到下个节点？ 路由算法 数据链路层
确保两个临近设备间数据的传输，并隐藏底层实现 帧同步：两个设备之间传输时的协商速率问题 数据纠错 物理层
封装和隐藏具体的传输手段，并且提供稳定的传输接口 比如：电缆、光纤、蓝牙等 3、OSI的问题 分层设计较为臃肿，并非每一层都为必要的，所以有了 应用层、表示层、会话层合为应用层</content></entry><entry><title>rsync数据同步备份工具</title><url>/post/5/</url><categories><category>Linux</category></categories><tags><tag>rsync</tag><tag>数据同步备份</tag></tags><content type="html"><![CDATA[  介绍rsync工具 rsync是什么：一款开源的，快速的，多功能的，可以实现全量和增量的本地或远程数据同步备份工具。
使用范围 : unix,linux,windows等多种操作系统
优点： 1、具有本地和远程两台主机之间数据快速复制同步，备份功能 2、能实现增量备份，具有独特的quick check算法
工作方式： 1、单个本机之间数据传输，类似于cp命令。 2、借助rcp,ssh通道传输数据，类似于scp。 3、以守护进程（socket）方式传输数据。
实践 示例：以虚拟机与本地机器（自己实体电脑）数据备份为例
简单说明：自己电脑内安装VirtualBox虚拟机通过共享文件的方式把虚拟机内产生的数据备份到自己电脑的磁盘上
环境：台式机一台，安装VirtualBox虚拟机
准备脚本(databak.sh)
/usr/bin/rsync --timeout=60 --progress --log-file=&#39;/opt/logs/rsync.log&#39; --log-file-format=&#39;%t %f %b&#39; -azvP /opt/all_data /media/sf_2/ 脚本命令解释：该命令使用rsync工具将/opt/all_data目录及其内容同步到/media/sf_2/目录。
具体参数解释如下：
&ndash;timeout=60：设置连接超时时间为60秒。 &ndash;progress：显示进度条。 &ndash;log-file=&rsquo;/opt/logs/rsync.log&rsquo;：将rsync的日志记录到/opt/logs/rsync.log文件中。 &ndash;log-file-format=&rsquo;%t %f %b&rsquo;：日志文件的格式为时间、文件名和字节大小。 -a 以递归方式传输文件，并保持所有文件的属性 -z 传输时进行压缩以提高传输效率 -v 详细模式输出 -P 显示同步的过程及传输时的进度等信息 crontab简单操作命令
crontab -l 查看 crontab -e 编辑 service crond restart 重启 crontab定时任务，数据备份命令 0 3 * * * /usr/bin/sh /opt/databak.sh &gt; /dev/null 2&gt;&amp;1 cron表达式解释：表示每天凌晨0点用shell执行/opt/databak.sh脚本，并将输出重定向到/null。
具体解释如下：
0：表示分钟数，即0分。 3：表示小时数，即0-23小时之间的第3个小时。 *：表示日期（月份、星期等）的通配符，表示每小时执行。 *：表示日期（月份、星期等）的通配符，表示每天执行。 &gt; /dev/null：将标准输出重定向到/null，即不输出任何结果。 2&gt;&amp;1：将错误输出重定向到标准输出，即仍然保留错误输出，只是不输出正常输出。   ]]></content></entry><entry><title>Linux下安装jupyter</title><url>/post/1/</url><categories><category>Linux</category></categories><tags><tag>jupyter</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  1.安装jupyter # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install jupyter 2.生成jupyter配置文件 # root用户： jupyter notebook –generate-config –allow-root # 非root用户 jupyter notebook –generate-config #输出信息：Writing default config to: /root/.jupyter/jupyter_notebook_config.py # 配置文件地址： /root/.jupyter/jupyter_notebook_config.py 3.打开ipython,生成密码 [root@hangzhi ~]# ipython In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: #此处输入密码 Verify password: #此处输入之前输入的密码 Out[2]: &#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; #这个秘钥要copy备用 4.修改配置文件 [root@hangzhi ~]# vi /root/.jupyter/jupyter_notebook_config.py # notebook服务会监听的IP地址 c.NotebookApp.ip = &#39;&#39; #工作目录，自己选定 c.NotebookApp.notebook_dir = &#39;/opt/jupyter/jupyter_work&#39; c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 #上面生成的秘钥 c.NotebookApp.password = u&#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; 5.启动jupyter # root用户 jupyter notebook –allow-root # 非root用户 jupyter notebook 后台启动脚本 # root用户 nohup jupyter notebook --allow-root &gt; /opt/logs/jupyter.log 2&gt;&amp;1 &amp; 停止脚本 #!/bin/bash #停止服务名称 SERVER_NAME=jupyter-notebook PIDS=`ps -ef | grep jupyter |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep jupyter` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34; 6.浏览器访问 ip:8888 即可访问了，需输入密码就可以   ]]></content></entry><entry><title>frp实现内网穿透详细配置</title><url>/post/8/</url><categories><category>Linux</category></categories><tags><tag>frp</tag><tag>内网穿透</tag></tags><content type="html"> 1、条件 需要一个有公网IP的云服务器（我的是腾讯云）
2、frp下载及介绍 (1)、 frp下载：https://github.com/fatedier/frp/releases 下载最新版，根据自己的服务器下载对应版本（我的是linux64系统）
wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gz (2)、解压压缩包
tar -zxvf frp_0.34.3_linux_amd64.tar.gz mv frp_0.34.3_linux_amd64 frpServer 包结构介绍： 服务器端：
frps： 服务器端服务启动文件 frps_full.ini： 启动配置文件（全版） frps.ini ：启动配置文件（简版） 客户端（Linux版）：
frpc ：客户端服务启动文件 frpc_full.ini ：启动配置文件（全版） frpc.ini ：启动配置文件（简版） 3、进入解压文件夹 cd frpServer 服务端配置及运行 1、修改端口，frps.ini文件
[common] bind_port = 9999 # bind_port是服务器的端口，我们最好不要使用默认端口 2、运行服务
直接运行： # frp解压文件夹目录下运行，也可以使用全路径 # 相对路径 ./frps -c frps.ini # 绝对路径 /opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini 后台运行： nohup ./frpc -c ./frpc.ini &amp;amp;amp; 3、配置系统启动时自动启动
在/lib/systemd/system文件夹下创建frps.service文件 编辑frps.service文件，输入以下内容(注：ExecStart 使用绝对路径 )： [Unit] Description=frp service After=network.target [Service] TimeoutStartSec=30 ExecStart=/opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini ExecStop=/bin/kill …</content></entry><entry><title>解决自己的云服务器经常被登录问题</title><url>/post/6/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag></tags><content type="html"> 解决过程 环境：腾讯centos云服务器
原因：每次登录云服务器时系统都会提示，这是被各种尝试登录导致的（简单说就是你的服务器被攻击了）
Last failed login: Tue Dec 29 21:06:17 CST 2020 from 182.78.163.21 on ssh:notty There were 6751 failed login attempts since the last successful login. Last login: Sat Dec 26 01:17:59 2020 from 120.230.83.193 解决办法：使用密钥登录可以解决
步骤如下：
1、生成ssh密钥
[root@hangzhi ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #此处直接回车就可以 Enter passphrase (empty for no passphrase): #设置解密钥密码 Enter same passphrase again: #再此输入一样密码确认 Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:9vRVtZ9uUUinLq+0byUMYDo8XZpZQ/t2iDbrGjcjMNc root@hangzhi The key&amp;#39;s randomart image is: +---[RSA 2048]----+ | .. . o| | o +o +o| | . + B..o.o| | = =..+ o+| | Soo Eo*oo| | . * o B+.o| | + B .= | | * =o | | ..+o. | +----[SHA256]-----+ 2、查看生成的密钥
[root@hangzhi ~]# cd /root/.ssh/ [root@hangzhi .ssh]# ll total 12 -rw-r--r--. 1 root root 0 Mar 7 2018 authorized_keys -rw------- 1 root root 1766 Dec 29 21:13 id_rsa #私钥 -rw-r--r-- 1 root root 394 Dec 29 21:13 id_rsa.pub #公钥 -rw-r--r-- 1 root root 176 Jan 6 2019 known_hosts 3、将公钥追加到authorized_keys文件中
[root@hangzhi .ssh]# cat id_rsa.pub &amp;gt;&amp;gt; /root/.ssh/authorized_keys 4、将权限改为只有当前用户可读可写，保证安全
[root@hangzhi .ssh]# chmod 600 authorized_keys 5、打开ssh的密钥登录功能
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys #将上面2行前面的注释去掉，然后保存 # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service 6、然后使用客户端配置密钥登录，如果成功接着下一步，不成功重复上面步骤
7、关闭ssh密码登录（注意：只有配置成功后才操作这个步，不然没成功关闭这个会导致不能登录服务器 ）
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config PasswordAuthentication yes 修改为: PasswordAuthentication no # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service</content></entry><entry><title>VirtualBox虚拟机导出及磁盘扩展</title><url>/post/4/</url><categories><category>Linux</category></categories><tags><tag>VirtualBox虚拟机</tag><tag>磁盘扩展</tag></tags><content type="html"> VirtualBox虚拟机导出 VirtualBox虚拟机的迁移除了复制还有一种通用方式是导出
复制的方式可以看之前写的：VirtualBox虚拟机迁移/复制（带快照）
简单方便的导出方式(推荐)，因为适用其他虚拟机,如:VMWare
VirtualBox虚拟机磁盘扩展 1.创建磁盘和添加磁盘
**对于创建时使用哪种磁盘文件，如下图介绍（我自己使用的VMDK）：** 2.查看能不能识别磁盘
3.对磁盘分区
fdisk /dev/sdb 选N进行分区 两个选项，e为分逻辑分区，p为主分区，（我选择的是p） 选1，说明是创建第一个分区，起始位置默认直接回车 下一个是让你选择究竟要分多大空间给这个分区，直接回车就默认全部分给他，单位按MB来算 选W 保存退出 4.查看分好区的磁盘
fdisk -l 查看 能看到/dev/sdb1了就ok 5.对分区好磁盘格式化
mkfs.ext4 /dev/sdb1 对这个分区进行格式化 格式化成ext4格式，如果你想其他格式就自己改 6.创建磁盘挂载的文件夹
mkdir /mnt/sdb1 （这个是要将硬盘挂载的地方，位置随意） 7.将挂载文件夹与磁盘关联
mount /dev/sdb1 /mnt/sdb1 （挂载这个硬盘到这个位置上） df -h就能看到硬盘了 8.设置开机自动挂载磁盘
vi /etc/fstab 让系统可以开机后自动将硬盘挂载上去 最后一行添加：/dev/sdb1 /mnt/sdb1 ext4 defaults 0 0 然后保存退出</content></entry><entry><title>启动和停止shell脚本</title><url>/post/2/</url><categories><category>Linux</category></categories><tags><tag>shell脚本</tag></tags><content type="html"><![CDATA[  start.sh 定义变量: 服务名/部署路径/服务输出日志路径/启动文件路径 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 没启动继续下面的 设置JVM参数: JAVA_OPTS 后台启动应用: nohup java -jar 命令 再次检查是否启动 shell脚本示例: #!/bin/bash #启动服务名称 SERVER_NAME=test #服务部署路径 DEPLOY_DIR=/opt/app/test # 服务日志输出路径 STDOUT_FILE=${DEPLOY_DIR}/logs/test.log #服务启动的jar或war WAR_FILE=${DEPLOY_DIR}/test.jar PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -n &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The ${SERVER_NAME} already started!&#34; echo &#34;&gt;&gt;&gt; PID: $PIDS&#34; exit 1 fi #jvm参数配置 JAVA_OPTS=&#34;-server -Xmx2g -Xms2g &#34; echo -e &#34;&gt;&gt;&gt; Starting the ${SERVER_NAME} ...\c&#34; nohup java $JAVA_OPTS -jar ${WAR_FILE} &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39; | wc -l` if [ $COUNT -gt 0 ]; then break fi done PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39;` echo &#34;OK ! --&gt;&gt;&gt; PID: $PIDS --&gt;&gt;&gt; STDOUT: $STDOUT_FILE &#34; stop.sh 定义变量: 部署服务路径/停止服务名称 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 启动继续下面的 kill掉进程 再次检查进程是否存在 shell脚本示例: #!/bin/bash #服务部署路径 DEPLOY_DIR=/opt/app/test #停止服务名称 SERVER_NAME=test PIDS=`ps -ef | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep java` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34;   ]]></content></entry><entry><title>VirtualBox虚拟机迁移/复制（带快照）</title><url>/post/3/</url><categories><category>Linux</category></categories><tags><tag>VirtualBox虚拟机</tag></tags><content type="html"> 本次虚拟机迁移是基于VirtualBox虚拟机，如果要尝试安装和创建虚拟机可以去搜索：virtualbox的安装与使用、安装镜像创建虚拟机
一、VirtualBox的结构介绍 xxx.vdi : 这个文件是磁盘映像，创建虚拟机的时候创建的
xxx.vbox 和 xxx.vbox-prev：这个两文件虚拟机的配置文件，记录了所以配置信息，如快照，虚拟磁盘等，核心文件是.vbox文件
xxx.vmdk : 这个文件是虚拟机磁盘，是用来扩展机器存储空间，创建虚拟机一般是没有次文件的
{UUID}.vdi ：磁盘映像文件的快照
{UUID}.vmdk : 虚拟机磁盘文件的快照
注：迁移有风险，迁移时要多细心
二、不带快照 1、迁移到不同机器 迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到不同机器，由于是在不同的机器上进行迁移，是不涉及到镜像文件的UUID相同情况，因此比较简单，只需要打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
在新机器上的VirtualBox软件中注册刚修改的文件，有.vmdk 文件也需要注册，否则不注册。如下图：
新机的迁移就这么简单完成了。
2、迁移到本机机器不同目录 迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到本机机器不同目录，由于是在本机机器上进行迁移，涉及到镜像文件的UUID相同情况，因此需要分两步走：一是修改文件路径，二是修改文件UUID
修改文件路径：打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
修改文件UUID：将.vdi、.vmdk(没有这个文件，可以忽略)文件重新生成UUID
VirtualBox软件安装目录下执行如下命令重新生成UUID
// 重新生成centos7(two).vdi的UUID VBoxManage internalcommands sethduuid &amp;amp;#34;F:\VirtualBox\centos7(two)\centos7(two).vdi&amp;amp;#34; // 重新生成sda7.vmdk的UUID VBoxManage internalcommands sethduuid …</content></entry></search>