<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 编程之路 一枚不起眼有着梦想爱读书的程序猿，记录自己的编程小技巧分享。
编程之路，探索智慧的无尽旅程。
在这条路上，小猿编程秘籍解锁创新，磨砺思维，不断超越。
编程，开启你的未来可能。
其他渠道： Github 掘金 知乎 CSDN 公众号：小猿编程秘籍 民族风情园 民族风情园致力于一个汇聚、分享知识的风情园。
知识如同一座宝库，不断挖掘，方能收获智慧之光。
风情园各园：编程之路、文化之路、AI之路、生活之路、财富之路、杂货铺之路</content></entry><entry><title>计算机网络：Socket编程-实现HTTP服务</title><url>/post/17/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  1、目标 不用框架利用Socket编程实现一个HTTP服务框架 2、线程模型 图示： 1、操作系统接受到外部请求时，会把请求放到Pending Queue里面，慢慢积累，如果 Pending Queue被占满时，这里会发生拒绝请求；
2、某一时刻某个线程会触发Accept的系统调用，Accept的系统调用会从Pending Queue拿出一个请求，然后在内核空间形成一个Socket文件，Socket文件会形成资源的一个句柄对应这个文件，派发线程一直循环，不断的Accept将每个文件形成FD（Socket，用来操作文件资源的）；
3、将FD派发给工作线程，工作线程读取Socket中的内容，进行处理后，再给用户返回信息，返回时工作线程直接在Socket写入信息，不需要原路返回了；
4、内核监听到Socket的写入信息，然后再把信息返回给请求方。
过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将获取到的Socket派发到工作线程）-&gt; 7（工作线程先读取4中文件内容，处理完请求后将相关信息直接写入到4中文件中，）-&gt; 8（内核监听到Socket文件写入信息然后再返回给请求方）
3、代码实现（简单实现） HttpServer代码 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 简单版 * * @author hang.yuan 2022/3/8 17:58 */ public class HttpServer { public static void main(String[] args) throws IOException { ServerSocket socketServer = new ServerSocket(8000); //main Thread while (true){ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = socketServer.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(&#34;HTTP/1.1 200 ok\n\nhello word!\n&#34;); bufferedWriter.flush(); socket.close(); } } } 测试： 结果：
  ]]></content></entry><entry><title>计算机网络：常用HTTP状态码速查表</title><url>/post/9/</url><categories><category>计算机网络</category></categories><tags><tag>状态码</tag></tags><content type="html"> Code Reason-Phrase 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 307 Temporary Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 426 Upgrade Required 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported Informational 1xx 1xx(Informational) 状态码类别表示在完成所请求的动作并发送最终响应之前的通信连接状态或请求进度的临时响应。
1xx 响应由状态行之后的第一个空行（空行表示header 部分的结尾）终止。 由于HTTP/1.0 没有定义任何1xx状态码，因此服务器不得向HTTP/1.0客户端发送1xx响应。
即使客户端没有预期到，客户 …</content></entry><entry><title>计算机网络：TCP、UDP、IP抓包工具-wireshark</title><url>/post/16/</url><categories><category>计算机网络</category></categories><tags><tag>wireshark</tag></tags><content type="html"> 1、什么是Wireshark？ 是世界上应用最广泛的网络协议分析器。 在微观层面上看到整个网络正在发生的事情。 使用WinPCAP作为接口，直接与网卡进行数据报文交换。 2、wireshark抓包原理 单机：直接抓取本机网卡的网络流量。 交换机：通过端口镜像、ARP欺骗等方式获取网络流量。 端口镜像：利用交换机的接口，将网络流量转发到指定电脑的网卡上。 ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取网络流量。 3、功能集 深入检查数百个协议，并不断添加更多协议 实时捕获和离线分析 支持Windows、Linux、macOS、Solaris、FreeBSD、NetBSD和许多其他平台 提供GUI浏览，也可以通过TTY VoIP支持 Gzip支持 IpSec支持 &amp;hellip;&amp;hellip; 4、抓包界面 如上图： 菜单栏 工具栏 过滤栏 数据列表区：不同的协议使用了不同的颜色区分。 数据详细区 数据字节区 数据统计区 下载 软件下载： https://www.wireshark.org/download.html 中文文档： wireshark-中文手册.pdf 提取码: 6or7</content></entry><entry><title>计算机网络：UDP协议</title><url>/post/15/</url><categories><category>计算机网络</category></categories><tags><tag>UDP</tag></tags><content type="html"> 背景和介绍 背景 1980年由科学家David P. Reed提出 协议简单，搭建在IP协议之上 尽可能的减少通信机制，速度非常快 该协议的RFC只有两页 介绍 全称: User Datagram Protocol，用户数据报协议 定义：在传输层提供直接发送报文(Datagram)的能力。Datagram是数据传输的最小单位。 目标：发送报文，无法拆分数据 思考：为什么不直接调用IP协议？ IP协议只能把数据从一个网络接口发送到另一个网络接口，无法寻址到应用 封包格式 设计目标：允许用户直接发送报文的情况下最大限度的简化应用的设计
报文格式： Source Port：源端口号 Destination Port：目标端口号。 Length：消息体长度 Checksum：检查封包是否出错 Data octets：一个字节一个字节的数据。Octet是8位。 与TCP的区别 UDP TCP 本质 提供报文交换，简化协议 提供可靠的网络传输 可靠性 不可靠 可靠 顺序 无序 有序 负载 负载小 负载大 广播场景 合适 不合适，代价大 场景分析 聊天室是否适合UDP？ 不合适，聊天室并发高但流量不大，依赖可靠性
HTTP协议适不适合UDP？ 合适，HTTP3.0就是建立在UDP上的</content></entry><entry><title>计算机网络：IPv6协议</title><url>/post/14/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 背景 IPv4只能支持43亿设备，不够用。
工作原理 IPv6和IPv4两者工作原理相似，为切片、增加封包头、路由(寻址)几个阶段。 与IPv4的主要区别 地址
地址数量：IPv4有4个8位，共16位，IPv6有8个16位，共128位 分割符号： IPv4的地址用 . 分割，如 103.28.7.35 。每一个是8位，用0-255的数字表示。 IPv6的地址用 : 分割，如 0123:4567:89ab:cdef:0123:4567:89ab:cdef 。每个是一个16位的16进制数字，就是4个符。 IPv6地址： 寻址
全局单播
站点前缀（Site Prefix)：48bit，一般是由ISP（Internet Service Providor，运营商）或者RIR(Regional Internet Registry， 地区性互联网注册机构)。RIR将IP地址分配给运营商。 子网号（Subnet ID)：16bit，用于站点内部区分子网。 接口号（Interface ID)：64bit，用于站点内部区分设备。 本地单播
给定地址，本地网定位设备 ⚠️ 注意：Link-local必须以fe80开头 分组多播
需要以8个1，也就是 ff00 开头，后面跟上一个分组的编号。 所在的网络中已经定义了该分组编号，而且有设备可以识别这个编号。 拥有分组下设备的完整清单，并把数据发送给对应的设备们。 IPv4也支持分组多播，但需要网络配置整体配合。 新设备接入 新设备接入IPv6后，会使用IPv6的邻居发现协议(Neighbour Discover Protocol)为自己申请一个IP地址。当新设备需要发送信息到目的地时，还可以通过ND协议广播查询目标设备。然后如果需要路由，还可以通过ND查找路由器。 传统：ARP协议（Address Resolution Protocol，地址解析协议）。每个节点存储许多额外信息。
IPv6: 更加无状态化，减少数据冗余带来的风险和负担
优势 解决了IP地址耗尽的问题 解决了网络区域、站点划分的问题。 协议层支持多播。 Ipv6可以有专门的地址用作多播。 支持邻居发现协议，自动分配地址，做到了无状态接入设备。</content></entry><entry><title>计算机网络：IP协议</title><url>/post/13/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 概念 IP协议(Internet Protocol)：网络层协议。 IP协议可能遇到的问题： 封包损坏 丢包 重发 乱序 网络层需要解决的3个问题： 延迟 吞吐量 丢包率 IP协议目前主要有两种架构，IPv4和IPv6，IPv4是目前应用最广泛的互联网协议。 IP协议的工作原理 分片
把数据切分成片 适配底层传输网络 增加协议头 Type Of Service：服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。 IHL（Internet Header Length)：IP协议头的大小。 Total Length：报文(封包datagram)的长度 Identification：报文的ID，发送方分配，代表顺序 Fragment offset：描述是否要分包（拆分），和如何拆分。 Time To Live：封包存活的时间。 Protocol：描述上层的协议，比如TCP=6,UDP=17 Options：可选项 Checksum：检验封包的正确性 延迟、吞吐量、丢包率 寻址
寻址：给一个地址，然后找到这个东西 IPv4地址(32位)：逐级寻址 步骤： 路由
若寻找的IP地址不在局域网中，需要路由找到去往对应网络的路径。 IP地址和子网掩码位与的过程是由路由算法实现的。</content></entry><entry><title>计算机网络：TCP协议</title><url>/post/12/</url><categories><category>计算机网络</category></categories><tags><tag>TCP</tag></tags><content type="html"> 概述 TCP全名是(Transport Control Protocol)，是一个可以提供可靠的、支持全双工、连接导向的协议，因此在客户端和服务端之间传输数据的时候，是必须先建立一个连接的。 TCP的特点 连接 是虚拟、抽象的概念 能让两个通信的程序间确保彼此都在线 加快响应请求速度 连接也被称为会话(Session） 使通信更稳定、安全 消耗更多资源 全双工 单工：任何时刻数据只能单向发送 半双工：允许数据在两个方向上传输，在某一时刻，只允许数据在一个方向上传输 全双工：任何时刻都能双向发送数据 可靠的
可靠性指数据保证无损传输 使无序的数据恢复原有顺序 多播时每个接收方都获得无损副本 TCP协议的工作过程 建立连接的过程（三次握手） 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 断开连接的过程（四次挥手） 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 传输数据 报文拆分
应用层数据很大时无法一次性传输完 拆分后可实现并行传输 顺序保证
思考：如果TCP段特别多的时候，该如何进行排序？时间窗口 TCP序号：发送序号(Seq)、接收序号(Ack) 一个端的发送序号是另一个端的接受序号 TCP头部结构 结构图： 源端口：描述发送方机器上的应用
目标端口：描述接收方服务器上的应用
发送序号(Seq)/接收序号(Ack)
标志位
NS、CWR、ECE：TCP扩展协议 ECN：显示拥塞控制协议，有助于帮助解决延迟和丢包问题， URG：紧急标志位SYN（Synchronize Sequence Numbers)：同步序号，也就是在建立连接。 FIN： 终止连接 ACK（Achnowledgment)：响应。 PSH（push）：传送数据 RST（Reset Connection)： 重置连接 TCP协议周边配置 纠错能力：保证数据可靠性； TCP拥有一个16bit的Checksum字段 Checksum是一个函数，把原文映射到一个不可逆的16bit的编码中这样就可以知道原文传输过程中有没有发生变化 流控能力：协同两边速率，保证可靠性； 主要目标：让发送方和接收方协商一个合理的收发速率，让两边都可以稳定的工作。 利用滑动窗口 拥塞控制能力：确定网络的拥堵情况决定传输速度。</content></entry><entry><title>SSH还能内网穿透，实在是没想到</title><url>/post/7/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag><tag>内网穿透</tag></tags><content type="html"> 1、准备 两台机器(一台有公网IP A，一台是没有公网IP B)
2、操作 (1) A机器运行sshd ，将GatewayPorts设置为yes，并重启sshd
(2) B机器执行如下命令：
ssh -NR 9999:192.168.56.2:22 A机器的用户@A机器的Ip 参数解释： -N ：不执行任何命令 -R ： 将端口绑定到远程服务器,反向代理 9999 ：自己设定的在远程服务器的监听端口 192.168.56.2:22 ： 本地的服务ip和监听端口 A机器的用户@A机器的Ip ：远程服务器的用户和IP 3、测试 (1) 在A机器上执行netstat -lntp 可以看到9999端口被监听
(2) 测试A机器上使用隧道连接B机器
ssh -p 9999 B机器的用户@192.168.56.2 注：只是自己测试玩一玩的，不要抱很大希望能生产使用</content></entry><entry><title>计算机网络：互联网协议群</title><url>/post/11/</url><categories><category>计算机网络</category></categories><tags><tag>TCP/IP协议</tag></tags><content type="html"> 概述 OSI无实际可行方案 有人就提出了TCP协议 TCP/IP协议群解决的5个问题 报文拆分
数据量大，网络底层设备不支持 复用路径 增加协议头
数据分块后在接收端需要重组，所以需要使用头部来添加一些描述字段 数据在相邻设备间数据传递 路由和寻址
路由算法：通过算法寻找下一个要到达的节点 数组重组 TCP/IP协议群的5层模型 5层模型图： 5层模型与OSI7层模型区别 删除了会话层，会话是虚拟概念，不是必须的 删除了表示层，数据压缩、数据格式转换不是应用必须的 TCP/IP协议群可选性 传输层：TCP协议、UDP协议、TLS/SSL、SCTP等 网络层：IP协议(ipv4和ipv6)、ICMP协议、IPSec协议</content></entry><entry><title>计算机网络：OSI七层模型</title><url>/post/10/</url><categories><category>计算机网络</category></categories><tags><tag>7层模型</tag></tags><content type="html"> 1、OSI模型是什么？ OSI模型指的是Open System Interconnection Reference Model，即开放式系统互联模型。它是世界上第一个试图在世界范围内规范网络标准的框架。
2、7层模型详解 OSI模型图示： 应用层
应用层位于OSI模型最上方 只关心业务逻辑，不关心数据传输 例如：张三给小花微信发送消息 表现层
负责协商用于传输的数据格式，并转换数据格式 会话层
负责管理两个连网实体间的连接 功能及特点：建立连接，维持通信，释放连接 传输层
负责将数据从一个实体（服务器或者应用）传输到另一个实体，但不负责数据传输的方式。 能力： 数据分隔重组：将数据拆分后按顺序重组 纠错：在数据传输过程中出现问题后采取方式进行纠正 管理连接：处理数据的频繁交换 流量控制：控制传输数据的速率 端口寻址：标明参与传输的实体的端口号 网络层
负责把一个封包从一个IP地址传输到另一个IP地址 思考：一个节点接收到一个封包之后，它怎么把这个封包传递到下个节点？ 路由算法 数据链路层
确保两个临近设备间数据的传输，并隐藏底层实现 帧同步：两个设备之间传输时的协商速率问题 数据纠错 物理层
封装和隐藏具体的传输手段，并且提供稳定的传输接口 比如：电缆、光纤、蓝牙等 3、OSI的问题 分层设计较为臃肿，并非每一层都为必要的，所以有了 应用层、表示层、会话层合为应用层</content></entry><entry><title>rsync数据同步备份工具</title><url>/post/5/</url><categories><category>Linux</category></categories><tags><tag>rsync</tag><tag>数据同步备份</tag></tags><content type="html"><![CDATA[  介绍rsync工具 rsync是什么：一款开源的，快速的，多功能的，可以实现全量和增量的本地或远程数据同步备份工具。
使用范围 : unix,linux,windows等多种操作系统
优点： 1、具有本地和远程两台主机之间数据快速复制同步，备份功能 2、能实现增量备份，具有独特的quick check算法
工作方式： 1、单个本机之间数据传输，类似于cp命令。 2、借助rcp,ssh通道传输数据，类似于scp。 3、以守护进程（socket）方式传输数据。
实践 示例：以虚拟机与本地机器（自己实体电脑）数据备份为例
简单说明：自己电脑内安装VirtualBox虚拟机通过共享文件的方式把虚拟机内产生的数据备份到自己电脑的磁盘上
环境：台式机一台，安装VirtualBox虚拟机
准备脚本(databak.sh)
/usr/bin/rsync --timeout=60 --progress --log-file=&#39;/opt/logs/rsync.log&#39; --log-file-format=&#39;%t %f %b&#39; -azvP /opt/all_data /media/sf_2/ 脚本命令解释：该命令使用rsync工具将/opt/all_data目录及其内容同步到/media/sf_2/目录。
具体参数解释如下：
&ndash;timeout=60：设置连接超时时间为60秒。 &ndash;progress：显示进度条。 &ndash;log-file=&rsquo;/opt/logs/rsync.log&rsquo;：将rsync的日志记录到/opt/logs/rsync.log文件中。 &ndash;log-file-format=&rsquo;%t %f %b&rsquo;：日志文件的格式为时间、文件名和字节大小。 -a 以递归方式传输文件，并保持所有文件的属性 -z 传输时进行压缩以提高传输效率 -v 详细模式输出 -P 显示同步的过程及传输时的进度等信息 crontab简单操作命令
crontab -l 查看 crontab -e 编辑 service crond restart 重启 crontab定时任务，数据备份命令 0 3 * * * /usr/bin/sh /opt/databak.sh &gt; /dev/null 2&gt;&amp;1 cron表达式解释：表示每天凌晨0点用shell执行/opt/databak.sh脚本，并将输出重定向到/null。
具体解释如下：
0：表示分钟数，即0分。 3：表示小时数，即0-23小时之间的第3个小时。 *：表示日期（月份、星期等）的通配符，表示每小时执行。 *：表示日期（月份、星期等）的通配符，表示每天执行。 &gt; /dev/null：将标准输出重定向到/null，即不输出任何结果。 2&gt;&amp;1：将错误输出重定向到标准输出，即仍然保留错误输出，只是不输出正常输出。   ]]></content></entry><entry><title>Linux下安装jupyter</title><url>/post/1/</url><categories><category>Linux</category></categories><tags><tag>jupyter</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  1.安装jupyter # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install jupyter 2.生成jupyter配置文件 # root用户： jupyter notebook –generate-config –allow-root # 非root用户 jupyter notebook –generate-config #输出信息：Writing default config to: /root/.jupyter/jupyter_notebook_config.py # 配置文件地址： /root/.jupyter/jupyter_notebook_config.py 3.打开ipython,生成密码 [root@hangzhi ~]# ipython In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: #此处输入密码 Verify password: #此处输入之前输入的密码 Out[2]: &#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; #这个秘钥要copy备用 4.修改配置文件 [root@hangzhi ~]# vi /root/.jupyter/jupyter_notebook_config.py # notebook服务会监听的IP地址 c.NotebookApp.ip = &#39;&#39; #工作目录，自己选定 c.NotebookApp.notebook_dir = &#39;/opt/jupyter/jupyter_work&#39; c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 #上面生成的秘钥 c.NotebookApp.password = u&#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; 5.启动jupyter # root用户 jupyter notebook –allow-root # 非root用户 jupyter notebook 后台启动脚本 # root用户 nohup jupyter notebook --allow-root &gt; /opt/logs/jupyter.log 2&gt;&amp;1 &amp; 停止脚本 #!/bin/bash #停止服务名称 SERVER_NAME=jupyter-notebook PIDS=`ps -ef | grep jupyter |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep jupyter` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34; 6.浏览器访问 ip:8888 即可访问了，需输入密码就可以   ]]></content></entry><entry><title>frp实现内网穿透详细配置</title><url>/post/8/</url><categories><category>Linux</category></categories><tags><tag>frp</tag><tag>内网穿透</tag></tags><content type="html"> 1、条件 需要一个有公网IP的云服务器（我的是腾讯云）
2、frp下载及介绍 (1)、 frp下载：https://github.com/fatedier/frp/releases 下载最新版，根据自己的服务器下载对应版本（我的是linux64系统）
wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gz (2)、解压压缩包
tar -zxvf frp_0.34.3_linux_amd64.tar.gz mv frp_0.34.3_linux_amd64 frpServer 包结构介绍： 服务器端：
frps： 服务器端服务启动文件 frps_full.ini： 启动配置文件（全版） frps.ini ：启动配置文件（简版） 客户端（Linux版）：
frpc ：客户端服务启动文件 frpc_full.ini ：启动配置文件（全版） frpc.ini ：启动配置文件（简版） 3、进入解压文件夹 cd frpServer 服务端配置及运行 1、修改端口，frps.ini文件
[common] bind_port = 9999 # bind_port是服务器的端口，我们最好不要使用默认端口 2、运行服务
直接运行： # frp解压文件夹目录下运行，也可以使用全路径 # 相对路径 ./frps -c frps.ini # 绝对路径 /opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini 后台运行： nohup ./frpc -c ./frpc.ini &amp;amp;amp; 3、配置系统启动时自动启动
在/lib/systemd/system文件夹下创建frps.service文件 编辑frps.service文件，输入以下内容(注：ExecStart 使用绝对路径 )： [Unit] Description=frp service After=network.target [Service] TimeoutStartSec=30 ExecStart=/opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini ExecStop=/bin/kill …</content></entry><entry><title>解决自己的云服务器经常被登录问题</title><url>/post/6/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag></tags><content type="html"> 解决过程 环境：腾讯centos云服务器
原因：每次登录云服务器时系统都会提示，这是被各种尝试登录导致的（简单说就是你的服务器被攻击了）
Last failed login: Tue Dec 29 21:06:17 CST 2020 from 182.78.163.21 on ssh:notty There were 6751 failed login attempts since the last successful login. Last login: Sat Dec 26 01:17:59 2020 from 120.230.83.193 解决办法：使用密钥登录可以解决
步骤如下：
1、生成ssh密钥
[root@hangzhi ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #此处直接回车就可以 Enter passphrase (empty for no passphrase): #设置解密钥密码 Enter same passphrase again: #再此输入一样密码确认 Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:9vRVtZ9uUUinLq+0byUMYDo8XZpZQ/t2iDbrGjcjMNc root@hangzhi The key&amp;#39;s randomart image is: +---[RSA 2048]----+ | .. . o| | o +o +o| | . + B..o.o| | = =..+ o+| | Soo Eo*oo| | . * o B+.o| | + B .= | | * =o | | ..+o. | +----[SHA256]-----+ 2、查看生成的密钥
[root@hangzhi ~]# cd /root/.ssh/ [root@hangzhi .ssh]# ll total 12 -rw-r--r--. 1 root root 0 Mar 7 2018 authorized_keys -rw------- 1 root root 1766 Dec 29 21:13 id_rsa #私钥 -rw-r--r-- 1 root root 394 Dec 29 21:13 id_rsa.pub #公钥 -rw-r--r-- 1 root root 176 Jan 6 2019 known_hosts 3、将公钥追加到authorized_keys文件中
[root@hangzhi .ssh]# cat id_rsa.pub &amp;gt;&amp;gt; /root/.ssh/authorized_keys 4、将权限改为只有当前用户可读可写，保证安全
[root@hangzhi .ssh]# chmod 600 authorized_keys 5、打开ssh的密钥登录功能
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys #将上面2行前面的注释去掉，然后保存 # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service 6、然后使用客户端配置密钥登录，如果成功接着下一步，不成功重复上面步骤
7、关闭ssh密码登录（注意：只有配置成功后才操作这个步，不然没成功关闭这个会导致不能登录服务器 ）
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config PasswordAuthentication yes 修改为: PasswordAuthentication no # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service</content></entry><entry><title>VirtualBox虚拟机导出及磁盘扩展</title><url>/post/4/</url><categories><category>Linux</category></categories><tags><tag>VirtualBox虚拟机</tag><tag>磁盘扩展</tag></tags><content type="html"> VirtualBox虚拟机导出 VirtualBox虚拟机的迁移除了复制还有一种通用方式是导出
复制的方式可以看之前写的：VirtualBox虚拟机迁移/复制（带快照）
简单方便的导出方式(推荐)，因为适用其他虚拟机,如:VMWare
VirtualBox虚拟机磁盘扩展 1.创建磁盘和添加磁盘
**对于创建时使用哪种磁盘文件，如下图介绍（我自己使用的VMDK）：** 2.查看能不能识别磁盘
3.对磁盘分区
fdisk /dev/sdb 选N进行分区 两个选项，e为分逻辑分区，p为主分区，（我选择的是p） 选1，说明是创建第一个分区，起始位置默认直接回车 下一个是让你选择究竟要分多大空间给这个分区，直接回车就默认全部分给他，单位按MB来算 选W 保存退出 4.查看分好区的磁盘
fdisk -l 查看 能看到/dev/sdb1了就ok 5.对分区好磁盘格式化
mkfs.ext4 /dev/sdb1 对这个分区进行格式化 格式化成ext4格式，如果你想其他格式就自己改 6.创建磁盘挂载的文件夹
mkdir /mnt/sdb1 （这个是要将硬盘挂载的地方，位置随意） 7.将挂载文件夹与磁盘关联
mount /dev/sdb1 /mnt/sdb1 （挂载这个硬盘到这个位置上） df -h就能看到硬盘了 8.设置开机自动挂载磁盘
vi /etc/fstab 让系统可以开机后自动将硬盘挂载上去 最后一行添加：/dev/sdb1 /mnt/sdb1 ext4 defaults 0 0 然后保存退出</content></entry><entry><title>启动和停止shell脚本</title><url>/post/2/</url><categories><category>Linux</category></categories><tags><tag>shell脚本</tag></tags><content type="html"><![CDATA[  start.sh 定义变量: 服务名/部署路径/服务输出日志路径/启动文件路径 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 没启动继续下面的 设置JVM参数: JAVA_OPTS 后台启动应用: nohup java -jar 命令 再次检查是否启动 shell脚本示例: #!/bin/bash #启动服务名称 SERVER_NAME=test #服务部署路径 DEPLOY_DIR=/opt/app/test # 服务日志输出路径 STDOUT_FILE=${DEPLOY_DIR}/logs/test.log #服务启动的jar或war WAR_FILE=${DEPLOY_DIR}/test.jar PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -n &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The ${SERVER_NAME} already started!&#34; echo &#34;&gt;&gt;&gt; PID: $PIDS&#34; exit 1 fi #jvm参数配置 JAVA_OPTS=&#34;-server -Xmx2g -Xms2g &#34; echo -e &#34;&gt;&gt;&gt; Starting the ${SERVER_NAME} ...\c&#34; nohup java $JAVA_OPTS -jar ${WAR_FILE} &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39; | wc -l` if [ $COUNT -gt 0 ]; then break fi done PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39;` echo &#34;OK ! --&gt;&gt;&gt; PID: $PIDS --&gt;&gt;&gt; STDOUT: $STDOUT_FILE &#34; stop.sh 定义变量: 部署服务路径/停止服务名称 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 启动继续下面的 kill掉进程 再次检查进程是否存在 shell脚本示例: #!/bin/bash #服务部署路径 DEPLOY_DIR=/opt/app/test #停止服务名称 SERVER_NAME=test PIDS=`ps -ef | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep java` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34;   ]]></content></entry><entry><title>VirtualBox虚拟机迁移/复制（带快照）</title><url>/post/3/</url><categories><category>Linux</category></categories><tags><tag>VirtualBox虚拟机</tag></tags><content type="html"> 本次虚拟机迁移是基于VirtualBox虚拟机，如果要尝试安装和创建虚拟机可以去搜索：virtualbox的安装与使用、安装镜像创建虚拟机
一、VirtualBox的结构介绍 xxx.vdi : 这个文件是磁盘映像，创建虚拟机的时候创建的
xxx.vbox 和 xxx.vbox-prev：这个两文件虚拟机的配置文件，记录了所以配置信息，如快照，虚拟磁盘等，核心文件是.vbox文件
xxx.vmdk : 这个文件是虚拟机磁盘，是用来扩展机器存储空间，创建虚拟机一般是没有次文件的
{UUID}.vdi ：磁盘映像文件的快照
{UUID}.vmdk : 虚拟机磁盘文件的快照
注：迁移有风险，迁移时要多细心
二、不带快照 1、迁移到不同机器 迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到不同机器，由于是在不同的机器上进行迁移，是不涉及到镜像文件的UUID相同情况，因此比较简单，只需要打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
在新机器上的VirtualBox软件中注册刚修改的文件，有.vmdk 文件也需要注册，否则不注册。如下图：
新机的迁移就这么简单完成了。
2、迁移到本机机器不同目录 迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到本机机器不同目录，由于是在本机机器上进行迁移，涉及到镜像文件的UUID相同情况，因此需要分两步走：一是修改文件路径，二是修改文件UUID
修改文件路径：打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
修改文件UUID：将.vdi、.vmdk(没有这个文件，可以忽略)文件重新生成UUID
VirtualBox软件安装目录下执行如下命令重新生成UUID
// 重新生成centos7(two).vdi的UUID VBoxManage internalcommands sethduuid &amp;amp;#34;F:\VirtualBox\centos7(two)\centos7(two).vdi&amp;amp;#34; // 重新生成sda7.vmdk的UUID VBoxManage internalcommands sethduuid …</content></entry></search>