<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Hibernate入门：轻松掌握Java持久化技术</title><url>/post/61/</url><categories><category>Java库</category></categories><tags><tag>Hibernate入门</tag></tags><content type="html"><![CDATA[  介绍Hibernate这个强大的Java持久化库，学会Hibernate的核心概念和技巧，快速入门并掌握基本使用方法和高级功能。
1、Hibernate是什么 Hibernate是一个开源的Java持久化框架，它对JDBC进行了封装，让开发者只需要使用简单的Java对象和配置文件，就可以轻松地实现数据持久化操作。
Hibernate不仅简化了数据库操作，还提供了许多高级功能，如关联映射、事务管理、缓存机制等。
2、Hibernate的核心概念 1.实体类（Entity）：实体类是映射到数据库表的Java类，它包含了与表结构相对应的属性和方法。
2.映射文件（Mapping）：映射文件是用来描述实体类与数据库表之间关系的XML文件，它定义了实体类属性与数据库字段之间的映射关系。
3.会话（Session）：会话是Hibernate的核心接口，它代表了与数据库的连接，并负责执行数据库操作。
4.查询（Query）：Hibernate提供了一种面向对象的查询语言（HQL），通过会话对象可以执行HQL查询，并将查询结果映射为Java对象。
3、Hibernate的基本操作 1.添加数据
要向数据库中添加数据，需要创建一个实体类，编写映射文件，通过会话执行插入操作。
（1）创建实体类User.java
public class User { private Integer id; private String name; private Integer age; // 省略 getter 和 setter 方法 } （2）编写映射文件User.hbm.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE hibernate-mapping PUBLIC &amp;#34;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;#34; &amp;#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&amp;#34;&amp;gt; &amp;lt;hibernate-mapping&amp;gt; &amp;lt;class name=&amp;#34;User&amp;#34; table=&amp;#34;users&amp;#34;&amp;gt; &amp;lt;id …  ]]></content></entry><entry><title>MyBatis入门：让 Java 数据库操作更简单</title><url>/post/60/</url><categories><category>Java库</category></categories><tags><tag>MyBatis入门</tag></tags><content type="html"><![CDATA[  MyBatis是一个优秀的 Java 库，用于简化数据库操作。
本文将介绍 MyBatis 的基本概念、特点和使用方法，并通过示例展示如何使用 MyBatis 完成常见的数据库操作。
1、MyBatis 简介 MyBatis 是一个半ORM（对象关系映射）框架，它允许开发者通过简单的 XML 或注解来配置 SQL 语句，并将 SQL 语句与 Java 对象的方法关联起来。
MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的工作。
MyBatis 可以使用简单的 XML 或注解来配置和原始映射，将接口和 Java 的 POJOs（Plain Old Java Objects，普通的 Java 对象）映射成数据库中的记录。
2、MyBatis 特点 1.简单易学：MyBatis 的学习曲线较低，只需掌握基本的 SQL 语句和 Java 编程知识，就可以轻松上手。
2.灵活性：MyBatis 允许开发者自定义 SQL 语句，满足各种复杂的业务需求。
3.高效性能：MyBatis 的执行效率较高，因为它避免了 JDBC 的繁琐操作，并且可以通过缓存机制提高查询效率。
4.支持多种数据库：MyBatis 支持包括 MySQL、Oracle、SQL Server 在内的多种数据库。
3、MyBatis 使用方法 1.添加依赖,在项目的 pom.xml 文件中添加 MyBatis 的依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;!-- MyBatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.10&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL 驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.19&amp;lt;/version&amp;gt; …  ]]></content></entry><entry><title>一篇文章带你入门Fastjson2：Java库的“闪电”解析</title><url>/post/59/</url><categories><category>Java库</category></categories><tags><tag>Fastjson2入门</tag></tags><content type="html"><![CDATA[  介绍一个Java编程中非常实用的库——Fastjson2。
Fastjson2是一个由我国阿里巴巴团队开发的高效JSON解析库，它能够让你在处理JSON数据时，体验到飞一般的感觉。
1、Fastjson2的背景 在互联网开发领域，JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。
由于其简洁易读的特点，JSON成为了网络数据传输的事实标准。
当时在Java中处理JSON数据并不总是那么容易。为此Fastjson应运而生，它旨在简化Java开发者处理JSON数据的复杂度，提高处理速度。
Fastjson2是Fastjson项目的重要升级，与Fastjson1相比，性能有非常大的提升。
性能远超过其他流行JSON库，包括jackson/gson/org.json，
性能数据: https://github.com/alibaba/fastjson2/wiki/fastjson_benchmark 2、Fastjson2的特点 速度快：Fastjson2的解析速度非常快，比其他库如Jackson和Gson要快得多。 易使用：Fastjson2的API简单易用，你几乎可以无脑使用它。 功能全：Fastjson2支持各种复杂类型的JSON处理，包括泛型、枚举等。 可扩展：Fastjson2允许你自定义序列化和反序列化规则。 支持JDK新特性 完善的JSONPath支持，支持SQL:2016的JSONPath语法 支持Android 8+，客户端和服务器一套API 支持JSON Schema 3、Fastjson2的使用 1.添加依赖,在你的项目中添加Fastjson2的依赖。如果你使用Maven，可以在pom.xml文件中添加以下代码：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba.fastjson2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;fastjson2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.44&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.JSON字符串转Java对象
public class Test1 { public static void main(String[] args) …  ]]></content></entry><entry><title>Java开发者必备：一款神器Dozer，让你轻松实现对象属性映射！</title><url>/post/30/</url><categories><category>Java库</category></categories><tags><tag>Dozer</tag></tags><content type="html"><![CDATA[  介绍一款Java领域内广泛使用的数据映射库——Dozer。
通过本文你将了解到Dozer的基本概念、使用方法和应用场景，更有详细的示例代码助你快速上手！
1、Dozer简介 Dozer是一个用于Java对象的映射工具，它可以帮助我们轻松地将一个对象的属性映射到另一个对象的对应属性。
在Java开发过程中，我们经常需要处理对象之间的转换和映射，而手动编写这些转换逻辑既繁琐又容易出错。
Dozer为我们提供了一种自动化、高效的方式来解决这个问题。
2、Dozer的核心概念 1.映射器（Mapper）：Dozer通过映射器来实现对象之间的映射。我们可以自定义映射器，也可以使用Dozer提供的默认映射器。
2.类型映射（Type Mapping）：Dozer支持基本数据类型、包装类、自定义对象等多种类型的映射。
3.属性映射（Property Mapping）：Dozer可以根据对象属性的名称、getter方法或setter方法来自动匹配映射关系。
4.复杂映射（Complex Mapping）：Dozer还支持嵌套映射、集合映射等复杂场景。
3、Dozer的使用方法 1.添加依赖，需要在项目的pom.xml文件中添加Dozer的依赖：
&amp;lt;dependencies&amp;gt; &amp;lt;!-- Dozer依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;net.sf.dozer&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;dozer&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 2.创建映射器
创建一个Java类，并继承Dozer的Mapper接口。然后重写接口中的映射方法，实现自定义的映射逻辑。
import org.dozer.Mapper; import org.dozer Mapping; @Mapper public class MyMapper { @Mapping(source = &amp;#34;name&amp;#34;, target = &amp;#34;name&amp;#34;) public MyObject map(MyObject source) { …  ]]></content></entry><entry><title>ASM：深入Java字节码的世界，小白也能轻松掌握</title><url>/post/29/</url><categories><category>Java库</category></categories><tags><tag>字节码</tag></tags><content type="html"><![CDATA[  你是否曾在Java开发中遇到需要对字节码进行操作的需求？
是否为了实现某个功能而不得不深入研究Java字节码的奥秘？
如果是的话，那么你可能会感兴趣我要介绍的Java库——ASM。
ASM是一个强大的Java字节码操作库，它可以帮助我们轻松地读取、修改和生成Java字节码。
无论你是小白还是有一定基础的开发者，ASM都能为你带来极大的便利。
一篇关于ASM的入门介绍，让你轻松掌握这个强大的Java库。
1、ASM简介 ASM是一个用Java编写的库，主要用于分析和操作Java字节码。
通过ASM我们可以读取Java字节码文件，了解其结构，修改字节码以满足我们的需求，甚至可以生成全新的字节码文件。
ASM提供了丰富的API，使我们能够以编程的方式操作字节码，极大地提高了我们的工作效率。
2、ASM的核心组件 ClassReader：用于读取Java字节码文件，并获取其对应的Class对象。 ClassWriter：用于生成Java字节码文件，我们可以通过ClassWriter将修改后的字节码写入到新的文件中。 MethodVisitor：用于访问Java方法，包括方法的参数、返回值、异常等信息。 FieldVisitor：用于访问Java字段，包括字段的类型、修饰符等信息。 AnnotationVisitor：用于访问Java注解。 ConstructorVisitor：用于访问Java构造器。 3、ASM的使用示例 我将通过一个简单的示例，展示如何使用ASM来读取和修改Java字节码。
1.我们需要添加ASM的依赖。如果你使用Maven，可以在pom.xml文件中添加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.ow2.asm&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;asm&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;9.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.创建一个简单的Java类，例如：
public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;#34;Hello, World!&amp;#34;); } } 3.编 …  ]]></content></entry><entry><title>一窥Dozer的Java库：让Java对象映射更轻松</title><url>/post/28/</url><categories><category>Java库</category></categories><tags><tag>Dozer</tag></tags><content type="html"><![CDATA[  尽管各种新兴技术层出不穷，Java仍然稳居开发语言的前沿。
然而Java的对象映射问题一直让许多新手程序员头疼。
我要介绍的是拯救诸位于此困扰的利器——Dozer。
1、Dozer是什么？ Dozer是一个强大、简单易用的Java Bean到Java Bean映射工具，它使用Java反射API进行动态映射。
不论是同名属性映射，深层对象映射，或者是复制不同类型的对象都处理得游刃有余。
2、Dozer的优势 1、在源目标与目标类名称和字段名称相同时，能自动将值从一方映射到另一方。
2、对于字段类型不同的映射，它也能妥善应对。
3、提供了丰富的API，还支持自定义转换器，让你的映射更加自如。
3、使用Dozer 保持简洁的原则，我们用一段代码示例来看看如何使用Dozer。
1、需要在工程中引入Dozer。
&lt;dependency&gt; &lt;groupId&gt;com.github.dozermapper&lt;/groupId&gt; &lt;artifactId&gt;dozer-core&lt;/artifactId&gt; &lt;version&gt;6.5.0&lt;/version&gt; &lt;/dependency&gt; 2、创建两个Java Bean对象，Person和Employee。
public class Person { private String name; private int age; //...getter和setter } public class Employee { private String name; private int age; //...getter和setter } 3、实操使用：实现Person对象到Employee对象的映射了。
// 创建DozerBeanMapper对象 Mapper mapper = DozerBeanMapperBuilder.buildDefault(); Person p = new Person(); p.setName(&#34;小白&#34;); p.setAge(25); Employee e = mapper.map(p, Employee.class); System.out.println(e.getName()); System.out.println(e.getAge()); //以上代码能够成功地输出“小白”和“25”，证明映射工作已经成功地完成了。 ▽ 通过Dozer我们能够更快、更轻松地完成Java对象的映射。
不论是编程新手，还是在Java道路上已经走过一段距离的朋友，都可以使用一下这个强大的工具更快、更轻松地完成编程任务，可少加班早点下班。
良好的工具能够提升编程效率，让你有更多时间去处理更重要的事情。
希望Dozer能够为你的Java之路提供便利，让你的编程任务都能够如你所愿，甚至超出你的预期，让你的人生与代码都无往不利！
开源地址： https://github.com/DozerMapper/dozer   ]]></content></entry><entry><title>Guava：一款强大的Java库，让你的开发更高效</title><url>/post/27/</url><categories><category>Java库</category></categories><tags><tag>Guava</tag></tags><content type="html"><![CDATA[  Guava是一款由Google开源的Java库，提供了丰富的工具类和扩展类，帮助我们解决日常开发中遇到的各种问题。
本文将详细介绍Guava库的特点、常用工具类及其使用方法，让小白读者轻松上手。
1、Guava简介 Guava是一款由Google开源的Java库，旨在为Java开发者提供一系列便捷的工具类和扩展类，以提高开发效率。
Guava包含了很多实用的工具类，如集合类（multisets、multimaps、tables等）、数式编程风格（通过supplier、function、predicate、optional等实现）、缓存（CacheLoader和CacheBuilder等）、支持原生的Java类型、事件总线以及并发库扩展等，可以帮助我们轻松应对日常开发中的各种挑战。
2、Guava的安装与使用 1.添加依赖 要使用Guava库，需要在项目中添加其依赖。如果你使用Maven进行项目管理，可以在pom.xml文件中添加以下依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;31.0.1-jre&amp;lt;/version&amp;gt; &amp;lt;!-- 请根据实际版本进行替换 --&amp;gt; &amp;lt;/dependency&amp;gt; 如果你使用Gradle，可以在build.gradle文件中添加以下依赖：
dependencies { implementation &amp;#39;com.google.guava:guava:31.0.1-jre&amp;#39; // 请根据实际版本进行替换 } 2.使用Guava工具类 Guava提供了很多实用的工具类，下面将介绍几个常用的工具类及其使用方法。
(1).增强java集合功能
Guava库向我们提供了一些更加丰富的集合类，比如诸如ImmutableSet、ImmutableList、ImmutableSortedSet、ImmutableMap以及更为泛化和强大的Multiset（可以存储相同元素的集合）、BiMap（可以将两个键映射到一个值）、Table（可以将一个键映射到另一个键的值）等。
(2).字符串处理
Guava库提供 …  ]]></content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 编程之路 一枚不起眼有着梦想爱读书的程序猿，记录自己的编程小技巧分享。
编程之路，探索智慧的无尽旅程。
在这条路上，小猿编程秘籍解锁创新，磨砺思维，不断超越。
编程，开启你的未来可能。
其他渠道： Github 掘金 知乎 CSDN 公众号：小猿编程秘籍</content></entry><entry><title>计算机网络：面试真题实战</title><url>/post/25/</url><categories><category>计算机网络</category></categories><tags><tag>面试真题实战</tag></tags><content type="html"> 1、面试真题问答 以下问题都是基于之前写的计算机网络系文章做出简单问答
问1：TCP/IP协议群做了哪些事情？
1、报文拆分 2、增加协议头 3、数据传输 4、路由和寻址 5、数据重组 问2：TCP协议为什么是3次握手4次挥手？
3次握手 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 4次分手 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 问3：IPv4和Ipv6的区别？
地址不同：Ipv4 32位；Ipv6 128位 （地址空间、数目不同）。 地址分配不同：IPv4资源是稀缺的，分配需要竞争；IPv6可以给每个人分配很多地址。 寻址方式不同：IPv4通过子网掩码计算网络地址；IPv6有固定的计算方式划分网络。 地址解析策略不同：IPv4需要ARP；IPv6通过无状态的邻居发现。 DNS不同：IPv4是A记录；IPv6是AAAA记录。 问4：TCP和UDP的区别？
传输：TCP面向流；UDP面向报文 连接：TCP有会话；UDP无会话 头部开销：TCP开销大；UDP开销小 可靠性：TCP保证数据可靠到达；UDP不保证数据可靠到达 场景：TCP适合保证数据完整到达场景，如：文件传输；UDP适合随时发送数据，不要求数据完整到达场景，如：广播通信 问5：TCP如何确保数据顺序？ 为什么需要保证：TCP拆分封包的时候是顺序拆分的，但是包会无序的到达目的地。 方法1：利用(SEQ, ACK)编号确定封包的唯一性 方法2：利用滑动窗口存放没有排好序的封包，直到窗口中完全有序才发送ACK。如果有包丢失，就会一直不发ACK。 如果窗口大小是4，发送ABCD，如果只有BD到目的地，那么滑动窗口中是_B_D。
问6：如果网络延迟是30ms，那么Ping一个网站需要多少ms? 如果请求一个HTTPS协议的网站，TTFB至少ms? 问7：LRU是什么？ 缓存置换：缓存满了后，每次创建新的缓存条目，就会删除旧的缓存条目。 问8：什么是https中间人攻击? 问9：NIO有什么优势？
Reactive模型+非阻塞(减少线程切换） 内核级别拷贝内存到JVM（减少系统调用） …</content></entry><entry><title>计算机网络：同源策略</title><url>/post/24/</url><categories><category>计算机网络</category></categories><tags><tag>同源策略</tag></tags><content type="html"><![CDATA[  1、介绍 同源策略：禁止一个源(origin)的脚本和文档和另一个源的脚本和文档交互。 什么是同源：两个URL的协议(protocol)、端口(port)和域名(domain)都相同，这就是同源。 同源策略的目的：防止恶意的网站窃取用户的cookie，或者其他敏感信息。 同源策略的实现：浏览器会在同源的情况下，允许脚本和文档进行交互。 同源策略的限制：不能读取对方的cookie、localStorage、sessionStorage、indexedDB、webSocket、EventSource、XMLHttpRequest、location、history 等等。 2、问题回答 问1：如果两个源产生过多交互会有什么影响？ 影响很大的就是恶意的网站窃取用户的cookie，或者其他敏感信息。这样数据就不安全了，所以同源策略是非常重要的。
问2：应不应该允许网站提交cookie到不同源的服务器？ 这个是不允许的，但是你自己配置了跨域是可以的。
问3：为什么不禁用不同源的js？ 因为有些js是第三方提供的，我们引用cdn的js，引用组件。
问4：应不应该允许不同源的js修改dom？ 这个是允许的，比如百度统计，百度地图等，如果不允许不同源的js修改dom，那么就无法统计用户的地理位置，无法使用百度地图等功能。
问5：应不应该允许不同源的js获取远程图片内容？ 这个是不允许的，如果能远程执行代码，那么就有可能获取到敏感信息和人家私密数据，这个肯定不行的。
问6：应不应该允许网站提交数据到不同源的服务器？ 这个是不允许的，如果能提交数据，那么就会被别人收集你的数据，然后提交到自己的服务器上，这等于抢劫，不劳而获，这个也肯定不行的。
3、跨域请求技术 Jsonp技术
Jsonp的原理：就是利用script标签的src属性没有跨域限制来实现的。
Jsonp的优缺点：
缺点：只能get请求 优点：浏览器的兼容性好 Jsonp的实现及应用：
模拟服务端： server.js ，启动方式: node server.js （需要安装node.js）
//模拟服务端 let http = require(&amp;#34;http&amp;#34;) let url = require(&amp;#34;url&amp;#34;) //模拟数据 let data; http.createServer((req, res) …  ]]></content></entry><entry><title>计算机网络：加密和解密</title><url>/post/23/</url><categories><category>计算机网络</category></categories><tags><tag>加密和解密</tag></tags><content type="html"> 1、加密 概念：将明文信息变成不可读的密文内容，只有拥有解密方法的对象才能够将密文还原成加密前的内容。 举例子： 说明：例子中&amp;quot;每隔3个取1个字符解读&amp;quot;相当于秘钥。将加密后的密文通过秘钥还原为明文，这就是解密 2、加密解密算法 对称加密：加密/解密用一个秘钥，且加密方和解密方都知道秘钥，如DES,3DES等。 非对称加密：加密用一个秘钥，解密用另一个秘钥且加密方一般有2个秘钥，解密方有一个解密秘钥。非对称加密安全性高，但速度慢，如RSA算法。 摘要算法：摘要算法是一种特殊的加密算法，它接收任意长度的数据，并输出固定长度的消息摘要作为结果。就是将原文和摘要同时传输给接收方。 摘要算法3特点：公开、一致、难碰撞 场景举例 在现在互联网时代，各种数据都是非常重要的，数据的保护不言而喻。
那涉及到数据加密和解密的场景在生活中处处都有，比如：
密码保存 数据传输 互联网信任体系 A和B私下签协议
数字签名过程： 验证签名过程： 权威机构证书
A和B都去第三方机构注册账号，然后上传自己的公钥给第三方机构。 第三方机构可以给A和B办法一个证书，证书里含有他们的公钥。 信任链条
情况1：B机器上有预装证书，B和A签约的时候，就会用这个预装的根证书验证A证书的签名，要使用权威机构的公钥（而公钥在证书里）。 情况2：B机器上没有预装证书，而是预装了给权威机构颁发证书的机构的证书。 信任体系里面存在的漏洞
B安装盗版操作系统，系统中含有恶意机构的CA 黑客发的邮件，点击后安装CA</content></entry><entry><title>计算机网络：Linux网络指令</title><url>/post/22/</url><categories><category>计算机网络</category><category>Linux</category></categories><tags><tag>Linux网络指令</tag></tags><content type="html"> 1、ssh/scp ssh
概念：Secure Shell（安全外壳），安全外壳是一种网络安全技术，它为网络服务提供安全的远程登录和传输，它是一种加密的传输协议。 ssh加密通信原理： 客户端向服务器发送加密的登录请求，服务器验证用户的身份，并向客户端发送公钥。 客户端使用公钥加密登录信息，并发送给服务器。 服务器使用自己的私钥解密登录信息，并与用户的信息进行比较。 若信息匹配，则建立加密通道，并开始传输数据。 若信息不匹配，则拒绝登录。 查看命令使用手册： ssh --help man ssh 命令：ssh [选项] [user@]hostname [command] 常用的选项： -p：指定远程主机的端口号，默认是22。 -l：指定登录用户名，如果不指定，使用本地登录用户名。 -C：压缩传输数据。 -i: 指定私钥文件。 -4：使用IPv4地址进行通信。 -6: 使用IPv6地址进行通信。 scp
概念：Secure Copy（安全复制），安全复制是一种在网络上进行文件传输的安全方式。 查看命令使用手册： scp --help man scp 命令：scp [选项] [user@]hostname:file1 [user@]hostname:file2 常用的选项： -P：指定远程主机的端口号，默认是22。 -r：递归复制整个目录。 -C: 压缩传输数据。 -p：保留远程文件的修改时间、访问时间和权限。 -i：指定私钥文件。 -4：使用IPv4地址进行通信。 -6：使用IPv6地址进行通信。 三种传输方式： 本地文件到远程文件：scp file1 user@hostname:file2 远程文件到本地文件：scp user@hostname:file1 file2 源和目标都为远程文件：scp user@hostname:file1 user@hostname:file2 2、ifconfig/netstat ifconfig
概念：网络接口配置工具，用于配置和显示网络接口的各种参数。 查看命令使用手册： ifconfig --help man ifconfig 命令：ifconfig [网络接口] [选项] 常用的网络接口： up：启动网络接口 down：停止网络接口 inet [IP地址]：设置网络接口的IP地址 netmask [子网掩码]：设置网络接口的 …</content></entry><entry><title>计算机网络：HTTP协议入门</title><url>/post/21/</url><categories><category>计算机网络</category></categories><tags><tag>HTTP协议</tag></tags><content type="html"> 1、起源 1990年伯纳斯.李，发明了万维网(WWW)，写了第一个Web Server HTTP协议：浏览器和Web Server之间通信的协议 2、定义 HTTP协议(Hyper Text Transfer Protocol): 应用层协议 目标: 是处理客户端和服务端之间的通信 3、请求/响应 请求
一次请求，分成头(Header)和体(Body)。 下面是一个请求头+消息体的 响应
一次返回，也同样分(Header)和体(Body)。 下面是一个返回头+消息体 4、请求头/响应头 HTTP协议通过请求头和返回头控制协议工作。无论是请求头还是返回头都是Key/Value的形式。 常见头部 Content-Length：发送/接收Body内容的字节数。 User-Agent：这个字段可以帮助统计客户端用了什么浏览器、操作系统等 Content-Type：请求的时候，告知服务端数据的媒体类（MediaType/MIME Type)。返回的时候告知客户端，数据的媒体类型。 Origin：描述请求来源地址 Accept：是HTTP协议协商能力的体现，用于建议服务端返回何种媒体类型(MIME Type) Referer：告诉服务端打开当前页面的上一张页面的URL，非浏览器环境有时候不发送Referer（或者虚拟Referer,通常是爬虫)，常用于用户行为分析 Connection：决定HTTP连接（不是TCP连接）是否在当前事务完成后关闭。（Http1.0 默认是 close ，Http1.1 后默认是 keep-alive） 5、HTTP的方法和状态码 方法 GET：从服务器获取资源 POST：在服务器创建资源(幂等性) PUT：在服务器修改资源 DELETE：在服务器删除资源 OPTION ：跨域部分讲解 TRACE ：用于显示调试信息 多数网站不支持 CONNECT： 代理部分讲解 PATCH ：对资源进行部分更新(极少用) 状态码 1xx：提供信息 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务端错误 注： 常用状态码速查表 6、HTTP缓存 HTTP缓存最重要的配置项为Cache-Control HTTP 返回头。 不仅浏览器可以缓存，浏览器和服务器之间的HTTP代理服务器也可以缓存。 7、代理服务器 概念：代理服务器接收一个请求，然后把请求转发 …</content></entry><entry><title>计算机网络：Socket编程-NIO进行优化</title><url>/post/20/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写了计算机网络：Socket编程-多线程优化和请求响应对象封装，
有留心的伙伴就会发现，我先是简单写了一个HTTP服务，然后对这个HTTP服务进行面向对象封装，接着又在封装的基础上进行多线程的优化和请求响应对象的封装，这样一步一步的由简入深。
这篇也是继续深入优化，之前的代码都是使用ServerSocket这个类，从代码中可以看出，它是每个请求都需要单独的线程进行处理，ServerSocket是基于阻塞I/O模型。那有没有非阻塞模式类？
有的，Java NIO库中提供了ServerSocketChannel这个类，它是通过Selector来管理多个通道的，一个线程可以处理多个请求。
1、NIO 过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将Socket注册到Selector中，也将内容信息存入Buffer中，放入Channel中）-&gt; 7（工作线程通过响应式获取Channel里的信息）-&gt; 8（工作线程先读取Channel信息，处理完请求后将相关信息写入Buffer，通过Channel再传递给内核）-&gt; 9（内核监听到Socket文件写入信息然后再返回给请求方）
代码实现 package com.hh.http; import java.io.*; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Iterator; import java.util.Set; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * NIO进步优化 * * @author hang.yuan 2022/3/8 19:50 */ public class HttpServer4 { ServerSocketChannel ssc; public void listen(int port) throws IOException { ssc = ServerSocketChannel.open(); ssc.bind(new InetSocketAddress(port)); // Reactive / Reactor ssc.configureBlocking(false); Selector selector = Selector.open(); ssc.register(selector,ssc.validOps(),null); ByteBuffer buffer = ByteBuffer.allocate(1024*16); for(;;){ int numOfKeys = selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator(); while (it.hasNext()){ SelectionKey key = it.next(); if (key.isAcceptable()){ SocketChannel channel = ssc.accept(); if (channel == null){ continue; } // Kernel --&gt; mmap(buffer) --&gt; Channel --&gt; User(buffer) channel.configureBlocking(false); channel.register(selector,SelectionKey.OP_READ); }else { SocketChannel channel = (SocketChannel)key.channel(); //_ _ _ _ _ _ _ // P(position) // L buffer.clear(); channel.read(buffer); String request = new String(buffer.array()); //Logic ... buffer.clear(); buffer.put(&#34;HTTP/1.1 200 ok\n\nHello NIO!\n&#34;.getBytes()); // H T T P / 1 ... ! _ _ // P(L) // P L buffer.flip();//就是把指针反过来 channel.write(buffer); channel.close(); } } } } public static void main(String[] args) throws IOException { HttpServer4 server = new HttpServer4(); server.listen(8000); } } 自己也可以学着前几篇用ServerSocket写的HttpServer类优化步骤，依葫芦画瓢一样对ServerSocketChannel写的HttpServer类进一步优化，
  ]]></content></entry><entry><title>计算机网络：Socket编程-多线程优化和请求响应对象封装</title><url>/post/19/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写了计算机网络：Socket编程-面向对象封装，然后以下基于之前的代码进一步进行多线程优化和请求响应对象封装。
1、多线程优化 对之前面向对象封装的代码，添加多线程优化，代码实现：
package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * 加入多线程优化 * * @author hang.yuan 2022/3/8 18:50 */ public class HttpServer3 { ServerSocket serverSocket; Function&lt;String,String&gt; handler; ExecutorService executorService; public HttpServer3(Function&lt;String, String&gt; handler) { this.handler = handler; this.executorService = Executors.newFixedThreadPool(10); } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } void accept() throws IOException { // Blocking ... Socket socket = serverSocket.accept(); // 多线程工作 executorService.execute(()-&gt;{ try{ this.handler(socket); }catch (IOException e){ e.printStackTrace(); } }); } public void handler(Socket socket)throws IOException { try{ // Thread --&gt; Sleep --&gt; Other Threads System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String response = this.handler.apply(request); bufferedWriter.write(response); bufferedWriter.flush(); socket.close(); }catch (IOException e){ e.printStackTrace(); } } public static void main(String[] args) throws IOException { HttpServer3 server = new HttpServer3(req -&gt; { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } return &#34;HTTP/1.1 201 ok\n\nGood!\n&#34;; }); server.listen(8000); } } 2、Request和Response对象封装 代码进行多线程优化后，进一步对请求（Request）和响应（Response）对象的封装
HttpServer对象 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.Map; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.function.Function; /** * Request/Response 进步抽象 * * @author hang.yuan 2022/3/8 18:50 */ public class HttpServer31 { ServerSocket serverSocket; IHandlerInterface handler; ExecutorService executorService; public HttpServer31(IHandlerInterface handler) { this.handler = handler; this.executorService = Executors.newFixedThreadPool(5); } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } void accept() throws IOException { // Blocking ... Socket socket = serverSocket.accept(); executorService.execute(()-&gt;{ try{ this.handler(socket); }catch (IOException e){ e.printStackTrace(); } }); } public void handler(Socket socket)throws IOException { Request request = new Request(socket); Response response = new Response(socket); this.handler.handler(request,response); } public static void main(String[] args) throws IOException { HttpServer31 server = new HttpServer31((req,resp)-&gt;{ System.out.println(req.getHeaders()); resp.send(&#34;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Hello Word&lt;/H1&gt;&lt;/body&gt;&lt;/html&gt;&#34;); }); server.listen(8000); } } 逻辑处理接口 package com.hh.http; import java.io.IOException; /** * 接口 * * @author hang.yuan 2022/3/8 20:07 */ @FunctionalInterface public interface IHandlerInterface { void handler(Request request, Response response) throws IOException; } Request对象 package com.hh.http; import org.apache.commons.httpclient.Header; import org.apache.commons.httpclient.HttpParser; import java.io.*; import java.net.Socket; import java.util.HashMap; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 请求 * * @author hang.yuan 2022/3/8 19:21 */ public class Request { static Pattern methodRegex = Pattern.compile(&#34;(GET|POST|PUT|DELETE|OPTIONS|TRACE|HEAD)&#34;); private final String body; private final String method; private final Map&lt;String, String&gt; headers; public Request(Socket socket) throws IOException { InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String methodLine = HttpParser.readLine(inputStream, &#34;UTF-8&#34;); Matcher matcher = methodRegex.matcher(methodLine); matcher.find(); String method = matcher.group(); Header[] headers = HttpParser.parseHeaders(inputStream, &#34;UTF-8&#34;); Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for (Header header : headers) { map.put(header.getName(),header.getValue()); } BufferedReader bufferedReader1 = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder sb = new StringBuilder(); char[] buffer = new char[1024]; while (inputStream.available()&gt;0){ bufferedReader1.read(buffer); sb.append(buffer); } this.body= sb.toString(); this.method=method; this.headers=map; } public String getBody() { return body; } public String getMethod() { return method; } public Map&lt;String, String&gt; getHeaders() { return headers; } } Response对象 package com.hh.http; import java.io.BufferedWriter; import java.io.IOException; import java.io.OutputStreamWriter; import java.net.Socket; import java.util.HashMap; import java.util.Map; /** * 响应 * * @author hang.yuan 2022/3/8 19:22 */ public class Response { Socket socket; private int status = 200; static Map&lt;Integer,String&gt; codeMap; public Response(Socket socket) { this.socket=socket; if (codeMap == null){ codeMap= new HashMap&lt;&gt;(); codeMap.put(200,&#34;OK&#34;); } } public void send(String msg) throws IOException { String resp = &#34;HTTP/1.1 &#34;+this.status+&#34; &#34;+ this.codeMap.get(this.status)+&#34;\n&#34;; resp += &#34;\n&#34;; resp += msg; this.sendRaw(resp); } public void sendRaw(String msg) throws IOException { BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(msg); bufferedWriter.flush(); socket.close(); } }   ]]></content></entry><entry><title>计算机网络：Socket编程-面向对象封装</title><url>/post/18/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  上篇写的 计算机网络：Socket编程-实现HTTP服务 来进行面向对象封装
1、代码实现 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.util.function.Function; /** * 面向对象封装 * * @author hang.yuan 2022/3/8 18:30 */ public class HttpServer2 { ServerSocket serverSocket; Function&lt;String,String&gt; handler; public HttpServer2(Function&lt;String, String&gt; handler) { this.handler = handler; } public void listen(int port) throws IOException { serverSocket = new ServerSocket(port); while (true){ this.accept(); } } public void accept() { try{ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = serverSocket.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); String response = this.handler.apply(request); bufferedWriter.write(response); bufferedWriter.flush(); socket.close(); }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) throws IOException { HttpServer2 server = new HttpServer2( req -&gt; { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } return &#34;HTTP/1.1 201 ok\n\nGood!\n&#34;; }); server.listen(8000); } } 2、测试 测性能工具 ab 开始测试 结果 使用更大的并发测试，发现Pending Queue被占满，直接拒绝请求了   ]]></content></entry><entry><title>计算机网络：Socket编程-实现HTTP服务</title><url>/post/17/</url><categories><category>计算机网络</category></categories><tags><tag>Socket编程</tag></tags><content type="html"><![CDATA[  1、目标 不用框架利用Socket编程实现一个HTTP服务框架 2、线程模型 图示： 1、操作系统接受到外部请求时，会把请求放到Pending Queue里面，慢慢积累，如果 Pending Queue被占满时，这里会发生拒绝请求；
2、某一时刻某个线程会触发Accept的系统调用，Accept的系统调用会从Pending Queue拿出一个请求，然后在内核空间形成一个Socket文件，Socket文件会形成资源的一个句柄对应这个文件，派发线程一直循环，不断的Accept将每个文件形成FD（Socket，用来操作文件资源的）；
3、将FD派发给工作线程，工作线程读取Socket中的内容，进行处理后，再给用户返回信息，返回时工作线程直接在Socket写入信息，不需要原路返回了；
4、内核监听到Socket的写入信息，然后再把信息返回给请求方。
过程： 1（用户请求）-&gt; 2（Pending Queue收集）-&gt; 3、4、5（线程触发Accept，内核从Pending Queue获取一个请求，形成一个Socket文件，拿到文件句柄）-&gt; 6（线程将获取到的Socket派发到工作线程）-&gt; 7（工作线程先读取4中文件内容，处理完请求后将相关信息直接写入到4中文件中，）-&gt; 8（内核监听到Socket文件写入信息然后再返回给请求方）
3、代码实现（简单实现） HttpServer代码 package com.hh.http; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * 简单版 * * @author hang.yuan 2022/3/8 17:58 */ public class HttpServer { public static void main(String[] args) throws IOException { ServerSocket socketServer = new ServerSocket(8000); //main Thread while (true){ // Blocking ... // Thread --&gt; Sleep --&gt; Other Threads Socket socket = socketServer.accept(); System.out.println(&#34;socket created&#34;); InputStream inputStream = new DataInputStream(socket.getInputStream()); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder requestBuilder = new StringBuilder(); String line = &#34;&#34;; while (true){ line = bufferedReader.readLine(); if(line ==null || line.isEmpty()){ break; } requestBuilder.append(line+&#34;\n&#34;); } String request = requestBuilder.toString(); System.out.println(request); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(&#34;HTTP/1.1 200 ok\n\nhello word!\n&#34;); bufferedWriter.flush(); socket.close(); } } } 测试： 结果：
  ]]></content></entry><entry><title>计算机网络：常用HTTP状态码速查表</title><url>/post/9/</url><categories><category>计算机网络</category></categories><tags><tag>状态码</tag></tags><content type="html"> Code Reason-Phrase 100 Continue 101 Switching Protocols 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 307 Temporary Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 426 Upgrade Required 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported Informational 1xx 1xx(Informational) 状态码类别表示在完成所请求的动作并发送最终响应之前的通信连接状态或请求进度的临时响应。
1xx 响应由状态行之后的第一个空行（空行表示header 部分的结尾）终止。 由于HTTP/1.0 没有定义任何1xx状态码，因此服务器不得向HTTP/1.0客户端发送1xx响应。
即使客户端没有预期到，客户 …</content></entry><entry><title>计算机网络：TCP、UDP、IP抓包工具-wireshark</title><url>/post/16/</url><categories><category>计算机网络</category></categories><tags><tag>wireshark</tag></tags><content type="html"> 1、什么是Wireshark？ 是世界上应用最广泛的网络协议分析器。 在微观层面上看到整个网络正在发生的事情。 使用WinPCAP作为接口，直接与网卡进行数据报文交换。 2、wireshark抓包原理 单机：直接抓取本机网卡的网络流量。 交换机：通过端口镜像、ARP欺骗等方式获取网络流量。 端口镜像：利用交换机的接口，将网络流量转发到指定电脑的网卡上。 ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取网络流量。 3、功能集 深入检查数百个协议，并不断添加更多协议 实时捕获和离线分析 支持Windows、Linux、macOS、Solaris、FreeBSD、NetBSD和许多其他平台 提供GUI浏览，也可以通过TTY VoIP支持 Gzip支持 IpSec支持 &amp;hellip;&amp;hellip; 4、抓包界面 如上图： 菜单栏 工具栏 过滤栏 数据列表区：不同的协议使用了不同的颜色区分。 数据详细区 数据字节区 数据统计区 下载 软件下载： https://www.wireshark.org/download.html 中文文档： wireshark-中文手册.pdf 提取码: 6or7</content></entry><entry><title>计算机网络：UDP协议</title><url>/post/15/</url><categories><category>计算机网络</category></categories><tags><tag>UDP</tag></tags><content type="html"> 背景和介绍 背景 1980年由科学家David P. Reed提出 协议简单，搭建在IP协议之上 尽可能的减少通信机制，速度非常快 该协议的RFC只有两页 介绍 全称: User Datagram Protocol，用户数据报协议 定义：在传输层提供直接发送报文(Datagram)的能力。Datagram是数据传输的最小单位。 目标：发送报文，无法拆分数据 思考：为什么不直接调用IP协议？ IP协议只能把数据从一个网络接口发送到另一个网络接口，无法寻址到应用 封包格式 设计目标：允许用户直接发送报文的情况下最大限度的简化应用的设计
报文格式： Source Port：源端口号 Destination Port：目标端口号。 Length：消息体长度 Checksum：检查封包是否出错 Data octets：一个字节一个字节的数据。Octet是8位。 与TCP的区别 UDP TCP 本质 提供报文交换，简化协议 提供可靠的网络传输 可靠性 不可靠 可靠 顺序 无序 有序 负载 负载小 负载大 广播场景 合适 不合适，代价大 场景分析 聊天室是否适合UDP？ 不合适，聊天室并发高但流量不大，依赖可靠性
HTTP协议适不适合UDP？ 合适，HTTP3.0就是建立在UDP上的</content></entry><entry><title>计算机网络：IPv6协议</title><url>/post/14/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 背景 IPv4只能支持43亿设备，不够用。
工作原理 IPv6和IPv4两者工作原理相似，为切片、增加封包头、路由(寻址)几个阶段。 与IPv4的主要区别 地址
地址数量：IPv4有4个8位，共16位，IPv6有8个16位，共128位 分割符号： IPv4的地址用 . 分割，如 103.28.7.35 。每一个是8位，用0-255的数字表示。 IPv6的地址用 : 分割，如 0123:4567:89ab:cdef:0123:4567:89ab:cdef 。每个是一个16位的16进制数字，就是4个符。 IPv6地址： 寻址
全局单播
站点前缀（Site Prefix)：48bit，一般是由ISP（Internet Service Providor，运营商）或者RIR(Regional Internet Registry， 地区性互联网注册机构)。RIR将IP地址分配给运营商。 子网号（Subnet ID)：16bit，用于站点内部区分子网。 接口号（Interface ID)：64bit，用于站点内部区分设备。 本地单播
给定地址，本地网定位设备 ⚠️ 注意：Link-local必须以fe80开头 分组多播
需要以8个1，也就是 ff00 开头，后面跟上一个分组的编号。 所在的网络中已经定义了该分组编号，而且有设备可以识别这个编号。 拥有分组下设备的完整清单，并把数据发送给对应的设备们。 IPv4也支持分组多播，但需要网络配置整体配合。 新设备接入 新设备接入IPv6后，会使用IPv6的邻居发现协议(Neighbour Discover Protocol)为自己申请一个IP地址。当新设备需要发送信息到目的地时，还可以通过ND协议广播查询目标设备。然后如果需要路由，还可以通过ND查找路由器。 传统：ARP协议（Address Resolution Protocol，地址解析协议）。每个节点存储许多额外信息。
IPv6: 更加无状态化，减少数据冗余带来的风险和负担
优势 解决了IP地址耗尽的问题 解决了网络区域、站点划分的问题。 协议层支持多播。 Ipv6可以有专门的地址用作多播。 支持邻居发现协议，自动分配地址，做到了无状态接入设备。</content></entry><entry><title>计算机网络：IP协议</title><url>/post/13/</url><categories><category>计算机网络</category></categories><tags><tag>IP</tag></tags><content type="html"> 概念 IP协议(Internet Protocol)：网络层协议。 IP协议可能遇到的问题： 封包损坏 丢包 重发 乱序 网络层需要解决的3个问题： 延迟 吞吐量 丢包率 IP协议目前主要有两种架构，IPv4和IPv6，IPv4是目前应用最广泛的互联网协议。 IP协议的工作原理 分片
把数据切分成片 适配底层传输网络 增加协议头 Type Of Service：服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。 IHL（Internet Header Length)：IP协议头的大小。 Total Length：报文(封包datagram)的长度 Identification：报文的ID，发送方分配，代表顺序 Fragment offset：描述是否要分包（拆分），和如何拆分。 Time To Live：封包存活的时间。 Protocol：描述上层的协议，比如TCP=6,UDP=17 Options：可选项 Checksum：检验封包的正确性 延迟、吞吐量、丢包率 寻址
寻址：给一个地址，然后找到这个东西 IPv4地址(32位)：逐级寻址 步骤： 路由
若寻找的IP地址不在局域网中，需要路由找到去往对应网络的路径。 IP地址和子网掩码位与的过程是由路由算法实现的。</content></entry><entry><title>计算机网络：TCP协议</title><url>/post/12/</url><categories><category>计算机网络</category></categories><tags><tag>TCP</tag></tags><content type="html"> 概述 TCP全名是(Transport Control Protocol)，是一个可以提供可靠的、支持全双工、连接导向的协议，因此在客户端和服务端之间传输数据的时候，是必须先建立一个连接的。 TCP的特点 连接 是虚拟、抽象的概念 能让两个通信的程序间确保彼此都在线 加快响应请求速度 连接也被称为会话(Session） 使通信更稳定、安全 消耗更多资源 全双工 单工：任何时刻数据只能单向发送 半双工：允许数据在两个方向上传输，在某一时刻，只允许数据在一个方向上传输 全双工：任何时刻都能双向发送数据 可靠的
可靠性指数据保证无损传输 使无序的数据恢复原有顺序 多播时每个接收方都获得无损副本 TCP协议的工作过程 建立连接的过程（三次握手） 1.客户端发送SYN，服务端准备好进行连接 2.服务端针对客户端的SYN给ACK，服务端发送SYN 3.客户端准备就绪，客户端发送ACK 断开连接的过程（四次挥手） 1.客户端发送断开请求FIN 2.服务端收到请求，发送ACK 3.服务端经过一个等待（数据处理完毕），确定可以关闭连接，发送FIN 4.客户端收到FIN，处理完自己的事情后发送ACK 传输数据 报文拆分
应用层数据很大时无法一次性传输完 拆分后可实现并行传输 顺序保证
思考：如果TCP段特别多的时候，该如何进行排序？时间窗口 TCP序号：发送序号(Seq)、接收序号(Ack) 一个端的发送序号是另一个端的接受序号 TCP头部结构 结构图： 源端口：描述发送方机器上的应用
目标端口：描述接收方服务器上的应用
发送序号(Seq)/接收序号(Ack)
标志位
NS、CWR、ECE：TCP扩展协议 ECN：显示拥塞控制协议，有助于帮助解决延迟和丢包问题， URG：紧急标志位SYN（Synchronize Sequence Numbers)：同步序号，也就是在建立连接。 FIN： 终止连接 ACK（Achnowledgment)：响应。 PSH（push）：传送数据 RST（Reset Connection)： 重置连接 TCP协议周边配置 纠错能力：保证数据可靠性； TCP拥有一个16bit的Checksum字段 Checksum是一个函数，把原文映射到一个不可逆的16bit的编码中这样就可以知道原文传输过程中有没有发生变化 流控能力：协同两边速率，保证可靠性； 主要目标：让发送方和接收方协商一个合理的收发速率，让两边都可以稳定的工作。 利用滑动窗口 拥塞控制能力：确定网络的拥堵情况决定传输速度。</content></entry><entry><title>SSH还能内网穿透，实在是没想到</title><url>/post/7/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag><tag>内网穿透</tag></tags><content type="html"> 1、准备 两台机器(一台有公网IP A，一台是没有公网IP B)
2、操作 (1) A机器运行sshd ，将GatewayPorts设置为yes，并重启sshd
(2) B机器执行如下命令：
ssh -NR 9999:192.168.56.2:22 A机器的用户@A机器的Ip 参数解释： -N ：不执行任何命令 -R ： 将端口绑定到远程服务器,反向代理 9999 ：自己设定的在远程服务器的监听端口 192.168.56.2:22 ： 本地的服务ip和监听端口 A机器的用户@A机器的Ip ：远程服务器的用户和IP 3、测试 (1) 在A机器上执行netstat -lntp 可以看到9999端口被监听
(2) 测试A机器上使用隧道连接B机器
ssh -p 9999 B机器的用户@192.168.56.2 注：只是自己测试玩一玩的，不要抱很大希望能生产使用</content></entry><entry><title>计算机网络：互联网协议群</title><url>/post/11/</url><categories><category>计算机网络</category></categories><tags><tag>TCP/IP协议</tag></tags><content type="html"> 概述 OSI无实际可行方案 有人就提出了TCP协议 TCP/IP协议群解决的5个问题 报文拆分
数据量大，网络底层设备不支持 复用路径 增加协议头
数据分块后在接收端需要重组，所以需要使用头部来添加一些描述字段 数据在相邻设备间数据传递 路由和寻址
路由算法：通过算法寻找下一个要到达的节点 数组重组 TCP/IP协议群的5层模型 5层模型图： 5层模型与OSI7层模型区别 删除了会话层，会话是虚拟概念，不是必须的 删除了表示层，数据压缩、数据格式转换不是应用必须的 TCP/IP协议群可选性 传输层：TCP协议、UDP协议、TLS/SSL、SCTP等 网络层：IP协议(ipv4和ipv6)、ICMP协议、IPSec协议</content></entry><entry><title>计算机网络：OSI七层模型</title><url>/post/10/</url><categories><category>计算机网络</category></categories><tags><tag>7层模型</tag></tags><content type="html"> 1、OSI模型是什么？ OSI模型指的是Open System Interconnection Reference Model，即开放式系统互联模型。它是世界上第一个试图在世界范围内规范网络标准的框架。
2、7层模型详解 OSI模型图示： 应用层
应用层位于OSI模型最上方 只关心业务逻辑，不关心数据传输 例如：张三给小花微信发送消息 表现层
负责协商用于传输的数据格式，并转换数据格式 会话层
负责管理两个连网实体间的连接 功能及特点：建立连接，维持通信，释放连接 传输层
负责将数据从一个实体（服务器或者应用）传输到另一个实体，但不负责数据传输的方式。 能力： 数据分隔重组：将数据拆分后按顺序重组 纠错：在数据传输过程中出现问题后采取方式进行纠正 管理连接：处理数据的频繁交换 流量控制：控制传输数据的速率 端口寻址：标明参与传输的实体的端口号 网络层
负责把一个封包从一个IP地址传输到另一个IP地址 思考：一个节点接收到一个封包之后，它怎么把这个封包传递到下个节点？ 路由算法 数据链路层
确保两个临近设备间数据的传输，并隐藏底层实现 帧同步：两个设备之间传输时的协商速率问题 数据纠错 物理层
封装和隐藏具体的传输手段，并且提供稳定的传输接口 比如：电缆、光纤、蓝牙等 3、OSI的问题 分层设计较为臃肿，并非每一层都为必要的，所以有了 应用层、表示层、会话层合为应用层</content></entry><entry><title>rsync数据同步备份工具</title><url>/post/5/</url><categories><category>Linux</category></categories><tags><tag>rsync</tag><tag>数据同步备份</tag></tags><content type="html"><![CDATA[  1、介绍rsync工具 1.1 rsync是什么：
一款开源的，快速的，多功能的，可以实现全量和增量的本地或远程数据同步备份工具。
1.2 使用范围 :
unix,linux,windows等多种操作系统
1.3 优点：
1.具有本地和远程两台主机之间数据快速复制同步，备份功能
2.能实现增量备份，具有独特的quick check算法
1.4 工作方式：
1.单个本机之间数据传输，类似于cp命令。
2.借助rcp,ssh通道传输数据，类似于scp。
3.以守护进程（socket）方式传输数据。
2、实践 示例：以虚拟机与本地机器（自己实体电脑）数据备份为例
2.1 简单说明：
自己电脑内安装VirtualBox虚拟机通过共享文件的方式把虚拟机内产生的数据备份到自己电脑的磁盘上
2.2 环境：
台式机一台，安装VirtualBox虚拟机
2.3 准备脚本(databak.sh)
/usr/bin/rsync --timeout=60 --progress --log-file=&#39;/opt/logs/rsync.log&#39; --log-file-format=&#39;%t %f %b&#39; -azvP /opt/all_data /media/sf_2/ 2.4 脚本命令解释：
该命令使用rsync工具将/opt/all_data目录及其内容同步到/media/sf_2/目录。
具体参数解释如下：
&ndash;timeout=60：设置连接超时时间为60秒。 &ndash;progress：显示进度条。 &ndash;log-file=&rsquo;/opt/logs/rsync.log&rsquo;：将rsync的日志记录到/opt/logs/rsync.log文件中。 &ndash;log-file-format=&rsquo;%t %f %b&rsquo;：日志文件的格式为时间、文件名和字节大小。 -a 以递归方式传输文件，并保持所有文件的属性 -z 传输时进行压缩以提高传输效率 -v 详细模式输出 -P 显示同步的过程及传输时的进度等信息 2.5 crontab简单操作命令：
crontab -l 查看 crontab -e 编辑 service crond restart 重启 2.6 crontab定时任务，数据备份命令：
0 3 * * * /usr/bin/sh /opt/databak.sh &gt; /dev/null 2&gt;&amp;1 2.7 cron表达式解释：
表示每天凌晨0点用shell执行/opt/databak.sh脚本，并将输出重定向到/null。
具体解释如下：
0：表示分钟数，即0分。 3：表示小时数，即0-23小时之间的第3个小时。 *：表示日期（月份、星期等）的通配符，表示每小时执行。 *：表示日期（月份、星期等）的通配符，表示每天执行。 &gt; /dev/null：将标准输出重定向到/null，即不输出任何结果。 2&gt;&amp;1：将错误输出重定向到标准输出，即仍然保留错误输出，只是不输出正常输出。   ]]></content></entry><entry><title>Linux下安装jupyter</title><url>/post/1/</url><categories><category>Linux</category></categories><tags><tag>jupyter</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  1.安装jupyter # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install jupyter 2.生成jupyter配置文件 # root用户： jupyter notebook –generate-config –allow-root # 非root用户 jupyter notebook –generate-config #输出信息：Writing default config to: /root/.jupyter/jupyter_notebook_config.py # 配置文件地址： /root/.jupyter/jupyter_notebook_config.py 3.打开ipython,生成密码 [root@hangzhi ~]# ipython In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: #此处输入密码 Verify password: #此处输入之前输入的密码 Out[2]: &#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; #这个秘钥要copy备用 4.修改配置文件 [root@hangzhi ~]# vi /root/.jupyter/jupyter_notebook_config.py # notebook服务会监听的IP地址 c.NotebookApp.ip = &#39;&#39; #工作目录，自己选定 c.NotebookApp.notebook_dir = &#39;/opt/jupyter/jupyter_work&#39; c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 #上面生成的秘钥 c.NotebookApp.password = u&#39;sha1:f8b5f5dbeca8:d1f5b93d5e787e4bf1bf4ad2c48c177ba79f55dd&#39; 5.启动jupyter # root用户 jupyter notebook –allow-root # 非root用户 jupyter notebook 后台启动脚本 # root用户 nohup jupyter notebook --allow-root &gt; /opt/logs/jupyter.log 2&gt;&amp;1 &amp; 停止脚本 #!/bin/bash #停止服务名称 SERVER_NAME=jupyter-notebook PIDS=`ps -ef | grep jupyter |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep jupyter` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34; 6.浏览器访问 ip:8888 即可访问了，需输入密码就可以   ]]></content></entry><entry><title>1.Java基础概述</title><url>/post/44/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag></tags><content type="html"> 1、简介 Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。
后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。
2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 &amp;amp;ldquo;2&amp;amp;rdquo;：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。
2、Java 三个体系： Java SE（Java 2 Platform Standard Edition）标准版【J2SE】 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE，是其它两者的基础。
Java ME（Java 2 Platform Micro Edition）小型版、微型版【J2ME】 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME。
Java EE（Java 2 Platform Enterprise Edition）企业版【J2EE】 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE。
三种技术的关系： 3、Java语言的特性 简单性（简洁有效、易学） Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。
面向对象（强制面向对象） Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制。
Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。
分布式处理（适合分布式计算） Java语言支持Internet应用的开发，在基本的Java应用编程接口中有 …</content></entry><entry><title>2.Java基础知识：语法</title><url>/post/45/</url><categories><category>Java</category></categories><tags><tag>Java基础</tag></tags><content type="html"> 1、Java中的关键字 关键字 说明 abstract 表明类或者成员方法具有抽象属性 assert 用来进行程序调试 boolean 基本数据类型之一，布尔类型 break 提前跳出一个块 byte 基本数据类型之一，字节类型 case 用在switch语句之中，表示其中的一个分支 catch 用在异常处理中，用来捕捉异常 char 基本数据类型之一，字符类型 class 类 const 保留关键字，没有具体含义 continue 回到一个块的开始处 default 默认，例如，用在switch语句中，表明一个默认的分支 do 用在do-while循环结构中 double 基本数据类型之一，双精度浮点数类型 else 用在条件语句中，表明当条件不成立时的分支 enum 枚举 extends 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口 final 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变 finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块 float 基本数据类型之一，单精度浮点数类型 for 一种循环结构的引导词 goto 保留关键字，没有具体含义 if 条件语句的引导词 implements 表明一个类实现了给定的接口 import 表明要访问指定的类或包 instanceof 用来测试一个对象是否是指定类型的实例对象 int 基本数据类型之一，整数类型 interface 接口 long 基本数据类型之一，长整数类型 native 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 new 用来创建新实例对象 package 包 private 一种访问控制方式：私用模式 protected 一种访问控制方式：保护模式 public 一种访问控制方式：共用模式 return 从成员方法中返回数据 short 基本数据类型之一,短整数类型 static 表明具有静态属性 strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 super 表明当前对象的父类型的引用或者父类型的构造方法 switch 分支语句结构的引导词 synchronized 表明一段代码需要同步执行 this 指向当前实例对象 …</content></entry><entry><title>13.Python处理高级数据结构和数据分析常用扩展库：Pandas</title><url>/post/43/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、Pandas介绍 Pandas是一个用于处理高级数据结构和数据分析的Python库。基于Numpy构建的一种工具，纳入了大量模块和库一些标准的数据模型，提高python处理大数据的性能。广泛应用于金融、经济、数据分析、统计等商业领域，为从业者提供了便捷。
特点：
支持Dataframe格式，自定义索引，Dataframe是一种高效快速的数据结构对象 可以将不同格式的数据文件加载到内存中 可处理时间序列或非时间序列数据 可基于标签来切片索引，获得大数据集子集 可进行高性能数据分组、聚合、添加、删除 未对齐及索引方式不同的数据可按轴自动对齐 灵活处理数据缺失、重组、空格 2、Pandas安装 # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install pandas 3、Series数据结构 Series类似一维数组，数组由数据与其索引标签组成，索引在左侧，值在右侧。
3.1、创建Series数组
import pandas as pd import numpy as np # 创建Series数组 s1 = pd.Series([1,2,3,4]) print(&amp;#34;s1:&amp;#34;,s1) # 创建Series数组并设置index参数 s2 = pd.Series([1,2,3,4],index=[&amp;#39;一&amp;#39;,&amp;#39;二&amp;#39;,&amp;#39;三&amp;#39;,&amp;#39;四&amp;#39;]) print(&amp;#34;s2:&amp;#34;,s2) 3.2、Series的索引和切片
通过Series的value和index属性可以获取Series中的索引和数值
# Series索引和切片 print(&amp;#39;s2的索引：&amp;#39;,s2.index) print(&amp;#39;s2的值：&amp;#39;,s2.values) # 通过索引获取值或者修改（索引是不可以修改的） # 单索引 print(&amp;#39;s2中二对应的值&amp;#39;,s2[&amp;#39;二&amp;#39;]) s2[&amp;#39;二&amp;#39;] = 5 print(&amp;#39;s2中二对应的值&amp;#39;,s2[&amp;#39;二&amp;#39;]) # 多索引 print(&amp;#39;s2中二、四对应的值&amp;#39;,s2[[&amp;#39;二&amp;#39;,&amp;#39; …  ]]></content></entry><entry><title>12.Python科学计算和数据分析的常用扩展库：Numpy</title><url>/post/42/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、Numpy介绍 Numpy (Numerical Python) 是python中的一个基础工具包，用以进行科学计算及数据分析， Numpy中单一数据类型的多维数组以ndarray的形式存储，可进行快速矢量算术运算， Numpy还可用于磁盘数据的读写以及内存映射文件的操作，实现数据的快速读写与输出， Numpy也是数据分析必不可少的工具，可以进行数据清洗、数据转换等矢量化数组运算。 2、Numpy安装 # python -m pip会使用您指定为python的Python解释器来执行pip python -m pip install numpy 3、创建ndarray数组 ndarray：数组中的所有对象必须是相同类型的，创建ndarray数组可以使用array函数传入python序列对象实现
3.1、一维数组
import numpy as np # 创建一维数组 a = [1, 2, 3, 4, 5] arr1 = np.array(a) print(&amp;#34;创建一维数组：\n&amp;#34;, arr1) 3.2、多维数组
# 创建多维数组 b = [[1, 2, 3], [4, 5, 6]] arr2 = np.array(b) print(&amp;#34;创建多维数组：\n&amp;#34;, arr2) 3.3、shape函数
shape函数是查看每个数组各维度的大小，返回值是一个元组对象，数组是一维数组，返回值是(n,)，
n表示数组的长度，数组是二维数组，返回值是(n1,n2) ，n1表示行数，n2表示列数，
对于三维数组就是包含多少个二维数组，后两个数字表示二维数组的行与列 返回值是(n1,n2,n3)， n1表示几个二维数组，n2表示二维数组的行，n3表示二维数组列
# shape print(&amp;#34;arr1 shape: &amp;#34;, arr1.shape) print(&amp;#34;arr2 shape: &amp;#34;, arr2.shape) 3.4、reshape函数
reshape函数可以更改数组的结构，原数组的shape仍然保持不变，原数组与新数组是共享同一数据储存内存区域，
所以对其中一个数组元素修改，都会同时引起另一个数组内容的改变
# reshape arr2_reshape = arr2.reshape(3,2) …  ]]></content></entry><entry><title>frp实现内网穿透详细配置</title><url>/post/8/</url><categories><category>Linux</category></categories><tags><tag>frp</tag><tag>内网穿透</tag></tags><content type="html"> 1、条件 需要一个有公网IP的云服务器（我的是腾讯云）
2、frp下载及介绍 (1) frp下载：https://github.com/fatedier/frp/releases 下载最新版，根据自己的服务器下载对应版本（我的是linux64系统）
wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gz (2) 解压压缩包
tar -zxvf frp_0.34.3_linux_amd64.tar.gz mv frp_0.34.3_linux_amd64 frpServer 包结构介绍：
服务器端：
frps： 服务器端服务启动文件 frps_full.ini： 启动配置文件（全版） frps.ini ：启动配置文件（简版） 客户端（Linux版）：
frpc ：客户端服务启动文件 frpc_full.ini ：启动配置文件（全版） frpc.ini ：启动配置文件（简版） 3、进入解压文件夹 cd frpServer 4、服务端配置及运行 4.1 修改端口，frps.ini文件
[common] bind_port = 9999 # bind_port是服务器的端口，我们最好不要使用默认端口 4.2 运行服务
直接运行： # frp解压文件夹目录下运行，也可以使用全路径 # 相对路径 ./frps -c frps.ini # 绝对路径 /opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini 后台运行： nohup ./frpc -c ./frpc.ini &amp;amp;amp; 4.3 配置系统启动时自动启动
在/lib/systemd/system文件夹下创建frps.service文件
编辑frps.service文件，输入以下内容(注：ExecStart 使用绝对路径 )：
[Unit] Description=frp service After=network.target [Service] TimeoutStartSec=30 ExecStart=/opt/frp/frpServer/frps -c /opt/frp/frpServer/frps.ini …</content></entry><entry><title>解决自己的云服务器经常被登录问题</title><url>/post/6/</url><categories><category>Linux</category></categories><tags><tag>SSH</tag></tags><content type="html"> 1、解决过程 1.1 环境：
腾讯centos云服务器
1.2 原因：
每次登录云服务器时系统都会提示，这是被各种尝试登录导致的（简单说就是你的服务器被攻击了）
Last failed login: Tue Dec 29 21:06:17 CST 2020 from 182.78.163.21 on ssh:notty There were 6751 failed login attempts since the last successful login. Last login: Sat Dec 26 01:17:59 2020 from 120.230.83.193 1.3 解决办法：
使用密钥登录可以解决
1.4 步骤如下：
1.生成ssh密钥： [root@hangzhi ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): #此处直接回车就可以 Enter passphrase (empty for no passphrase): #设置解密钥密码 Enter same passphrase again: #再此输入一样密码确认 Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:9vRVtZ9uUUinLq+0byUMYDo8XZpZQ/t2iDbrGjcjMNc root@hangzhi The key&amp;#39;s randomart image is: +---[RSA 2048]----+ | .. . o| | o +o +o| | . + B..o.o| | = =..+ o+| | Soo Eo*oo| | . * o B+.o| | + B .= | | * =o | | ..+o. | +----[SHA256]-----+ 2.查看生成的密钥： [root@hangzhi ~]# cd /root/.ssh/ [root@hangzhi .ssh]# ll total 12 -rw-r--r--. 1 root root 0 Mar 7 2018 authorized_keys -rw------- 1 root root 1766 Dec 29 21:13 id_rsa #私钥 -rw-r--r-- 1 root root 394 Dec 29 21:13 id_rsa.pub #公钥 -rw-r--r-- 1 root root 176 Jan 6 2019 known_hosts 3.将公钥追加到authorized_keys文件中： [root@hangzhi .ssh]# cat id_rsa.pub &amp;gt;&amp;gt; /root/.ssh/authorized_keys 4.将权限改为只有当前用户可读可写，保证安全： [root@hangzhi .ssh]# chmod 600 authorized_keys 5.打开ssh的密钥登录功能： [root@hangzhi .ssh]# vim /etc/ssh/sshd_config #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys #将上面2行前面的注释去掉，然后保存 # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service 6.然后使用客户端配置密钥登录，如果成功接着下一步，不成功重复上面步骤
7.关闭ssh密码登录（注意：只有配置成功后才操作这个步，不然没成功关闭这个会导致不能登录服务器 ）
[root@hangzhi .ssh]# vim /etc/ssh/sshd_config PasswordAuthentication yes 修改为: PasswordAuthentication no # 重启ssh服务 [root@hangzhi .ssh]# systemctl restart sshd.service</content></entry><entry><title>11.Python爬虫必学的网络编程知识</title><url>/post/41/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、基础知识 HTTP：（HyperText Transport Protocol）是超文本传输协议缩写
URL：（Uniform Resource Locator）是统一资源定位符的缩写
HTTP请求方式
对比项 GET POST 提交方式 提交的参数数据放在URL之后，使用?与URL进行分割，多个参数之间使用&amp;amp;分隔 提交的参数数据不放在URL中提交，模拟提交表单数据 提交数据长度 受限 无限制 安全性 安全性低，提交的数据与URL混合在一起提交，很容易被发现 安全性高 状态码：常见的状态码
200:表示请求成功，成功返回请求资源 404:表示请求的资源不存在 500:服务器错误 2、urllib库 urllib库内置模块：
模块 说明 urllib.request HTTP请求模块，在程序中模拟浏览器发送HTTP请求 urllib.error 异常模块，捕获由于HTTP请求问题产生的异常，并进行处理 urllib.parse URL解析模块，提供了处理URL的工具函数 urllib.robotparser robots.txt解析模块，网站通过robots.txt文件设置爬虫可爬取的网页 2.1、urllib.request.urlopen函数
常用参数：
url：目标URL访问地址 data：默认是None，表示GET方式发送请求，data有值，表示POST方式发送请求 timeout：访问超时时间 2.1.1、GET请求
import urllib.request #data没值是GET res = urllib.request.urlopen(&amp;#34;http://www.baidu.com&amp;#34;) print(res.read().decode(&amp;#34;utf8&amp;#34;)) 2.1.2、POST请求
import urllib.request # 请求数据 param_dict = {&amp;#34;key&amp;#34;:&amp;#34;hello world&amp;#34;} # 调用urlencode函数将字典类型数据转成字符串 param_str = urllib.parse.urlencode(param_dict) #将传输数据封装成一个bytes …  ]]></content></entry><entry><title>VirtualBox虚拟机导出及磁盘扩展</title><url>/post/4/</url><categories><category>Linux</category></categories><tags><tag>VirtualBox虚拟机</tag><tag>磁盘扩展</tag></tags><content type="html"> VirtualBox虚拟机导出 VirtualBox虚拟机的迁移除了复制还有一种通用方式是导出
复制的方式可以看之前写的：VirtualBox虚拟机迁移/复制（带快照）
简单方便的导出方式(推荐)，因为适用其他虚拟机,如:VMWare
VirtualBox虚拟机磁盘扩展 1.创建磁盘和添加磁盘
对于创建时使用哪种磁盘文件，如下图介绍（我自己使用的VMDK ：
2.查看能不能识别磁盘
3.对磁盘分区
fdisk /dev/sdb 选N进行分区 两个选项，e为分逻辑分区，p为主分区，（我选择的是p） 选1，说明是创建第一个分区，起始位置默认直接回车 下一个是让你选择究竟要分多大空间给这个分区，直接回车就默认全部分给他，单位按MB来算 选W 保存退出 4.查看分好区的磁盘
fdisk -l 查看 能看到/dev/sdb1了就ok 5.对分区好磁盘格式化
mkfs.ext4 /dev/sdb1 对这个分区进行格式化 格式化成ext4格式，如果你想其他格式就自己改 6.创建磁盘挂载的文件夹
mkdir /mnt/sdb1 （这个是要将硬盘挂载的地方，位置随意） 7.将挂载文件夹与磁盘关联
mount /dev/sdb1 /mnt/sdb1 （挂载这个硬盘到这个位置上） df -h就能看到硬盘了 8.设置开机自动挂载磁盘
vi /etc/fstab 让系统可以开机后自动将硬盘挂载上去 最后一行添加：/dev/sdb1 /mnt/sdb1 ext4 defaults 0 0 然后保存退出</content></entry><entry><title>VirtualBox虚拟机迁移/复制（带快照）</title><url>/post/3/</url><categories><category>Linux</category></categories><tags><tag>VirtualBox虚拟机</tag></tags><content type="html"> 本次虚拟机迁移是基于VirtualBox虚拟机，如果要尝试安装和创建虚拟机可以去搜索：virtualbox的安装与使用、安装镜像创建虚拟机
1、VirtualBox的结构介绍 xxx.vdi : 这个文件是磁盘映像，创建虚拟机的时候创建的
xxx.vbox 和 xxx.vbox-prev：这个两文件虚拟机的配置文件，记录了所以配置信息，如快照，虚拟磁盘等，核心文件是.vbox文件
xxx.vmdk : 这个文件是虚拟机磁盘，是用来扩展机器存储空间，创建虚拟机一般是没有次文件的
{UUID}.vdi ：磁盘映像文件的快照
{UUID}.vmdk : 虚拟机磁盘文件的快照
注：迁移有风险，迁移时要多细心
2、不带快照 2.1 迁移到不同机器
（1）迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到不同机器，由于是在不同的机器上进行迁移，是不涉及到镜像文件的UUID相同情况，因此比较简单，只需要打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
（2）在新机器上的VirtualBox软件中注册刚修改的文件，有.vmdk 文件也需要注册，否则不注册。如下图：
新机的迁移就这么简单完成了。
2.2 迁移到本机机器不同目录
（1）迁移的时候只需要将.vdi、.vbox、.vbox-prev文件迁移到本机机器不同目录，由于是在本机机器上进行迁移，涉及到镜像文件的UUID相同情况，因此需要分两步走：一是修改文件路径，二是修改文件UUID
修改文件路径：打开虚拟机的配置文件.vbox文件，修改里面的关于路径的几个配置项，一般是在文件的开头位置，如下图：
修改文件UUID：将.vdi、.vmdk(没有这个文件，可以忽略)文件重新生成UUID
VirtualBox软件安装目录下执行如下命令重新生成UUID
// 重新生成centos7(two).vdi的UUID VBoxManage internalcommands sethduuid &amp;amp;#34;F:\VirtualBox\centos7(two)\centos7(two).vdi&amp;amp;#34; // 重新生成sda7.vmdk的UUID VBoxManage internalcommands sethduuid …</content></entry><entry><title>10.Python的一大利器：正则表达式</title><url>/post/40/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、re模块 re模块中封装了很多正则表达式相关的函数，非常方便的使用正则表达式对字符串进行各种规则匹配检查，常用一个函数是match函数
match(patten,string)函数：用于对字符串进行正则匹配，patten表示正则表达式，string表示待匹配字符串，匹配成功返回Match对象，否则返回None # match 函数 （从左开始匹配，没匹配成功，不会向后面匹配，匹配失败） import re str1 = &amp;#34;hello python&amp;#34; str2 = &amp;#34;python hello python&amp;#34; rs1 = re.match(&amp;#34;python&amp;#34;,str1) rs2 = re.match(&amp;#34;python&amp;#34;,str2) print(rs1) # None print(rs2) # &amp;lt;re.Match object; span=(0, 6), match=&amp;#39;python&amp;#39;&amp;gt; #取值 print(rs2.group()) #python 2、单字符匹配 常用单字符匹配符号：
符号 说明 . 匹配除\n之外的任意字符 \d 匹配0到9之间的一个数字，等价于[0~9] \D 匹配一个非数字字符，等价于[^0~9] \s 匹配任意空白字符，如：空格、制表符\t、换行\n等 \S 匹配任意非空白字符 \w 匹配单词字符，包括字母、数字、下划线 \W 匹配非单词字符 [] 匹配[]中列举的字符 # 单字符匹配 import re rs = re.match(&amp;#39;.&amp;#39;,&amp;#39;1&amp;#39;) # 匹配一个包含数字的字符串 print(rs.group()) rs = re.match(&amp;#39;.&amp;#39;,&amp;#39;a&amp;#39;) # 匹配一个包含单字符的字符串 print(rs.group()) rs = re.match(&amp;#39;.&amp;#39;,&amp;#39;abc&amp;#39;) # 匹配一个包含多字符的字符串 print(rs.group()) # 多字符匹配 rs = re.match(&amp;#39;...&amp;#39;,&amp;#39;abc&amp;#39;) # 匹配一个包含多字符的字符串 print(rs.group()) #匹配任意空白字符 rs = …  ]]></content></entry><entry><title>9.Python必学的文件处理知识</title><url>/post/39/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、读写文件 1.1、打开文件
open函数打开文件，返回文件对象。open 函数打开文件三种常用模式：
只读模式，使用r表示，用于读取文件内容，不能向文件中写入数据 只写模式，使用w表示，用于将数据覆盖写入文件中 追加模式，使用a表示，用于将数据追加写入文件的末尾 注：打开一个不存在的文件时，只读模式会报不存在文件异常，只写和追加模式都会创建一个写文件
# 打开不存在的文件 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;r&amp;#39;) # 报错：FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;test.txt&amp;#39; f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) #创建文件 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;a&amp;#39;) #创建文件 1.2、写文件
write()方法：写入文件的内容不会自动换行，且调用一次只能将一个字符串写入文件 # 写入数据到文件 # 第一次 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) f.write(&amp;#39;hello&amp;#39;) f.write(&amp;#39;world&amp;#39;) f.write(&amp;#39;!&amp;#39;) # 第二次（覆盖第一次写入数据） f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) f.write(&amp;#39;你&amp;#39;) f.write(&amp;#39;好&amp;#39;) # 使用追加 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;a&amp;#39;) f.write(&amp;#39;你&amp;#39;) f.write(&amp;#39;好&amp;#39;) # 写入换行,使用换行符 f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;w&amp;#39;) f.write(&amp;#39;hello\n&amp;#39;) f.write(&amp;#39;world\n&amp;#39;) f.write(&amp;#39;!\n&amp;#39;) writelines()方法：可以将一个序列中的多个字符串一次写入文件中 # 使用writelines()函数,调一次写入 f = …  ]]></content></entry><entry><title>8.Python常用的时间和日期模块</title><url>/post/38/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"> 1、time模块 1.1、time函数
调用time函数，返回当前的时间戳，返回的时间戳是以秒为单位的浮点数
import time print(time.time()) #获取当前时间戳 1.2、localtime函数
可传入一个可选参数，以秒为单位的时间戳
传入参数，将时间戳格式化为本地时间，返回一个struct_time元组
不传入参数，将当前时间戳格式化为本地时间，返回一个struct_time元组
struct_time属性描述：
属性 含义 值 tm_year 年份 4位数字表示： 2020 tm_mon 月份 1-12数字表示：12 tm_mday 日期 1-31数字表示：5 tm_hour 小时 0-23数字表示：12 tm_min 分钟 0-59数字表示：30 tm_sec 秒 0-60数字表示：30 tm_wday 一周的第几天 0-6数字表示，0表示周一：5 tm_yday 一年的第几天 1-366数字表示：300 tm_isdst 是否是夏令时 默认值为-1，0表示不是，1表示是 import time date_time1 = time.localtime() print(date_time1) ts=time.time() date_time2=time.localtime(ts) print(date_time2) 1.3、strftime函数
strftime(fmt[,struct_time])函数是可以按照自定义的格式化参数将时间格式化，fmt是函数入参的自定义格式化参数，struct_time可选，不传表示当前时间格式化
时间格式化符号： 格式化符号 含义 %y 两位数的年份表示 %Y 四位数的年份表示 %m 月份 %d 日期 %H 24小时制小时数 %I 12小时制小时数 %M 分钟数 %S 秒 %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 一年内的第几天 %p 显示本地时间的AM或PM %U 一年中的第几周 %w 星期（0-6）0表示星期日 %W 一年中的星期数：星期一是一个星期的开始 %x 本地日期表示 20/12/5 %X 本地时间表示：10:10:10 %Z 当前时区的名称 import time # …</content></entry><entry><title>7.Python如何处理异常</title><url>/post/37/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、异常捕获 1.1、语法格式
# 单个异常 try: 可能产生异常的代码 except 异常类型名称 as 对异常类型名称重新命名: 异常处理 # 多个异常 try: 可能产生异常的代码 except (异常类型名称1,异常类型名称2,...) as 对异常类型名称重新命名: 异常处理 1.2、捕获单个异常
# 处理打开一个文件产生的有可能产生异常 try: open(&amp;#39;test.txt&amp;#39;) print(&amp;#39;打开文件成功！&amp;#39;) except FileNotFoundError as error: print(&amp;#39;捕获到异常&amp;#39;,error) print(&amp;#39;结束&amp;#39;) 1.3、捕获多个异常
# 处理打开一个文件产生的有可能产生异常和打印一个不存在变量异常 try: # 打开文件 open(&amp;#39;test.txt&amp;#39;) #打印不存在变量 print(file) except (FileNotFoundError,NameError) as error: print(&amp;#39;捕获到异常&amp;#39;,error) print(&amp;#39;结束&amp;#39;) 1.4、捕获全部异常
# 处理打开一个文件产生的有可能产生异常和打印一个不存在变量异常 try: # 打开文件 open(&amp;#39;test.txt&amp;#39;) #打印不存在变量 print(file) except NameError as error: # 只捕获了NameError异常，没捕获FileNotFoundError异常 print(&amp;#39;捕获到部分异常&amp;#39;,error) except Exception as e: print(&amp;#39;捕获到全部异常&amp;#39;,e) print(&amp;#39;结束&amp;#39;) 2、finally语句 如果某段代码必须要执行，不管是否有异常产生都要执行，那就需要使用finally语句了
#有异常 try: # 打开文件 f = open(&amp;#39;test.txt&amp;#39;) print(&amp;#39;打开文件成功！&amp;#39;) except FileNotFoundError as error: print(&amp;#39;捕获到异常&amp;#39;,error) finally: print(&amp;#39;关闭打开文 …  ]]></content></entry><entry><title>6.Python面向对象编程</title><url>/post/36/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、面向对象编程 面向对象编程（Object Oriented Programming，简称：OOP ）是一种解决软件复用的设计和编程方法，就是根据现实社会中的事物，抽象出事物的属性和功能，
后然将抽象出来的属性和功能封装成对象的属性和方法，在软件中通过复用对象实例提高软件的开发效率 ，很多高级编程语言都遵循面向对象的编程方法。
2、类和对象 2.1、类：是一类事物的抽象，定义了一类事物的属性和行为
类的构成：类名、属性、方法 定义： class 类名: def 方法名(self[,参数列表]): 方法体 ...... 注意事项： 1.定义类时，使用class关键字声明这是一个类
2.类名的命名规则：通常按照约定的“大驼峰”命名法。例：class ElectricCar 电动车类
3.定义方法时，方法的第一个参数默认为self，表示对象自身
4.通过对象调用方法时，不需要在方法中传入self参数，python解释器会自动传入
class Cat: def eat(self): print(&amp;#34;吃鱼。。。&amp;#34;) def drink(self): print(&amp;#34;喝水。。。&amp;#34;) def run(self): print(&amp;#34;跳舞。。。&amp;#34;) 2.2、对象：是通过类创建的一个具体事物，具有状态和行为，可以做具体事情。
创建对象的过程：是在内存中开辟一块区域存储这个对象，这块内存区域有它的对应内存地址，通过内存地址就能找到这块区域存储的这个对象。
对象的引用：就是把存储这个对象的内存地址告诉了变量，这个变量就指向了内存中的这个对象，通过这个变量就可以找到它所指的这个对象，所以这个变量叫这个对象的引用。
# 根据Cat类创建对象 xiaohe=Cat() #调用对象的方法 xiaohe.eat() xiaohe.drink() xiaohe.run() #对比一个类创建多对象是否相同 xiaobai=Cat() #id(对象)可以获取对象的内存地址 print(&amp;#34;xiaohe的id：{}&amp;#34;.format(id(xiaohe))) print(&amp;#34;xiaobai的id：{}&amp;#34;.format(id(xiaobai))) 2.3、类与对象的关系：类相当于创建对象的基础条件，根据类可以创建多个对象。 …  ]]></content></entry><entry><title>5.Python模块认识</title><url>/post/35/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、包 在Python中一个包内要创建__init__.py文件，来区分是包还是普通文件夹。一个项目中可以有多个包，每个包都可以含有子包或者多个模块，如图：
2、模块 在Python中一个以.py结尾的文件就是一个模块，不同包下可以用相同名称的模块，模块之间使用包名.模块名来区分。
引入模块的方法： 描述 引入方法 引入单个模块 Import 模块名称 引入多个模块 Import 模块名称1,模块名称1,&hellip; 引入模块中的指定函数或者类等 from 模块名称1 import func,&hellip;
from 模块名称1 import class,&hellip; 3、__init__.py 模块 使用Pycharm创建包时会自动创建一个__init__.py模块
__init__.py作用：模块内可以是空白用识别一个包，还可以在模块内定义关于包和模块相关的一些初始化操作
4、__name__ 变量 Python 内部定义了一个__name__变量（name前后分别是两个下划线），Python源码文件使用决定了__name__变量的取值
当Python源码文件直接运行时，__name__变量的值等于&quot;__main__&quot; 当Python源码文件作为模块在其他地方被引入时，__name__变量的值等于被引入模块名称 5、Python主入口解释 Python属于脚本语言，Python程序在执行时与其他语言不同，Python程序没有编译过程，不需要将程序编译成二进制再运行。
而是Python解释器根据Python代码文件从第一行开始由上到下逐行运行，整个程序没有统一的主入口
  ]]></content></entry><entry><title>4.Python函数使用</title><url>/post/34/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、函数定义和调用 1.1、定义函数的语法格式
def 函数名称(参数): 函数体代码 return 返回值 #定义函数 def user_info(): print(&amp;#34;姓名：张三&amp;#34;) print(&amp;#34;性别：男&amp;#34;) print(&amp;#34;年龄：18&amp;#34;) #函数调用 user_info() 2、函数参数 2.1、缺省参数：函数定义时，设置带有默认值的参数，调用时，缺省参数可以不传入，没传使用默认值，传了实参就使用实参
def sum(y,x=10): rs=x+y print(&amp;#34;{}+{}={}&amp;#34;.format(x,y,rs)) # 只传入一个参数y的值 sum(10) # 传入缺省参数的实参20 sum(10,20) 2.2、命名参数：指在调用带有参函数时，通过指定参数名称传入参数的值，并且可以不按照函数定义的参数顺序传入实参
def sum(y,x): rs=x+y print(&amp;#34;{}+{}={}&amp;#34;.format(x,y,rs)) # 不按照参数定义的顺序，通过指定参数名称传入，指定参数名称必须与定义的形参名称相同 sum(x=10,y=20) sum(y=20,x=10) 2.3、带参函数：函数定义时，可以在小括号内设置函数需要的参数，调用时安装顺序和个数传入
def user_info(name,sex,age): print(&amp;#34;姓名：&amp;#34;,name) print(&amp;#34;性别：&amp;#34;,sex) print(&amp;#34;年龄：&amp;#34;,age) # 调用 name=&amp;#34;张三&amp;#34; sex=&amp;#34;男&amp;#34; age=18 user_info(name,sex,age) 2.4、不定长参数
2.4.1、带有一个*的不定长参数 # 计算多个数字和 def any_num_sum(*args): print(&amp;#34;args参数值：&amp;#34;,args) print(&amp;#34;args参数类型：&amp;#34;,type(args)) rs=0 if len(args)&amp;gt;0: for arg in args: rs += arg print(&amp;#34;总和：&amp;#34;，rs) # 调用 any_num_sum(10,20) …  ]]></content></entry><entry><title>启动和停止shell脚本</title><url>/post/2/</url><categories><category>Linux</category></categories><tags><tag>shell脚本</tag></tags><content type="html"><![CDATA[  start.sh 定义变量: 服务名/部署路径/服务输出日志路径/启动文件路径 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 没启动继续下面的 设置JVM参数: JAVA_OPTS 后台启动应用: nohup java -jar 命令 再次检查是否启动 shell脚本示例: #!/bin/bash #启动服务名称 SERVER_NAME=test #服务部署路径 DEPLOY_DIR=/opt/app/test # 服务日志输出路径 STDOUT_FILE=${DEPLOY_DIR}/logs/test.log #服务启动的jar或war WAR_FILE=${DEPLOY_DIR}/test.jar PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -n &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The ${SERVER_NAME} already started!&#34; echo &#34;&gt;&gt;&gt; PID: $PIDS&#34; exit 1 fi #jvm参数配置 JAVA_OPTS=&#34;-server -Xmx2g -Xms2g &#34; echo -e &#34;&gt;&gt;&gt; Starting the ${SERVER_NAME} ...\c&#34; nohup java $JAVA_OPTS -jar ${WAR_FILE} &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39; | wc -l` if [ $COUNT -gt 0 ]; then break fi done PIDS=`ps -f | grep java | grep &#34;${DEPLOY_DIR}&#34; | awk &#39;{print $2}&#39;` echo &#34;OK ! --&gt;&gt;&gt; PID: $PIDS --&gt;&gt;&gt; STDOUT: $STDOUT_FILE &#34; stop.sh 定义变量: 部署服务路径/停止服务名称 检查是否启动: 使用 ps /grep/awk命令 配合 | 一起使用 启动继续下面的 kill掉进程 再次检查进程是否存在 shell脚本示例: #!/bin/bash #服务部署路径 DEPLOY_DIR=/opt/app/test #停止服务名称 SERVER_NAME=test PIDS=`ps -ef | grep java | grep &#34;${DEPLOY_DIR}&#34; |awk &#39;{print $2}&#39;` if [ -z &#34;$PIDS&#34; ]; then echo &#34;&gt;&gt;&gt; ERROR: The $SERVER_NAME does not started!&#34; exit 1 fi echo -e &#34;&gt;&gt;&gt; Stopping the $SERVER_NAME ...\c&#34; for PID in $PIDS ; do kill $PID &gt; /dev/null 2&gt;&amp;1 done COUNT=0 while [ $COUNT -lt 1 ]; do echo -e &#34;.\c&#34; sleep 1 COUNT=1 for PID in $PIDS ; do PID_EXIST=`ps -f -p $PID | grep java` if [ -n &#34;$PID_EXIST&#34; ]; then COUNT=0 break fi done done echo &#34;OK! --&gt;&gt;&gt; PID: $PIDS&#34;   ]]></content></entry><entry><title>3.Python容器使用入门</title><url>/post/33/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、列表 1.1、列表定义
列表用来顺序存储相同或者不同类型数据的集合，列表内存储的元素是有序的，列表使用一对[ ]表示，列表中存储的每个值叫元素，元素之间使用逗号隔开
# 存储相同数据类型 name_list=[&amp;#34;张三&amp;#34;,&amp;#34;李四&amp;#34;,&amp;#34;王五&amp;#34;] # 打印数据类型 print(type(name_list)) print(name_list) #存储不同数据类型 info=[&amp;#34;张三&amp;#34;,&amp;#34;男&amp;#34;,20] print(info) 1.2、向列表添加元素
info_list=[[&amp;#34;张三&amp;#34;,&amp;#34;男&amp;#34;,20],[&amp;#34;王五&amp;#34;,&amp;#34;男&amp;#34;,16]] # 1.append()方法 new_info=[&amp;#34;李四&amp;#34;,&amp;#34;男&amp;#34;,18] info_list.append(new_info) print(info_list) # 2.insert()方法 new_info=[&amp;#34;小美&amp;#34;,&amp;#34;女&amp;#34;,18] info_list.insert(1,new_info) print(info_list) # 3.extend()方法 new_infos=[[&amp;#34;马六&amp;#34;,&amp;#34;男&amp;#34;,18],[&amp;#34;小黑&amp;#34;,&amp;#34;女&amp;#34;,18]] info_list.extend(new_infos) print(info_list) # 4.使用+号拼接 str_list1=[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] str_list2=[&amp;#34;e&amp;#34;,&amp;#34;f&amp;#34;,&amp;#34;g&amp;#34;] str_list3=str_list1+str_list2 print(str_list3) 1.3、修改列表中元素值
# 索引修改元素值 info_list=[&amp;#34;小美&amp;#34;,&amp;#34;女&amp;#34;,20] #年龄涨一岁 info_list[2]+=1 print(info_list) 1.4、查询列表中元素
# 根据索引查询 info_list=[&amp;#34;小美&amp;#34;,&amp;#34;女&amp;#34;,20] …  ]]></content></entry><entry><title>2.Python语法基础知识</title><url>/post/32/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"><![CDATA[  1、注释 注释是我们自己语言来描述一段代码的实现逻辑，介绍这段代码具体实现的什么功能，方便我们维护和清晰地了解这段代码，增强程序的可读性
1.1、单行注释 ：用于注释一行文字或者代码，单行注释格式以 # 号开头
# 打印一行文字 print(&amp;#34;hello world&amp;#34;) # print(&amp;#34;hello world&amp;#34;) 1.2、多行注释 ：用于注释多行文字或者代码块，格式以三个英文单引号（&amp;rsquo;&amp;rsquo;&amp;rsquo;）开头，三个英文单引号（&amp;rsquo;&amp;rsquo;&amp;rsquo;）结束
&amp;#39;&amp;#39;&amp;#39; 使用多行注释 打印一行文字 &amp;#39;&amp;#39;&amp;#39; print(&amp;#34;hello world!&amp;#34;) 2、关键字与标识符 2.1、关键字
False、None、True、and、as、assert、break、class、 continue、def、del、elif、else、except、finally、for、 from、global、if、import、in、is、lambda、nonlocal、not、 or、pass、raise、return、try、while、with、yield 2.2、标识符
开发者自定义的一些符号和名称等称为标识符（如：变量名、函数名、类名等），标识符由字母、数字、下划线组成。
定义标识符的注意事项：
不能以数字开头 标识符区分大小写 不能使用Python内置关键字作为标识符名称 为了提高可读性，见名知其意 3、变量 变量就是一个装有不同类型数值的容器
3.1、变量定义
#定义姓名变量 name=&amp;#34;张三&amp;#34; #定义年龄变量 age=20 #定义性别变量 sex=&amp;#34;男&amp;#34; #打印信息 print(&amp;#34;姓名: &amp;#34;,name) print(&amp;#34;年龄: &amp;#34;,age) print(&amp;#34;性别: &amp;#34;,sex) 3.2、赋值
# 如果不是第一次出现，表示给这个变量重新赋值 #定义年龄变量 age=20 print(&amp;#34;年龄: &amp;#34;,age) #年龄增加2岁 age=age+2; print(&amp;#34;重新赋值后的年龄: &amp;#34;,age) 4、数据类型 python提供的标准数据类型：数据 …  ]]></content></entry><entry><title>1.Python开发基础工具</title><url>/post/31/</url><categories><category>Python</category></categories><tags><tag>自学记录</tag></tags><content type="html"> 1、Python3 安装包 Python3中文文档： https://docs.python.org/zh-cn/3/ Python官网下载： https://www.python.org/downloads Python3安装自行百度 2、Anaconda anaconda官网 ： https://www.anaconda.com/products/individual 简介： Anaconda就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。
Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。
Anaconda具有如下特点： 开源 安装过程简单 高性能使用Python和R语言 免费的社区支持 3、PyCharm PyCharm下载： https://www.jetbrains.com/pycharm/download/ 简介： PyCharm是一种Python IDE（集成开发软件），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，
比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。
此外该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。</content></entry></search>